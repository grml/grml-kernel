diff -Naurp linux-2.6.12.orig/drivers/usb/Makefile linux-2.6.12-grml/drivers/usb/Makefile
--- linux-2.6.12.orig/drivers/usb/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12-grml/drivers/usb/Makefile	2005-06-27 17:20:32.990156014 +0200
@@ -44,6 +44,7 @@ obj-$(CONFIG_USB_SN9C102)	+= media/
 obj-$(CONFIG_USB_STV680)	+= media/
 obj-$(CONFIG_USB_VICAM)		+= media/
 obj-$(CONFIG_USB_W9968CF)	+= media/
+obj-$(CONFIG_USB_USBVISION)	+= media/
 
 obj-$(CONFIG_USB_CATC)		+= net/
 obj-$(CONFIG_USB_KAWETH)	+= net/
diff -Naurp linux-2.6.12.orig/drivers/usb/media/i2c-algo-usb.c linux-2.6.12-grml/drivers/usb/media/i2c-algo-usb.c
--- linux-2.6.12.orig/drivers/usb/media/i2c-algo-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/i2c-algo-usb.c	2005-06-27 17:10:28.501248200 +0200
@@ -0,0 +1,290 @@
+/* 
+ * I2C_ALGO_USB
+ *  i2c algorithm for USB-I2C Bridges
+ *
+ * Copyright (c) 1999-2004 Joerg Heckenbach <joerg@heckenbach-aw.de>
+ *
+ * This module is part of usbvision driver projekt.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/usb.h>
+#include <linux/i2c.h>
+#include "i2c-algo-usb.h"
+
+int debug = 0;
+
+MODULE_PARM(debug, "i");				// debug mode of the device driver
+
+MODULE_AUTHOR("Joerg Heckenbach");
+MODULE_DESCRIPTION("I2C algorithm for USB-I2C-bridges");
+MODULE_LICENSE("GPL");
+
+
+static inline int try_write_address(struct i2c_adapter *i2c_adap,
+				    unsigned char addr, int retries)
+{
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+	void *data;
+	int i, ret = -1;
+	char buf[4];
+
+	data = i2c_get_adapdata(i2c_adap);
+	buf[0] = 0x00;
+	for (i = 0; i <= retries; i++) {
+		ret = (adap->outb(data, addr, buf, 1));
+		if (ret == 1)
+			break;	/* success! */
+		udelay(5 /*adap->udelay */ );
+		if (i == retries)	/* no success */
+			break;
+		udelay(adap->udelay);
+	}
+	if (debug) {
+		if (i) {
+			info("%s: Needed %d retries for address %#2x", __FUNCTION__, i, addr);
+			info("%s: Maybe there's no device at this address", __FUNCTION__);
+		}
+	}
+	return ret;
+}
+
+static inline int try_read_address(struct i2c_adapter *i2c_adap,
+				   unsigned char addr, int retries)
+{
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+	void *data;
+	int i, ret = -1;
+	char buf[4];
+
+	data = i2c_get_adapdata(i2c_adap);
+	for (i = 0; i <= retries; i++) {
+		ret = (adap->inb(data, addr, buf, 1));
+		if (ret == 1)
+			break;	/* success! */
+		udelay(5 /*adap->udelay */ );
+		if (i == retries)	/* no success */
+			break;
+		udelay(adap->udelay);
+	}
+	if (debug) {
+		if (i) {
+			info("%s: Needed %d retries for address %#2x", __FUNCTION__, i, addr);
+			info("%s: Maybe there's no device at this address", __FUNCTION__);
+		}
+	}
+	return ret;
+}
+
+static inline int usb_find_address(struct i2c_adapter *i2c_adap,
+				   struct i2c_msg *msg, int retries,
+				   unsigned char *add)
+{
+	unsigned short flags = msg->flags;
+	//struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+
+	unsigned char addr;
+	int ret;
+	if ((flags & I2C_M_TEN)) {
+		/* a ten bit address */
+		addr = 0xf0 | ((msg->addr >> 7) & 0x03);
+		/* try extended address code... */
+		ret = try_write_address(i2c_adap, addr, retries);
+		if (ret != 1) {
+			err("died at extended address code, while writing");
+			return -EREMOTEIO;
+		}
+		add[0] = addr;
+		if (flags & I2C_M_RD) {
+			/* okay, now switch into reading mode */
+			addr |= 0x01;
+			ret = try_read_address(i2c_adap, addr, retries);
+			if (ret != 1) {
+				err("died at extended address code, while reading");
+				return -EREMOTEIO;
+			}
+		}
+
+	} else {		/* normal 7bit address  */
+		addr = (msg->addr << 1);
+		if (flags & I2C_M_RD)
+			addr |= 1;
+		if (flags & I2C_M_REV_DIR_ADDR)
+			addr ^= 1;
+
+		add[0] = addr;
+		if (flags & I2C_M_RD)
+			ret = try_read_address(i2c_adap, addr, retries);
+		else
+			ret = try_write_address(i2c_adap, addr, retries);
+
+		if (ret != 1) {
+			return -EREMOTEIO;
+		}
+	}
+	return 0;
+}
+
+static int
+usb_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *pmsg;
+	struct i2c_algo_usb_data *adap = i2c_adap->algo_data;
+	void *data;
+	int i, ret;
+	unsigned char addr;
+
+	data = i2c_get_adapdata(i2c_adap);
+
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		ret = usb_find_address(i2c_adap, pmsg, i2c_adap->retries, &addr);
+		if (ret != 0) {
+			if (debug) {
+				info("%s: got NAK from device, message #%d\n", __FUNCTION__, i);
+			}
+			return (ret < 0) ? ret : -EREMOTEIO;
+		}
+
+		if (pmsg->flags & I2C_M_RD) {
+			/* read bytes into buffer */
+			ret = (adap->inb(data, addr, pmsg->buf, pmsg->len));
+			if (ret < pmsg->len) {
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		} else {
+			/* write bytes from buffer */
+			ret = (adap->outb(data, addr, pmsg->buf, pmsg->len));
+			if (ret < pmsg->len) {
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		}
+	}
+	return num;
+}
+
+static int algo_control(struct i2c_adapter *adapter, unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static u32 usb_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+
+/* -----exported algorithm data: -------------------------------------	*/
+
+static struct i2c_algorithm i2c_usb_algo = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner         = THIS_MODULE,
+	#endif
+#endif
+	.name          = "USB algorithm",
+	.id            = I2C_ALGO_BIT, /* FIXME */
+	.master_xfer   = usb_xfer,
+	.smbus_xfer    = NULL,
+	.slave_send    = NULL,
+	.slave_recv    = NULL,
+	.algo_control  = algo_control,
+	.functionality = usb_func,
+};
+
+
+/*
+ * registering functions to load algorithms at runtime
+ */
+int i2c_usb_add_bus(struct i2c_adapter *adap)
+{
+	/* register new adapter to i2c module... */
+
+	adap->id |= i2c_usb_algo.id;
+	adap->algo = &i2c_usb_algo;
+
+	adap->timeout = 100;	/* default values, should       */
+	adap->retries = 3;	/* be replaced by defines       */
+
+#ifdef MODULE
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 21)
+		MOD_INC_USE_COUNT;
+	#endif
+#endif
+
+	i2c_add_adapter(adap);
+
+	if (debug) {
+		info("i2c bus for %s registered", adap->name);
+	}
+
+	return 0;
+}
+
+
+int i2c_usb_del_bus(struct i2c_adapter *adap)
+{
+
+	i2c_del_adapter(adap);
+
+	if (debug) {
+		info("i2c bus for %s unregistered", adap->name);
+	}
+#ifdef MODULE
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 21)
+		MOD_DEC_USE_COUNT;
+	#endif
+#endif
+
+	return 0;
+}
+
+int __init i2c_algo_usb_init(void)
+{
+	if (debug) {
+		info("i2c usb algorithm module\n");
+	}
+	return 0;
+}
+
+
+
+EXPORT_SYMBOL(i2c_usb_add_bus);
+EXPORT_SYMBOL(i2c_usb_del_bus);
+
+#ifdef MODULE
+
+int init_module(void)
+{
+	return i2c_algo_usb_init();
+}
+
+void cleanup_module(void)
+{
+}
+#endif
+
+
diff -Naurp linux-2.6.12.orig/drivers/usb/media/i2c-algo-usb.h linux-2.6.12-grml/drivers/usb/media/i2c-algo-usb.h
--- linux-2.6.12.orig/drivers/usb/media/i2c-algo-usb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/i2c-algo-usb.h	2005-06-27 17:10:28.501248200 +0200
@@ -0,0 +1,77 @@
+/* 
+ * I2C_ALGO_USB
+ *  i2c algorithm for USB-I2C Bridges
+ *
+ * Copyright (c) 1999-2004 Joerg Heckenbach <joerg@heckenbach-aw.de>
+ *
+ * This module is part of usbvision driver projekt.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef I2C_ALGO_USB_H
+#define I2C_ALGO_USB_H 1 
+
+#include <linux/i2c.h>
+
+struct i2c_algo_usb_data {
+	void *data;		/* private data for lowlevel routines */
+	int (*inb) (void *data, unsigned char addr, char *buf, short len);
+	int (*outb) (void *data, unsigned char addr, char *buf, short len);
+
+	/* local settings */
+	int udelay;
+	int mdelay;
+	int timeout;
+};
+
+#define I2C_USB_ADAP_MAX	16
+
+int i2c_usb_add_bus(struct i2c_adapter *);
+int i2c_usb_del_bus(struct i2c_adapter *);
+
+static inline void *i2c_get_algo_usb_data (struct i2c_algo_usb_data *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_algo_usb_data (struct i2c_algo_usb_data *dev, void *data)
+{
+	dev->data = data;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static inline void *i2c_get_clientdata (struct i2c_client *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_clientdata (struct i2c_client *dev, void *data)
+{
+	dev->data = data;
+}
+
+static inline void *i2c_get_adapdata (struct i2c_adapter *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_adapdata (struct i2c_adapter *dev, void *data)
+{
+	dev->data = data;
+}
+#endif
+
+#endif //I2C_ALGO_USB_H
diff -Naurp linux-2.6.12.orig/drivers/usb/media/Kconfig linux-2.6.12-grml/drivers/usb/media/Kconfig
--- linux-2.6.12.orig/drivers/usb/media/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12-grml/drivers/usb/media/Kconfig	2005-06-27 17:15:17.613426783 +0200
@@ -210,4 +210,27 @@ config USB_PWC
 	  To compile this driver as a module, choose M here: the
 	  module will be called pwc.
 
+config USB_USBVISION
+  tristate "USB Zoran/Nogatech USBVision video support"
+  depends on USB && VIDEO_DEV
+  ---help---
+    Say Y here if you want to connect a Nogatech NT100x, or a Zoran
+    ZR36504/ZR36505 chipset based video/tv/radio grabber, to your
+    computer's USB port.
+
+    For more information, read .
+    This driver uses the Video For Linux API and I2C API.  You must enable
+    (Y or M in config) Video For Linux (under Multimedia Devices) and I2C
+    Support (under Character Devices/I2C Support) to use this driver. If
+    you have a tuner for your device.  Enable Bttv device support
+    (under Multimedia devices/Video For Linux/Video Adapters).
+
+    This code is also available as a module ( = code which can be
+    inserted in and removed from the running kernel whenever you want).
+    The module will be called usbvision.o.  If you want to compile it as a
+    module, say M here and read . This
+    video grabber has several configuration options which can be specified
+    when you load the module.  Read  to
+    learn more.
+
 
diff -Naurp linux-2.6.12.orig/drivers/usb/media/Makefile linux-2.6.12-grml/drivers/usb/media/Makefile
--- linux-2.6.12.orig/drivers/usb/media/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12-grml/drivers/usb/media/Makefile	2005-06-27 20:41:01.198625136 +0200
@@ -15,3 +15,4 @@ obj-$(CONFIG_USB_STV680)	+= stv680.o
 obj-$(CONFIG_USB_VICAM)		+= vicam.o usbvideo.o
 obj-$(CONFIG_USB_W9968CF)	+= w9968cf.o
 obj-$(CONFIG_USB_PWC)           += pwc/
+obj-$(CONFIG_USB_USBVISION)	+= usbvision.o i2c-algo-usb.o
diff -Naurp linux-2.6.12.orig/drivers/usb/media/saa7113.c linux-2.6.12-grml/drivers/usb/media/saa7113.c
--- linux-2.6.12.orig/drivers/usb/media/saa7113.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/saa7113.c	2005-06-27 17:10:28.502248070 +0200
@@ -0,0 +1,621 @@
+/* 
+ * saa7113 - Philips SAA7113A video decoder driver version 0.0.3
+ *
+ * Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+ *
+ * Slight changes for video timing and attachment output by
+ * Wolfgang Scherr <scherr@net4you.net>
+ *
+ * Changes by Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *    - moved over to linux>=2.4.x i2c protocol (1/1/2003)
+ *
+ * Changes by Michael Hunold <michael@mihu.de>
+ *    - implemented DECODER_SET_GPIO, DECODER_INIT, DECODER_SET_VBI_BYPASS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <linux/types.h>
+#include <linux/videodev.h>
+#include <asm/uaccess.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/video_decoder.h>
+
+MODULE_DESCRIPTION("Philips SAA7113 video decoder driver");
+MODULE_AUTHOR("Dave Perks, Jose Ignacio Gijon, Joerg Heckenbach, Mark McClelland, Dwaine Garden");
+MODULE_LICENSE("GPL");
+
+#define I2C_NAME(s) (s)->name
+
+static int debug = 0;
+MODULE_PARM(debug, "i");
+MODULE_PARM_DESC(debug, " Set the default Debug level.  Default: 0 (Off) - (0-1)");
+
+
+#define dprintk(num, format, args...) \
+	do { \
+		if (debug >= num) \
+			printk(format, ##args); \
+	} while (0)
+
+/* ----------------------------------------------------------------------- */
+
+struct saa7113 {
+	unsigned char reg[32];
+
+	int norm;
+	int input;
+	int enable;
+	int bright;
+	int contrast;
+	int hue;
+	int sat;
+};
+
+#define   I2C_SAA7113        0x4A
+
+/* ----------------------------------------------------------------------- */
+
+static inline int
+saa7113_write (struct i2c_client *client,
+	       u8                 reg,
+	       u8                 value)
+{
+	struct saa7113 *decoder = i2c_get_clientdata(client);
+
+	decoder->reg[reg] = value;
+	return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+static int
+saa7113_write_block (struct i2c_client *client,
+		     const u8          *data,
+		     unsigned int       len)
+{
+	int ret = -1;
+	u8 reg;
+
+	/* the saa7113 has an autoincrement function, use it if
+	 * the adapter understands raw I2C */
+	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		/* do raw I2C, not smbus compatible */
+		struct saa7113 *decoder = i2c_get_clientdata(client);
+		struct i2c_msg msg;
+		u8 block_data[32];
+
+		msg.addr = client->addr;
+		msg.flags = 0;
+		while (len >= 2) {
+			msg.buf = (char *) block_data;
+			msg.len = 0;
+			block_data[msg.len++] = reg = data[0];
+			do {
+				block_data[msg.len++] =
+				    decoder->reg[reg++] = data[1];
+				len -= 2;
+				data += 2;
+			} while (len >= 2 && data[0] == reg &&
+				 msg.len < 32);
+			if ((ret = i2c_transfer(client->adapter,
+						&msg, 1)) < 0)
+				break;
+		}
+	} else {
+		/* do some slow I2C emulation kind of thing */
+		while (len >= 2) {
+			reg = *data++;
+			if ((ret = saa7113_write(client, reg,
+						 *data++)) < 0)
+				break;
+			len -= 2;
+		}
+	}
+
+	return ret;
+}
+
+static int
+saa7113_init_decoder (struct i2c_client *client,
+	      struct video_decoder_init *init)
+{
+	return saa7113_write_block(client, init->data, init->len);
+}
+
+static inline int
+saa7113_read (struct i2c_client *client,
+	      u8                 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+/* ----------------------------------------------------------------------- */
+
+static const unsigned char saa7113_i2c_init[] = {
+	0x00, 0x00,	/* PH7113_CHIP_VERSION 00 - ID byte */
+	0x01, 0x08,     /* PH7113_INCREMENT_DELAY - (1) (1) (1) (1) IDEL3 IDEL2 IDELL1 IDEL0 */
+        0x02, 0xc0,     /* PH7113_ANALOG_INPUT_CONTR_1 - FUSE1 FUSE0 GUDL1 GUDL0 MODE3 MODE2 MODE1 MODE0 */
+        0x03, 0x23,     /* PH7113_ANALOG_INPUT_CONTR_2 - (1) HLNRS VBSL WPOFF HOLDG GAFIX GAI28 GAI18 */
+        0x04, 0x00,	/* PH7113_ANALOG_INPUT_CONTR_3 - GAI17 GAI16 GAI15 GAI14 GAI13 GAI12 GAI11 GAI10 */
+        0x05, 0x00,     /* PH7113_ANALOG_INPUT_CONTR_4 - GAI27 GAI26 GAI25 GAI24 GAI23 GAI22 GAI21 GAI20 */
+        0x06, 0xeb,     /* PH7113_HORIZONTAL_SYNC_START - HSB7 HSB6 HSB5 HSB4 HSB3 HSB2 HSB1 HSB0 */
+        0x07, 0xe0,     /* PH7113_HORIZONTAL_SYNC_STOP - HSS7 HSS6 HSS5 HSS4 HSS3 HSS2 HSS1 HSS0 */
+        0x08, 0x88,     /* PH7113_SYNC_CONTROL - AUFD FSEL FOET HTC1 HTC0 HPLL VNOI1 VNOI0 */
+        0x09, 0x00,	/* PH7113_LUMINANCE_CONTROL - BYPS PREF BPSS1 BPSS0 VBLB UPTCV APER1 APER0 */
+        0x0a, 0x80,	/* PH7113_LUMINANCE_BRIGHTNESS - BRIG7 BRIG6 BRIG5 BRIG4 BRIG3 BRIG2 BRIG1 BRIG0 */
+        0x0b, 0x47,	/* PH7113_LUMINANCE_CONTRAST - CONT7 CONT6 CONT5 CONT4 CONT3 CONT2 CONT1 CONT0 */
+        0x0c, 0x40,	/* PH7113_CHROMA_SATURATION - SATN7 SATN6 SATN5 SATN4 SATN3 SATN2 SATN1 SATN0 */
+        0x0d, 0x00,	/* PH7113_CHROMA_HUE_CONTROL - HUEC7 HUEC6 HUEC5 HUEC4 HUEC3 HUEC2 HUEC1 HUEC0 */
+        0x0e, 0x01,	/* PH7113_CHROMA_CONTROL - CDTO CSTD2 CSTD1 CSTD0 DCCF FCTC CHBW1 CHBW0 */
+        0x0f, 0xaa, 	/* PH7113_CHROMA_GAIN_CONTROL - ACGC CGAIN6 CGAIN5 CGAIN4 CGAIN3 CGAIN2 CGAIN1 CGAIN0 */
+        0x10, 0x00,	/* PH7113_FORMAT_DELAY_CONTROL - OFTS1 OFTS0 HDEL1 HDEL0 VRLN YDEL2 YDEL1 YDEL0 */
+        0x11, 0x1C,	/* PH7113_OUTPUT_CONTROL_1 - GPSW1 CM99 GPSW0 HLSEL OEYC OERT VIPB COLO */
+        0x12, 0x01, 	/* PH7113_OUTPUT_CONTROL_2 - RTSE13 RTSE12 RTSE11 RTSE10 RTSE03 RTSE02 RTSE01 RTSE00 */
+        0x13, 0x00,	/* PH7113_OUTPUT_CONTROL_3 - ADLSB (1) (1) OLDSB FIDP (1) AOSL1 AOSL0 */
+	0x14, 0x00,	/* RESERVED 14 - (1) (1) (1) (1) (1) (1) (1) (1) */
+        0x15, 0x00,	/* PH7113_V_GATE1_START - VSTA7 VSTA6 VSTA5 VSTA4 VSTA3 VSTA2 VSTA1 VSTA0 */
+        0x16, 0x00,	/* PH7113_V_GATE1_STOP - VSTO7 VSTO6 VSTO5 VSTO4 VSTO3 VSTO2 VSTO1 VSTO0 */
+        0x17, 0x00,	/* PH7113_V_GATE1_MSB - (1) (1) (1) (1) (1) (1) VSTO8 VSTA8 */
+};
+
+static int
+saa7113_command (struct i2c_client *client,
+		 unsigned int       cmd,
+		 void              *arg)
+{
+	struct saa7113 *decoder = i2c_get_clientdata(client);
+
+	switch (cmd) {
+
+	case 0:
+	case DECODER_INIT:
+	{
+		struct video_decoder_init *init = arg;
+		if (NULL != init)
+			return saa7113_init_decoder(client, init);
+		else {
+			struct video_decoder_init vdi;
+			vdi.data = saa7113_i2c_init;
+			vdi.len = sizeof(saa7113_i2c_init);
+			return saa7113_init_decoder(client, &vdi);
+		}
+	}
+
+	case DECODER_DUMP:
+	{
+		int i;
+
+		for (i = 0; i < 32; i += 16) {
+			int j;
+
+			printk(KERN_DEBUG "%s: %03x", I2C_NAME(client), i);
+			for (j = 0; j < 16; ++j) {
+				printk(" %02x",
+				       saa7113_read(client, i + j));
+			}
+			printk("\n");
+		}
+	}
+		break;
+
+	case DECODER_GET_CAPABILITIES:
+	{
+		struct video_decoder_capability *cap = arg;
+
+		cap->flags = VIDEO_DECODER_PAL |
+			     VIDEO_DECODER_NTSC |
+			     VIDEO_DECODER_SECAM |
+			     VIDEO_DECODER_AUTO |
+			     VIDEO_DECODER_CCIR;
+		cap->inputs = 8;
+		cap->outputs = 1;
+	}
+		break;
+
+	case DECODER_GET_STATUS:
+	{
+		int *iarg = arg;
+		int status;
+		int res;
+
+		status = saa7113_read(client, 0x1f);
+		dprintk(1, KERN_DEBUG "%s status: 0x%02x\n", I2C_NAME(client),
+			status);
+		res = 0;
+		if ((status & (1 << 6)) == 0) {
+			res |= DECODER_STATUS_GOOD;
+		}
+		switch (decoder->norm) {
+		case VIDEO_MODE_NTSC:
+			res |= DECODER_STATUS_NTSC;
+			break;
+		case VIDEO_MODE_PAL:
+			res |= DECODER_STATUS_PAL;
+			break;
+		case VIDEO_MODE_SECAM:
+			res |= DECODER_STATUS_SECAM;
+			break;
+		default:
+		case VIDEO_MODE_AUTO:
+			if ((status & (1 << 5)) != 0) {
+				res |= DECODER_STATUS_NTSC;
+			} else {
+				res |= DECODER_STATUS_PAL;
+			}
+			break;
+		}
+		if ((status & (1 << 0)) != 0) {
+			res |= DECODER_STATUS_COLOR;
+		}
+		*iarg = res;
+	}
+		break;
+
+	case DECODER_SET_GPIO:
+	{
+		int *iarg = arg;
+		if (0 != *iarg) {
+			saa7113_write(client, 0x11,
+				(decoder->reg[0x11] | 0x80));
+		} else {
+			saa7113_write(client, 0x11,
+				(decoder->reg[0x11] & 0x7f));
+		}
+		break;
+	}
+
+	case DECODER_SET_VBI_BYPASS:
+	{
+		int *iarg = arg;
+		if (0 != *iarg) {
+			saa7113_write(client, 0x13,
+				(decoder->reg[0x13] & 0xf0) | 0x0a);
+		} else {
+			saa7113_write(client, 0x13,
+				(decoder->reg[0x13] & 0xf0));
+		}
+		break;
+	}
+
+	case DECODER_SET_NORM:
+	{
+		int *iarg = arg;
+
+		switch (*iarg) {
+
+		case VIDEO_MODE_NTSC:
+			saa7113_write(client, 0x08,
+				      (decoder->reg[0x08] & 0x3f) | 0x40);
+			saa7113_write(client, 0x0e,
+				      (decoder->reg[0x0e] & 0x8f));
+			break;
+
+		case VIDEO_MODE_PAL:
+			saa7113_write(client, 0x08,
+				      (decoder->reg[0x08] & 0x3f) | 0x00);
+			saa7113_write(client, 0x0e,
+				      (decoder->reg[0x0e] & 0x8f));
+			break;
+
+		case VIDEO_MODE_SECAM:
+			saa7113_write(client, 0x08,
+				      (decoder->reg[0x0e] & 0x3f) | 0x00);
+			saa7113_write(client, 0x0e,
+				      (decoder->reg[0x0e] & 0x8f) | 0x50);
+			break;
+
+		case VIDEO_MODE_AUTO:
+			saa7113_write(client, 0x08,
+				      (decoder->reg[0x08] & 0x3f) | 0x80);
+			saa7113_write(client, 0x0e,
+				      (decoder->reg[0x0e] & 0x8f));
+			break;
+
+		default:
+			return -EINVAL;
+
+		}
+		decoder->norm = *iarg;
+	}
+		break;
+
+	case DECODER_SET_INPUT:
+	{
+		int *iarg = arg;
+
+		if (*iarg < 0 || *iarg > 7) {
+			return -EINVAL;
+		}
+
+		if (decoder->input != *iarg) {
+			decoder->input = *iarg;
+			/* select mode */
+			saa7113_write(client, 0x02,
+				      (decoder->
+				       reg[0x02] & 0xf8) | decoder->input);
+			/* bypass chrominance trap for modes 4..7 */
+			saa7113_write(client, 0x09,
+				      (decoder->
+				       reg[0x09] & 0x7f) | ((decoder->
+							     input >
+							     3) ? 0x80 :
+							    0));
+		}
+	}
+		break;
+
+	case DECODER_SET_OUTPUT:
+	{
+		int *iarg = arg;
+
+		/* not much choice of outputs */
+		if (*iarg != 0) {
+			return -EINVAL;
+		}
+	}
+		break;
+
+	case DECODER_ENABLE_OUTPUT:
+	{
+		int *iarg = arg;
+		int enable = (*iarg != 0);
+
+		if (decoder->enable != enable) {
+			decoder->enable = enable;
+
+			/* RJ: If output should be disabled (for
+			 * playing videos), we also need a open PLL.
+			 * The input is set to 0 (where no input
+			 * source is connected), although this
+			 * is not necessary.
+			 *
+			 * If output should be enabled, we have to
+			 * reverse the above.
+			 */
+
+			if (decoder->enable) {
+				saa7113_write(client, 0x02,
+					      (decoder->
+					       reg[0x02] & 0xf8) |
+					      decoder->input);
+				saa7113_write(client, 0x08,
+					      (decoder->reg[0x08] & 0xfb));
+				saa7113_write(client, 0x11,
+					      (decoder->
+					       reg[0x11] & 0xf3) | 0x0c);
+			} else {
+				saa7113_write(client, 0x02,
+					      (decoder->reg[0x02] & 0xf8));
+				saa7113_write(client, 0x08,
+					      (decoder->
+					       reg[0x08] & 0xfb) | 0x04);
+				saa7113_write(client, 0x11,
+					      (decoder->reg[0x11] & 0xf3));
+			}
+		}
+	}
+		break;
+
+	case DECODER_SET_PICTURE:
+	{
+		struct video_picture *pic = arg;
+
+		if (decoder->bright != pic->brightness) {
+			/* We want 0 to 255 we get 0-65535 */
+			decoder->bright = pic->brightness;
+			saa7113_write(client, 0x0a, decoder->bright >> 8);
+		}
+		if (decoder->contrast != pic->contrast) {
+			/* We want 0 to 127 we get 0-65535 */
+			decoder->contrast = pic->contrast;
+			saa7113_write(client, 0x0b,
+				      decoder->contrast >> 9);
+		}
+		if (decoder->sat != pic->colour) {
+			/* We want 0 to 127 we get 0-65535 */
+			decoder->sat = pic->colour;
+			saa7113_write(client, 0x0c, decoder->sat >> 9);
+		}
+		if (decoder->hue != pic->hue) {
+			/* We want -128 to 127 we get 0-65535 */
+			decoder->hue = pic->hue;
+			saa7113_write(client, 0x0d,
+				      (decoder->hue - 32768) >> 8);
+		}
+	}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+/*
+ * Generic i2c probe
+ * concerning the addresses: i2c wants 7 bit (without the r/w bit), so '>>1'
+ */
+static unsigned short normal_i2c[] = { I2C_SAA7113 >> 1, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+
+static unsigned short probe[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2] = { I2C_CLIENT_END , I2C_CLIENT_END };
+                                                                                
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c		= normal_i2c,
+	.normal_i2c_range	= normal_i2c_range,
+	.probe			= probe,
+	.probe_range		= probe_range,
+	.ignore			= ignore,
+	.ignore_range		= ignore_range,
+	.force			= force
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+static int saa7113_i2c_id = 0;
+#endif
+
+static struct i2c_driver i2c_driver_saa7113;
+
+static int
+saa7113_detect_client (struct i2c_adapter *adapter,
+		       int                 address,
+		       int                 kind)
+{
+	int i;
+	struct i2c_client *client;
+	struct saa7113 *decoder;
+	struct video_decoder_init vdi;
+
+	dprintk(1,
+		KERN_INFO
+		"saa7113.c: detecting saa7113 client on address 0x%x\n",
+		address << 1);
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return 0;
+
+	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (client == 0)
+		return -ENOMEM;
+	memset(client, 0, sizeof(struct i2c_client));
+	client->addr = address;
+	client->adapter = adapter;
+	client->driver = &i2c_driver_saa7113;
+	client->flags = I2C_CLIENT_ALLOW_USE;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	client->id = saa7113_i2c_id++;
+	snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
+	"saa7111[%d]", client->id); 
+#else
+	strlcpy(I2C_NAME(client), "saa7113", sizeof(I2C_NAME(client)));
+#endif
+	decoder = kmalloc(sizeof(struct saa7113), GFP_KERNEL);
+	if (decoder == NULL) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	memset(decoder, 0, sizeof(struct saa7113));
+	decoder->norm = VIDEO_MODE_NTSC;
+	decoder->input = 0;
+	decoder->enable = 1;
+	decoder->bright = 32768;
+	decoder->contrast = 32768;
+	decoder->hue = 32768;
+	decoder->sat = 32768;
+	i2c_set_clientdata(client, decoder);
+
+	i = i2c_attach_client(client);
+	if (i) {
+		kfree(client);
+		kfree(decoder);
+		return i;
+	}
+
+	vdi.data = saa7113_i2c_init;
+	vdi.len = sizeof(saa7113_i2c_init);
+	i = saa7113_init_decoder(client, &vdi);
+	if (i < 0) {
+		dprintk(1, KERN_ERR "%s_attach error: init status %d\n",
+			I2C_NAME(client), i);
+	} else {
+		dprintk(1,
+			KERN_INFO
+			"%s_attach: chip version %x at address 0x%x\n",
+			I2C_NAME(client), saa7113_read(client, 0x00) >> 4,
+			client->addr << 1);
+	}
+
+	return 0;
+}
+
+static int
+saa7113_attach_adapter (struct i2c_adapter *adapter)
+{
+	dprintk(1,
+		KERN_INFO
+		"saa7113.c: starting probe for adapter %s (0x%x)\n",
+		I2C_NAME(adapter), adapter->id);
+	return i2c_probe(adapter, &addr_data, &saa7113_detect_client);
+}
+
+static int
+saa7113_detach_client (struct i2c_client *client)
+{
+	struct saa7113 *decoder = i2c_get_clientdata(client);
+	int err;
+
+	err = i2c_detach_client(client);
+	if (err) {
+		return err;
+	}
+
+	kfree(decoder);
+	kfree(client);
+
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_driver i2c_driver_saa7113 = {
+	.owner = THIS_MODULE,
+	.name = "saa7113",
+
+	.id = I2C_DRIVERID_SAA7113,
+	.flags = I2C_DF_NOTIFY,
+
+	.attach_adapter = saa7113_attach_adapter,
+	.detach_client = saa7113_detach_client,
+	.command = saa7113_command,
+};
+
+static int __init
+saa7113_init (void)
+{
+	return i2c_add_driver(&i2c_driver_saa7113);
+}
+
+static void __exit
+saa7113_exit (void)
+{
+	i2c_del_driver(&i2c_driver_saa7113);
+}
+
+module_init(saa7113_init);
+module_exit(saa7113_exit);
diff -Naurp linux-2.6.12.orig/drivers/usb/media/usbvision.c linux-2.6.12-grml/drivers/usb/media/usbvision.c
--- linux-2.6.12.orig/drivers/usb/media/usbvision.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/usbvision.c	2005-06-27 17:10:28.505247677 +0200
@@ -0,0 +1,6296 @@
+/*
+ * USB USBVISION Video device driver 0.9.8.2cvs (For Kernel 2.4.19-2.4.30 + 2.6.0-2.6.11)
+ *
+ * 
+ *
+ * Copyright (c) 1999-2005 Joerg Heckenbach <joerg@heckenbach-aw.de>
+ *
+ * This module is part of usbvision driver project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Let's call the version 0.... until compression decoding is completely
+ * implemented.
+ *
+ * This driver is written by Jose Ignacio Gijon and Joerg Heckenbach.
+ * It was based on USB CPiA driver written by Peter Pregler,
+ * Scott J. Bertin and Johannes Erdfelt
+ * Ideas are taken from bttv driver by Ralph Metzler, Marcus Metzler &
+ * Gerd Knorr and zoran 36120/36125 driver by Pauline Middelink
+ * Updates to driver completed by Dwaine P. Garden
+ *
+ * History:
+ *
+ * Mar. 2000 - 15.12.2000:  (0.0.0 - 0.2.0)
+ *     Several alpha drivers and the first beta.
+ *
+ * Since Dec. 2000:  (0.2.1) or (v2.1)
+ *     Code changes or updates by Dwaine Garden and every other person.
+ *
+ *     Added: New Hauppauge TV device  Vendor  ID: 0x0573
+ *                                     Product ID: 0x4D01
+ *            (Thanks to Giovanni Garberoglio)
+ *
+ *     Added: UK Hauppauge WinTV-USB   Vendor  ID: 0x0573
+ *                                     Product ID: 0x4D02
+ *            (Thanks to Derek Freeman-Jones)
+ *
+ * Feb, 2001 - Apr 08, 2001:  (0.3.0)
+ *     - Some fixes. Driver is now more stable.
+ *     - Scratch is organized as ring-buffer now for better performance
+ *     - DGA (overlay) is now supported.
+ *       !!!!Danger!!!! Clipping is not yet implemented. Your system will
+ *       crash if your video window leaves the screen!!!
+ *     - Max. Framesize is set to 320x240. There isn't more memory on the
+ *       nt1003 video device for the FIFO.
+ *     - Supported video palettes: RGB565, RGB555, RGB24, RGB32
+ *
+ *
+ * Apr 15, 2001:  (0.3.1-test...)
+ *     - Clipping is implemented
+ *     - NTSC is now coloured (Thanks to Dwaine Garden)
+ *     - Added SECAM colour detection in saa7111-new
+ *     - Added: French Hauppauge WinTV USB  Vendor ID: 0x0573
+ *                                          Product ID: 0x4D03
+ *              (Thanks to Julius Hrivnac)
+ *     - Added: US Hauppauge WINTV USB  Vendor ID: 0x0573
+ *                                      Product ID: 0x4D00
+ *              (Thanks to  Derrick J Brashear)
+ *     - Changes for adding new devices. There's now a table in usbvision.h.
+ *       Adding your devices data to the usbvision_device_data table is all
+ *       you need to add a new device.
+ *
+ * May 11, 2001: (0.3.2-test...) (Thanks to Derek Freeman-Jones)
+ *     - Support YUV422 raw format for people with hardware scaling.
+ *     - Only power on the device when opened (use option PowerOnAtOpen=0 to disable it).
+ *     - Turn off audio so we can listen to Line In.
+ *
+ * July 5, 2001 - (Patch the driver to run with Kernel 2.4.6)
+ *     - Fixed a problem with the number of parameters passed to video_register_device.
+ *
+ * July 6, 2001 - Added: HAUPPAUGE WINTV-USB FM USA Vendor  ID: 0x0573
+ *                                              	Product ID: 0x4D10
+ *       (Thanks to Braddock Gaskill)
+ *                Added: USBGear USBG-V1 resp. HAMA USB
+ *                                      Vendor  ID: 0x0573
+ *                                      Product ID: 0x0003
+ *       (Thanks to Bradley A. Singletary and Juergen Weigert)
+ *
+ * Jan 24, 2002 - (0.3.3-test...)
+ *     - Moved all global variables that are device specific the usb_usbvision struct
+ *     - Fixed the 64x48 unchangable image in xawtv when starting it with overlay
+ *     - Add VideoNorm and TunerType to the usb_device_data table
+ *     - Checked the audio channels and mute for HAUPPAUGE WinTV USB FM
+ *     - Implemented the power on when opening the device. But some software opens
+ *       the device several times when starting. So the i2c parts are just registered
+ *       by an open, when they become deregistered by the next close. You can speed
+ *       up tuner detection, when adding "options tuner addr=your_addr" to /etc/modules.conf
+ *     - Begin to resize the frame in width and height. So it will be possible to watch i.e.
+ *       384x288 pixels at 23 fps.
+ *
+ * Feb 10, 2002
+ *     - Added radio device
+ *
+ *
+ * Jul 30, 2002 - (Thanks Cameron Maxwell)
+ *     - Changes to usbvision.h --fixed usbvision device data structure, incorrectly had (0x0573, 0x4d21) for WinTV-USB II, should be 0x4d20.
+ *     - Changes for device WinTV-USB II (0x0573. 0x4D21).  It does not have a FM tuner.
+ *     - Added the real device HAUPPAUGE WINTV-USB II (PAL) to the device structure in usbvision.h.
+ *     - Changes to saa7113-new, the video is 8 bit data for the Phillips SAA7113 not 16bit like SAA7111.
+ *     - Tuned lots of setup registers for the Phillips SAA7113 video chipset.
+ *     - Changes to the supplied makefile. (Dwaine Garden) Still needs to be fixed so it will compile modules on different distrubutions.
+ *
+ *
+ * Aug 10, 2002 - (Thanks Mike Klinke)
+ *     - Changes to usbvision.txt -- Fixed instructions on the location to copy the contents of the tgz file.
+ *     - Added device WinTV-USB FM Model 621 (0x0573. 0x4D30). There is another device which carries the same name. Kept that device in the device structure.
+ *
+ * Aug 12, 2002 - Dwaine Garden
+ *     - Added the ability to read the NT100x chip for the MaxISOPacketLength and USB Bandwidth
+ *       Setting of the video device.
+ *     - Adjustments to the SAA7113H code for proper video output.
+ *     - Changes to usbvision.h, so all the devices with FM tuners are working.
+ *
+ * Feb 10, 2003 - Joerg Heckenbach
+ *     - fixed endian bug for Motorola PPC
+ *
+ * Feb 13, 2003 - Joerg Heckenbach
+ *     - fixed Vin_Reg setting and presetting from usbvision_device_data()
+ *
+ * Apr 19, 2003 - Dwaine Garden
+ *     - Fixed compiling errors under RedHat v9.0. from uvirt_to_kva and usbvision_mmap. (Thanks Cameron Maxwell)
+ *     - Changed pte_offset to pte_offset_kernel.
+ *     - Changed remap_page_range and added additional parameter to function.
+ *     - Change setup parameters for the D-Link V100 USB device
+ *     - Added a new device to the usbvision driver.  Pinnacle Studio PCTV USB (PAL) 0x2304 0x0110
+ *     - Screwed up the sourceforge.net cvs respository!  8*)
+ *
+ * Apr 22, 2002 - Dwaine Garden
+ *     - Added a new device to the usbvision driver. Dazzle DVC-80 (PAL) 0x07d0 0x0004. (Thanks Carl Anderson)
+ *     - Changes to some of the comments.
+ *
+ * June 06, 2002 - Ivan, Dwaine Garden
+ *     - Ivan updates for fine tuning device parameters without driver recompiling. (Ivan)
+ *     - Changes to some of the comments. (Dwaine Garden)
+ *     - Changes to the makefile - Better CPU settings. (Ivan)
+ *     - Changes to device Hauppauge WinTv-USB III (PAL) FM Model 568 - Fine tuning parameters (Ivan)
+ *
+ *
+ * Oct 16, 2003 - 0.9.0 - Joerg Heckenbach
+ *     - Implementation of the first part of the decompression algorithm for intra frames.
+ *       The resolution has to be 320x240. A dynamic adaption of compression deepth is
+ *       missing yet.
+ *
+ * Oct 22, 2003 - 0.9.1 - Joerg Heckenbach
+ *     - Implementation of the decompression algorithm for inter frames.
+ *       The resolution still has to be 320x240.
+ *
+ * Nov 2003 - Feb 2004 - 0.9.2 to 0.9.3 - Joerg Heckenbach
+ *     - Implement last unknown compressed block type. But color is still noisy.
+ *     - Finding criteria for adaptive compression adjustment.
+ *     - Porting to 2.6 kernels, but still working under 2.4
+ *
+ * Feb 04, 2004 - 0.9.4 Joerg Heckenbach
+ *     - Found bug in color decompression. Color is OK now.
+ *
+ * Feb 09, 2004 - 0.9.5 Joerg Heckenbach
+ *     - Add auto-recognition of chip type NT1003 or NT1004.
+ *     - Add adaptive compression adjustment.
+ *     - Patched saa7113 multiplexer switching (Thanks to Orlando F.S. Bordoni)
+ *
+ * Feb 24, 2004 - 0.9.6 Joerg Heckenbach
+ *     - Add a timer to wait before poweroff at close, to save start time in
+ *       some video applications
+ *
+ * Mar 4, 2004 - 0.9.6 Dwaine Garden
+ *     - Added device Global Village GV-007 (NTSC) to usbvision.h (Thanks to Abe Skolnik)
+ *     - Forgot to add this device to the driver. 8*)
+ *
+ * June 2, 2004 - 0.9.6 Dwaine Garden
+ *     - Fixed sourceforge.net cvs repository.
+ *     - Added #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,26) for .owner to help compiling under kernels 2.4.x which do not have the i2c v2.8.x updates.
+ *     - Added device Hauppauge WinTv-USB III (PAL) FM Model 597 to usbvision.h	
+ *
+ * July 1, 2004 -0.9.6 Dwaine Garden
+ *     - Patch was submitted by Hal Finkel to fix the problem with the tuner not working under kernel 2.6.7.
+ *     - Thanks Hal.....
+ *
+ * July 30, 2004 - 0.9.6 Dwaine Garden
+ *     - Patch was submitted by Tobias Diaz to fix Model ID mismatch in usbvision.h.
+ *     - Thanks.....
+ *
+ * August 12, 2004 - 0.9.6 Dwaine Garden
+ *     - Updated the readme file so people could install the driver under the configuration file for kernel 2.6.x recompiles.  Now people can use make xconfig!
+ *     - Added new device "Camtel Technology Corp TVB330-USB FM".
+ *     - Sourceforge.net CVS has been updated with all the changes.
+ *
+ * August 20, 2004 - 0.9.7 Dwaine Garden
+ *     - Added Device "Hauppauge USB Live Model 600"
+ *     - Fixed up all the devices which did not have a default tuner type in usbvision.h.  It's best guess, at least until someone with the device tells me otherwise.
+ *     - Sourceforge.net CVS has been updated with all the changes.
+ *     - Clean up the driver.
+ *
+ * September 13, 2004 - 0.9.8 Dwaine Garden
+ *     - Changed usbvision_muxsel to address the problem with black & white s-video output for NT1004 devices with saa7114 video decoder.  Thanks to Emmanuel for the patch and testing.
+ *     - Fixed up SECAM devices which could not properly output video.  Changes to usbmuxsel.  Thanks to Emmanuel for the patch and everyone with a SECAM device which help test.
+ *     - Removed some commented out code.  Clean up.
+ *     - Tried to fix up the annoying empty directories in the sourceforge.net cvs.   Fuck it up again.  8*(	
+ *
+ * November 15, 2004 - 0.9.8 Dwaine Garden
+ *     - Release new tar - 0.9.8 on sourceforge.net
+ *     - Added some new devices to usbvision.h WinTV USB Model 602 40201 Rev B282, Hauppague WinTV USB Model 602 40201 Rev B285
+ *     - Added better compatibility for 2.6.x kernels.
+ *     - Hardware full screen scaling in grabdisplay mode.
+ *     - Better support for sysfs.  More code to follow for both video device and radio device.	Device information is located at /sys/class/video4linux/video0
+ *     - Added module_param so loaded module parameters are displayed in sysfs.  Driver parameters should show up in /sys/module/usbvision
+ *     - Adjusted the SAA7111 registers to match the 2.6.x kernel SAA7111 code. Thanks to the person which helped test.
+ *     - Changed to wait_event_interruptible. For all the people running Fedora 2.
+ *     - Added some screenshots of actual video captures on sourceforge.net.
+ *
+ * November 24, 2004 - 0.9.8.1cvs Dwaine Garden
+ *     - Added patch to check for palette and format in VIDIOCSPICT.  Helix Producer should work fine with the driver now.  Thanks Jason Simpson
+ *     - Two device description changes and two additions for the maintainer of usb.ids.
+ *
+ * December 2, 2004 - 0.9.8.1cvs Dwaine Garden
+ *     - Added patch for YUV420P and YUV422P video output.  Thanks to Alex Smith.
+ *     - Better support for mythtv.
+ *
+ * January 2, 2005 - 0.9.8.1cvs Dwaine Garden
+ *     - Setup that you can specify which device is used for video.  Default is auto detect next available device number eg.  /dev/videoX  
+ *     - Setup that you can specify which device is used for radio.  Default is auto detect next available device number eg.  /dev/radioX
+ *     - usb_unlink_urb() is deprecated for synchronous unlinks.  Using usb_kill_urb instead.
+ *     - usbvision_kvirt_to_pa is deprecated.  Removed.
+ *     - Changes are related to kernel changes for 2.6.10. (Fedora 4)
+ *
+ * February 2, 2005 - 0.9.8.1cvs Dwaine Garden
+ *     - Added a new device to usbvision.h Dazzle DVC 50.  Thanks to Luiz S.
+ *
+ * March 29, 2005 - 0.9.8.1cvs Dwaine Garden
+ *     - Fixed compile error with saa7113 under kernels 2.6.11+
+ *     - Added module parameter to help people with Black and White output with using s-video input.  Some cables and input device are wired differently.
+ *     - Removed the .id from the i2c usbvision template.  There was a change to the i2c with kernels 2.6.11+.
+ *
+ * April 9, 2005 - 0.9.8.1cvs Dwaine Garden
+ *     - Added in the 2.4 and 2.6 readme files the SwitchSVideoInput parameter information.  This will help people setup the right values for the parameter.
+ *       If your device experiences Black and White images with the S-Video Input.  Set this parameter to 1 when loading the module.
+ *     - Replaced the wrong 2.6 readme file.  I lost the right version.  Someone sent me the right version by e-mail.  Thanks.
+ *     - Released new module version on sourceforge.net.  So everyone can enjoy all the fixes and additional device support.
+ *
+ * April 20, 2005 - 0.9.8.2cvs Dwaine Garden
+ *     - Release lock in usbvision_v4l_read_done.  -Thanks to nplanel for the patch.
+ *     - Additional comments to the driver.
+ *     - Fixed some spelling mistakes.  8*)	
+ *
+ * April 23, 2005 - 0.9.8.2cvs Joerg Heckenbach
+ *     - Found bug in usbvision line counting. Now there should be no spurious lines in the image any longer.
+ *     - Swapped usbvision_register_video and usbvision_configure_video to fix problem with PowerOnAtOpen=0. 
+ *       Thanks to Erwan Velu
+ *
+ * April 26, 2005 - 0.9.8.2cvs Joerg Heckenbach
+ *     - Fixed problem with rmmod module and oppses. Replaced vfree(usbvision->overlay_base) with iounmap(usbvision->overlay_base).
+ *     - Added function usb_get_dev(dev) and ; To help with unloading the module multiple times without crashing. 
+ *       (Keep the reference count in kobjects correct)
+ *
+ * TODO:
+ *     - use submit_urb for all setup packets
+ *     - Fix memory settings for nt1004. It is 4 times as big as the
+ *       nt1003 memory.
+ *     - Add audio on endpoint 3 for nt1004 chip.  Seems impossible, needs a codec interface.  Which one?
+ *     - Clean up the driver.
+ *     - optimization for performance.
+ *     - Add Videotext capability (VBI).  Working on it.....
+ *     - Check audio for other devices
+ *     - Add v4l2 interface
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/smp_lock.h>
+#include <linux/videodev.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <asm/io.h>
+#include <linux/video_decoder.h>
+#include <linux/i2c.h>
+#include "i2c-algo-usb.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	#include <linux/proc_fs.h>
+	#include <linux/tqueue.h>
+	#include <linux/wrapper.h>
+	#include <../drivers/media/video/tuner.h>
+	#include <../drivers/media/video/audiochip.h>
+#else
+	#include <linux/moduleparam.h>
+	#include <linux/workqueue.h>
+	#include <media/tuner.h>
+	#include <media/audiochip.h>
+#endif
+
+#ifdef CONFIG_KMOD
+#include <linux/kmod.h>
+#endif
+
+#include "usbvision.h"
+#include "usbvision_ioctl.h"
+
+
+#define DRIVER_VERSION "0.9.8.2cvs for Linux kernels 2.4.19-2.4.30 + 2.6.0-2.6.11, compiled at "__DATE__", "__TIME__
+#define EMAIL "joerg@heckenbach-aw.de"
+#define DRIVER_AUTHOR "Joerg Heckenbach <joerg@heckenbach-aw.de>, Dwaine Garden <DwaineGarden@rogers.com>"
+#define DRIVER_DESC "USBVision USB Video Device Driver for Linux"
+#define DRIVER_LICENSE "GPL"
+#define DRIVER_ALIAS "USBVision"
+
+#define	ENABLE_HEXDUMP	0	/* Enable if you need it */
+
+
+#define USBVISION_DEBUG		/* Turn on debug messages */
+
+#ifdef USBVISION_DEBUG
+	#define PDEBUG(level, fmt, args...) \
+		if (debug & (level)) info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else
+	#define PDEBUG(level, fmt, args...) do {} while(0)
+#endif
+
+#define DBG_PROCFS	1<<2
+#define DBG_IOCTL	1<<3
+#define DBG_IO		1<<4
+#define DBG_RIO		1<<5
+#define DBG_HEADER	1<<7
+#define DBG_PROBE	1<<8
+#define DBG_IRQ		1<<9
+#define DBG_ISOC	1<<10
+#define DBG_PARSE	1<<11
+#define DBG_SCRATCH	1<<12
+#define DBG_FUNC	1<<13
+#define DBG_I2C		1<<14
+
+#define DEBUG(x...) 								/* General Debug */
+#define IODEBUG(x...)								/* Debug IO */
+#define OVDEBUG(x...) 								/* Debug overlay */
+#define MDEBUG(x...)								/* Debug memory management */
+
+//String operations
+#define rmspace(str)	while(*str==' ') str++;
+#define goto2next(str)	while(*str!=' ') str++; while(*str==' ') str++;
+
+
+static int usbvision_nr = 0;			// sequential number of usbvision device
+
+
+static const int max_imgwidth = MAX_FRAME_WIDTH;
+static const int max_imgheight = MAX_FRAME_HEIGHT;
+static const int min_imgwidth = MIN_FRAME_WIDTH;
+static const int min_imgheight = MIN_FRAME_HEIGHT;
+
+#define FRAMERATE_MIN	0
+#define FRAMERATE_MAX	31
+
+
+enum {
+	ISOC_MODE_YUV422 = 0x03,
+	ISOC_MODE_YUV420 = 0x14,
+	ISOC_MODE_COMPRESS = 0x60,
+};
+
+/*
+ * The value of 'scratch_buf_size' affects quality of the picture
+ * in many ways. Shorter buffers may cause loss of data when client
+ * is too slow. Larger buffers are memory-consuming and take longer
+ * to work with. This setting can be adjusted, but the default value
+ * should be OK for most desktop users.
+ */
+#define DEFAULT_SCRATCH_BUF_SIZE	(0x20000)		// 128kB memory scratch buffer
+static const int scratch_buf_size = DEFAULT_SCRATCH_BUF_SIZE;
+
+static int init_brightness = 128;	// Initalize the brightness of the video device
+static int init_contrast = 192;		// Initalize the contrast of the video device
+static int init_color = 128;		// Initalize the color mode of the video device
+static int init_hue = 128;		// Initalize the Hue settings of the video device
+
+// Function prototypes
+static int usbvision_restart_isoc(struct usb_usbvision *usbvision);
+static int usbvision_begin_streaming(struct usb_usbvision *usbvision);
+static int usbvision_muxsel(struct usb_usbvision *usbvision, int channel, int norm);
+static int usbvision_i2c_write(void *data, unsigned char addr, char *buf, short len);
+static int usbvision_i2c_read(void *data, unsigned char addr, char *buf, short len);
+static int usbvision_read_reg(struct usb_usbvision *usbvision, unsigned char reg);
+static int usbvision_write_reg(struct usb_usbvision *usbvision, unsigned char reg, unsigned char value);
+static int usbvision_request_intra (struct usb_usbvision *usbvision);
+static int usbvision_unrequest_intra (struct usb_usbvision *usbvision);
+static int usbvision_adjust_compression (struct usb_usbvision *usbvision);
+static int usbvision_measure_bandwidth (struct usb_usbvision *usbvision);
+static void usbvision_release(struct usb_usbvision *usbvision);
+
+
+// Bit flags (options)
+#define FLAGS_RETRY_VIDIOCSYNC		(1 << 0)
+#define	FLAGS_MONOCHROME		(1 << 1)
+#define FLAGS_DISPLAY_HINTS		(1 << 2)
+#define FLAGS_OSD_STATS			(1 << 3)
+#define FLAGS_FORCE_TESTPATTERN		(1 << 4)
+#define FLAGS_SEPARATE_FRAMES		(1 << 5)
+#define FLAGS_CLEAN_FRAMES		(1 << 6)
+
+// Default initalization of device driver parameters
+static int flags = 0;					// Set the default Overlay Display mode of the device driver
+static int debug = 0;					// Set the default Debug Mode of the device driver
+static int isocMode = ISOC_MODE_COMPRESS;		// Set the default format for ISOC endpoint
+static int adjustCompression = 1;			// Set the compression to be adaptive
+static int dga = 1;					// Set the default Direct Graphic Access
+static int PowerOnAtOpen = 1;				// Set the default device to power on at startup
+static int SwitchSVideoInput = 0;			// To help people with Black and White output with using s-video input.  Some cables and input device are wired differently.
+static int video_nr = -1;			        // Sequential Number of Video Device
+static int radio_nr = -1;			        // Sequential Number of Radio Device
+static int vbi_nr = -1;					// Sequential Number of VBI Device
+static char *CustomDevice=NULL;				// Set as nothing....
+
+// Grab parameters for the device driver
+
+#if defined(module_param)                               // Showing parameters under SYSFS
+module_param(flags, int, 0444);
+module_param(debug, int, 0444);
+module_param(isocMode, int, 0444);
+module_param(adjustCompression, int, 0444);
+module_param(dga, int, 0444);
+module_param(PowerOnAtOpen, int, 0444);
+module_param(SwitchSVideoInput, int, 0444);
+module_param(video_nr, int, 0444);
+module_param(radio_nr, int, 0444);
+module_param(vbi_nr, int, 0444);
+module_param(CustomDevice, charp, 0444);
+#else							// Old Style
+MODULE_PARM(flags, "i");				// Grab the Overlay Display mode of the device driver
+MODULE_PARM(debug, "i");				// Grab the Debug Mode of the device driver
+MODULE_PARM(isocMode, "i");				// Grab the video format of the video device
+MODULE_PARM(adjustCompression, "i");			// Grab the compression to be adaptive
+MODULE_PARM(dga, "i");					// Grab the Direct Graphic Access
+MODULE_PARM(PowerOnAtOpen, "i");			// Grab the device to power on at startup
+MODULE_PARM(SwitchSVideoInput, "i");			// To help people with Black and White output with using s-video input.  Some cables and input device are wired differently.
+MODULE_PARM(video_nr, "i");				// video_nr option allows to specify a certain /dev/videoX device (like /dev/video0 or /dev/video1 ...)                 
+MODULE_PARM(radio_nr, "i");				// radio_nr option allows to specify a certain /dev/radioX device (like /dev/radio0 or /dev/radio1 ...)
+MODULE_PARM(vbi_nr, "i");				// vbi_nr option allows to specify a certain /dev/vbiX device (like /dev/vbi0 or /dev/vbi1 ...)
+MODULE_PARM(CustomDevice, "s");			        // .... CustomDevice
+#endif
+
+MODULE_PARM_DESC(flags,	" Set the default Overlay Display mode of the device driver.  Default: 0 (Off)");
+MODULE_PARM_DESC(debug, " Set the default Debug Mode of the device driver.  Default: 0 (Off)");
+MODULE_PARM_DESC(isocMode, " Set the default format for ISOC endpoint.  Default: 0x60 (Compression On)");
+MODULE_PARM_DESC(adjustCompression, " Set the ADPCM compression for the device.  Default: 1 (On)");
+MODULE_PARM_DESC(dga, " Set the Direct Graphic Access for the device.  Default: 1 (On)");
+MODULE_PARM_DESC(PowerOnAtOpen, " Set the default device to power on when device is opened.  Default: 1 (On)");
+MODULE_PARM_DESC(SwitchSVideoInput, " Set the S-Video input.  Some cables and input device are wired differently. Default: 0 (Off)");
+MODULE_PARM_DESC(video_nr, "Set video device number (/dev/videoX).  Default: -1 (autodetect)");
+MODULE_PARM_DESC(radio_nr, "Set radio device number (/dev/radioX).  Default: -1 (autodetect)");
+MODULE_PARM_DESC(vbi_nr, "Set vbi device number (/dev/vbiX).  Default: -1 (autodetect)");
+MODULE_PARM_DESC(CustomDevice, " Define the fine tuning parameters for the device.  Default: null");
+
+
+// Misc stuff
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	MODULE_VERSION(DRIVER_VERSION);
+	MODULE_ALIAS(DRIVER_ALIAS); 
+#endif
+
+#ifdef MODULE
+static unsigned int autoload = 1;
+#else
+static unsigned int autoload = 0;
+#endif
+
+
+/**********************************************************************
+ * /proc interface
+ * Based on the CPiA driver version 0.7.4 -claudio
+ **********************************************************************/
+
+#if defined(CONFIG_VIDEO_PROC_FS)
+
+static struct proc_dir_entry *usbvision_proc_entry = NULL;
+extern struct proc_dir_entry *video_proc_entry;
+
+#define YES_NO(x) ((x) ? "Yes" : "No")
+
+/* /proc/video/usbvision/<minor#>/info */
+static int
+usbvision_read_proc_info(char *page, char **start, off_t off, int count, int *eof,
+		     void *data)
+{
+	char *out = page;
+	int idx, len;
+	struct usb_usbvision *usbvision = data;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -ENODEV;
+
+	// IMPORTANT: This output MUST be kept under PAGE_SIZE
+	//            or we need to get more sophisticated.
+
+	out += sprintf(out, "Driver version  : %s\n", DRIVER_VERSION);
+	out += sprintf(out, "VID:PID         : %04X:%04X\n",
+						usbvision_device_data[usbvision->DevModel].idVendor,
+						usbvision_device_data[usbvision->DevModel].idProduct);
+	out += sprintf(out, "Model           : %s\n",
+						usbvision_device_data[usbvision->DevModel].ModelString);
+	out += sprintf(out, "Streaming       : %s\n", YES_NO(usbvision->streaming));
+	out += sprintf(out, "Overlay         : %s\n", YES_NO(usbvision->overlay));
+	out += sprintf(out, "Compression     : %s\n", YES_NO(usbvision->isocMode==ISOC_MODE_COMPRESS));
+	out += sprintf(out, "  BlockPos      : %d\n", usbvision->BlockPos);
+	out += sprintf(out, "Picture\n");
+	out += sprintf(out, "  Brightness    : %d\n", usbvision->vpic.brightness >> 8);
+	out += sprintf(out, "  Colour        : %d\n", usbvision->vpic.colour >> 8);
+	out += sprintf(out, "  Contrast      : %d\n", usbvision->vpic.contrast >> 8);
+	out += sprintf(out, "  Hue           : %d\n", usbvision->vpic.hue >> 8);
+	if (usbvision->isocMode==ISOC_MODE_COMPRESS) {
+		out += sprintf(out, "IntraFrameBuf @ : 0x%p\n", usbvision->IntraFrameBuffer);
+		for (idx = 0; idx < 4; idx++) {
+			out += sprintf(out, "# Blocks Type %d : %d\n", idx, usbvision->ComprBlockTypes[idx]);
+			usbvision->ComprBlockTypes[idx] = 0;
+		}
+	}
+	if (usbvision->overlay) {
+			out += sprintf(out, "Overlay\n");
+			out += sprintf(out, "  Position      : %d,%d\n",
+				       usbvision->vid_win.x, usbvision->vid_win.y);
+			out += sprintf(out, "  Expected size : %dx%d\n",
+				       usbvision->vid_win.width, usbvision->vid_win.height);
+			out += sprintf(out, "  Current size  : %dx%d\n",
+				       usbvision->overlay_frame.frmwidth, usbvision->overlay_frame.frmheight);
+			out += sprintf(out, "  Depth         : %d\n",
+				       usbvision_v4l_format[usbvision->overlay_frame.v4l_format].depth);
+			out += sprintf(out, "  Format        : %s\n",
+				       usbvision_v4l_format[usbvision->overlay_frame.v4l_format].desc);
+			out += sprintf(out, "  # Clips       : %d\n",
+				       usbvision->vid_win.clipcount);
+	}
+	else {
+		out += sprintf(out, "FrameBuffer @   : 0x%p\n", usbvision->fbuf);
+		out += sprintf(out, "# Frames        : %d\n", USBVISION_NUMFRAMES);
+		for (idx = 0; idx < USBVISION_NUMFRAMES; idx++) {
+			out += sprintf(out, "Frame #         : %d\n", idx);
+			out += sprintf(out, "  Expected size : %dx%d\n",
+				       usbvision->frame[idx].width, usbvision->frame[idx].height);
+			out += sprintf(out, "  Current size  : %dx%d\n",
+				       usbvision->frame[idx].frmwidth, usbvision->frame[idx].frmheight);
+			out += sprintf(out, "  Depth         : %d\n",
+				       usbvision_v4l_format[usbvision->frame[idx].v4l_format].depth);
+			out += sprintf(out, "  Format        : %s\n",
+				       usbvision_v4l_format[usbvision->frame[idx].v4l_format].desc);
+			out += sprintf(out, "  Data buffer @ : 0x%p\n",
+				       usbvision->frame[idx].data);
+		}
+	}
+	for (idx = 0; idx < USBVISION_I2C_CLIENTS_MAX; idx++) {
+		if (usbvision->i2c_clients[idx] == NULL)
+			continue;
+		out += sprintf(out, "I2C client #    : %d\n", idx);
+		out += sprintf(out, "  Name          : %s\n", usbvision->i2c_clients[idx]->name);
+		out += sprintf(out, "  Address       : 0x%02X\n", usbvision->i2c_clients[idx]->addr << 1);
+		out += sprintf(out, "  Flags         : 0x%02X\n", usbvision->i2c_clients[idx]->flags);
+		if (usbvision->i2c_clients[idx]->driver == NULL)
+			continue;
+		out += sprintf(out, "  Driver        : %s\n", usbvision->i2c_clients[idx]->driver->name);
+	}
+	out += sprintf(out, "Time in irq [ms]: %lu\n", usbvision->timeInIrq * (1000L / HZ));
+	usbvision->timeInIrq = 0;
+	out += sprintf(out, "Isoc packetsize : %d\n", usbvision->isocPacketSize);
+	out += sprintf(out, "# Packets       : %lu\n", usbvision->isocPacketCount);
+	out += sprintf(out, "Isoc URBs       : %lu\n", usbvision->isocUrbCount);
+	out += sprintf(out, "Isoc tot data   : %lu\n", usbvision->isocDataCount);
+	out += sprintf(out, "# Frames        : %d\n", usbvision->frame_num);
+	out += sprintf(out, "usedBandwidth   : %d\n", usbvision->usedBandwidth);
+	out += sprintf(out, "comprLevel      : %d\n", usbvision->comprLevel);
+	usbvision->maxStripLen = 0;
+	usbvision->isocUrbCount = 0;
+	usbvision->frame_num = 0;
+	usbvision->isocDataCount = 0;
+	usbvision->isocPacketCount = 0;
+	out += sprintf(out, "Usb bus #       : %d\n", usbvision->dev->bus->busnum);
+	out += sprintf(out, "Usb device #    : %d\n", usbvision->dev->devnum);
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+
+	return len;
+}
+
+
+/* /proc/video/usbvision/<minor#>/register */
+static int
+usbvision_read_proc_register(char *page, char **start, off_t off, int count, int *eof,
+		     void *data)
+{
+	char *out = page;
+	int idx, len;
+	struct usb_usbvision *usbvision = data;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -ENODEV;
+
+
+	// IMPORTANT: This output MUST be kept under PAGE_SIZE
+	//            or we need to get more sophisticated.
+	out += sprintf(out, "Addr.\tValue\n");
+	for (idx = 0; idx < USBVISION_MAX_DIST_H + 1; idx++) {
+		out += sprintf(out, "0x%02X\t0x%02X\n", idx, usbvision_read_reg(usbvision, idx));
+	}
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+
+	return len;
+}
+
+static int
+usbvision_read_proc_frame(char *page, char **start, off_t off, int count, int *eof,
+		     void *data)
+{
+	char *out = page;
+	int len;
+	struct usb_usbvision *usbvision = data;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -ENODEV;
+
+
+	// IMPORTANT: This output MUST be kept under PAGE_SIZE
+	//            or we need to get more sophisticated.
+
+	if (usbvision->frame[0].grabstate == FrameState_Ready)
+		memcpy(out, usbvision->frame[0].data, PAGE_SIZE-1);
+	else if (usbvision->frame[1].grabstate == FrameState_Ready)
+		memcpy(out, usbvision->frame[1].data, PAGE_SIZE-1);
+
+	len = PAGE_SIZE-1;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+
+	return len;
+}
+
+/* /proc/video/usbvision/<minor#>/register */
+static int
+usbvision_write_proc_register (struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	char *in = (char *)buffer;
+	unsigned int reg_addr, reg_value;
+	int ret;
+	struct usb_usbvision *usbvision = data;
+
+	in[count] = 0;
+
+	rmspace(in);
+	do {
+		ret = sscanf(in,"0x%x",&reg_addr);
+		if (ret == 0) {
+			printk(KERN_INFO "usbvision_write_proc_register: ret=%d\n", ret);
+			//break;
+		}
+		goto2next(in);
+		ret = sscanf(in,"0x%x",&reg_value);
+		if (ret == 0) {
+			printk(KERN_INFO "usbvision_write_proc_register: ret=%d\n", ret);
+			//break;
+		}
+		printk(KERN_INFO "usbvision_write_proc_register will write %d to %d\n",
+							reg_value, reg_addr);
+		usbvision_write_reg(usbvision, (unsigned char)reg_addr, (unsigned char)reg_value);
+	} while(0);
+
+	return (int)count;
+}
+
+
+static void
+usbvision_proc_dev_create(struct usb_usbvision *usbvision)
+{
+	char dirname[10];
+
+	if (!usbvision_proc_entry || !usbvision)
+		return;
+
+	// Create per-device directory
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 10)
+	snprintf(dirname, 10, "%d", usbvision->vdev->minor);
+#else
+	sprintf(dirname, "%d", usbvision->vdev->minor);
+#endif
+	PDEBUG(DBG_PROCFS, "creating /proc/video/usbvision/%s/", dirname);
+	usbvision->proc_devdir = create_proc_entry(dirname, S_IFDIR, usbvision_proc_entry);
+	if (!usbvision->proc_devdir)
+		return;
+	usbvision->proc_devdir->owner = THIS_MODULE;
+
+	// Create "info" entry (human readable device information)
+	PDEBUG(DBG_PROCFS, "creating /proc/video/usbvision/%s/info", dirname);
+	usbvision->proc_info = create_proc_read_entry("info", S_IFREG|S_IRUGO|S_IWUSR,
+		usbvision->proc_devdir, usbvision_read_proc_info, usbvision);
+	if (!usbvision->proc_info)
+		return;
+	usbvision->proc_info->owner = THIS_MODULE;
+
+	// Create "register" entry (read/write interface)
+	PDEBUG(DBG_PROCFS, "creating /proc/video/usbvision/%s/register", dirname);
+	usbvision->proc_register = create_proc_read_entry("register", S_IFREG|S_IRUGO|S_IWUSR,
+		usbvision->proc_devdir, usbvision_read_proc_register, usbvision);
+	if (!usbvision->proc_register)
+		return;
+	usbvision->proc_register->owner = THIS_MODULE;
+	usbvision->proc_register->write_proc = usbvision_write_proc_register;
+
+	// Create "frame" entry
+	PDEBUG(DBG_PROCFS, "creating /proc/video/usbvision/%s/frame", dirname);
+	usbvision->proc_frame = create_proc_read_entry("frame", S_IFREG|S_IRUGO|S_IWUSR,
+		usbvision->proc_devdir, usbvision_read_proc_frame, usbvision);
+	if (!usbvision->proc_frame)
+		return;
+	usbvision->proc_frame->owner = THIS_MODULE;
+}
+
+
+static void
+usbvision_proc_dev_destroy(struct usb_usbvision *usbvision)
+{
+	char dirname[10];
+
+	if (!usbvision || !usbvision->proc_devdir)
+		return;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 10)
+	snprintf(dirname, 10, "%d", usbvision->vdev->minor);
+#else
+	sprintf(dirname, "%d", usbvision->vdev->minor);
+#endif
+
+	/* Destroy "control" entry */
+	if (usbvision->proc_control) {
+		PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/control", dirname);
+		remove_proc_entry("control", usbvision->proc_devdir);
+		usbvision->proc_control = NULL;
+	}
+
+	/* Destroy "button" entry */
+	if (usbvision->proc_button) {
+		PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/button", dirname);
+		remove_proc_entry("button", usbvision->proc_devdir);
+		usbvision->proc_button = NULL;
+	}
+
+	/* Destroy "frame" entry */
+	if (usbvision->proc_frame) {
+		PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/frame", dirname);
+		remove_proc_entry("frame", usbvision->proc_devdir);
+		usbvision->proc_frame = NULL;
+	}
+
+	/* Destroy "register" entry */
+	if (usbvision->proc_register) {
+		PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/register", dirname);
+		remove_proc_entry("register", usbvision->proc_devdir);
+		usbvision->proc_register = NULL;
+	}
+
+	/* Destroy "info" entry */
+	if (usbvision->proc_info) {
+		PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/info", dirname);
+		remove_proc_entry("info", usbvision->proc_devdir);
+		usbvision->proc_info = NULL;
+	}
+
+	/* Destroy per-device directory */
+	PDEBUG(DBG_PROCFS, "destroying /proc/video/usbvision/%s/", dirname);
+	remove_proc_entry(dirname, usbvision_proc_entry);
+	usbvision->proc_devdir = NULL;
+}
+
+static void
+usbvision_proc_create(void)
+{
+	/* No current standard here. Alan prefers /proc/video/ as it keeps
+	 * /proc "less cluttered than /proc/randomcardifoundintheshed/"
+	 * -claudio
+	 */
+	if (video_proc_entry == NULL) {
+		err("Error: /proc/video/ does not exist");
+		return;
+	}
+
+	usbvision_proc_entry = create_proc_entry("usbvision", S_IFDIR,
+					     video_proc_entry);
+
+	if (usbvision_proc_entry)
+		usbvision_proc_entry->owner = THIS_MODULE;
+	else
+		err("Unable to create /proc/video/usbvision");
+}
+
+static void
+usbvision_proc_destroy(void)
+{
+	PDEBUG(3, "removing /proc/video/usbvision");
+
+	if (usbvision_proc_entry == NULL)
+		return;
+
+	remove_proc_entry("usbvision", video_proc_entry);
+}
+#else
+static inline void usbvision_proc_dev_create(struct usb_usbvision *usbvision) { }
+static inline void usbvision_proc_dev_destroy(struct usb_usbvision *usbvision) { }
+static inline void usbvision_proc_create(void) { }
+static inline void usbvision_proc_destroy(void) { }
+#endif /* #ifdef CONFIG_VIDEO_PROC_FS */
+
+/****************************************************************************************/
+/* SYSFS Code - Copied from the stv680.c usb module.		                        */
+/* Device information is located at /sys/class/video4linux/video0	                */
+/* Device parameters information is located at /sys/module/usbvision                    */
+/* Device USB Information is located at /sys/bus/usb/drivers/USBVision Video Grabber    */
+/****************************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+
+#define YES_NO(x) ((x) ? "Yes" : "No")
+
+static inline struct usb_usbvision *cd_to_usbvision(struct class_device *cd)
+{
+	struct video_device *vdev = to_video_device(cd);
+	return video_get_drvdata(vdev);
+}
+
+static ssize_t show_version(struct class_device *cd, char *buf)
+{
+	return sprintf(buf, "%s\n", DRIVER_VERSION);
+} 
+static CLASS_DEVICE_ATTR(version, S_IRUGO, show_version, NULL);
+
+static ssize_t show_model(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%s\n", usbvision_device_data[usbvision->DevModel].ModelString);
+} 
+static CLASS_DEVICE_ATTR(model, S_IRUGO, show_model, NULL);
+
+static ssize_t show_hue(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%d\n", usbvision->vpic.hue >> 8);
+} 
+static CLASS_DEVICE_ATTR(hue, S_IRUGO, show_hue, NULL);
+
+static ssize_t show_contrast(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%d\n", usbvision->vpic.contrast >> 8);
+} 
+static CLASS_DEVICE_ATTR(contrast, S_IRUGO, show_contrast, NULL);
+
+static ssize_t show_brightness(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%d\n", usbvision->vpic.brightness >> 8);
+} 
+static CLASS_DEVICE_ATTR(brightness, S_IRUGO, show_brightness, NULL);
+
+static ssize_t show_colour(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%d\n", usbvision->vpic.colour >> 8);
+} 
+static CLASS_DEVICE_ATTR(colour, S_IRUGO, show_colour, NULL);
+
+static ssize_t show_streaming(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%s\n", YES_NO(usbvision->streaming));
+} 
+static CLASS_DEVICE_ATTR(streaming, S_IRUGO, show_streaming, NULL);
+
+static ssize_t show_overlay(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%s\n", YES_NO(usbvision->overlay));
+} 
+static CLASS_DEVICE_ATTR(overlay, S_IRUGO, show_overlay, NULL);
+
+static ssize_t show_compression(struct class_device *class_dev, char *buf)
+{
+	struct video_device *vdev = to_video_device(class_dev);	
+	struct usb_usbvision *usbvision = video_get_drvdata(vdev);	
+	return sprintf(buf, "%s\n", YES_NO(usbvision->isocMode==ISOC_MODE_COMPRESS));
+} 
+static CLASS_DEVICE_ATTR(compression, S_IRUGO, show_compression, NULL);
+
+static void usbvision_create_sysfs(struct video_device *vdev)
+{
+	if (vdev) {
+		video_device_create_file(vdev, &class_device_attr_version);
+		video_device_create_file(vdev, &class_device_attr_model);
+		video_device_create_file(vdev, &class_device_attr_hue);
+		video_device_create_file(vdev, &class_device_attr_contrast);
+		video_device_create_file(vdev, &class_device_attr_brightness);
+		video_device_create_file(vdev, &class_device_attr_colour);
+		video_device_create_file(vdev, &class_device_attr_streaming);
+		video_device_create_file(vdev, &class_device_attr_overlay);
+		video_device_create_file(vdev, &class_device_attr_compression);
+	}
+}
+
+static void usbvision_remove_sysfs(struct video_device *vdev)
+{
+	if (vdev) {
+		video_device_remove_file(vdev, &class_device_attr_version);
+		video_device_remove_file(vdev, &class_device_attr_model);
+		video_device_remove_file(vdev, &class_device_attr_hue);
+		video_device_remove_file(vdev, &class_device_attr_contrast);
+		video_device_remove_file(vdev, &class_device_attr_brightness);
+		video_device_remove_file(vdev, &class_device_attr_colour);
+		video_device_remove_file(vdev, &class_device_attr_streaming);
+		video_device_remove_file(vdev, &class_device_attr_overlay);
+		video_device_remove_file(vdev, &class_device_attr_compression);
+	}
+}
+
+#endif
+
+/*******************************/
+/* Memory management functions */
+/*******************************/
+
+/*
+ * Here we want the physical address of the memory.
+ * This is used when initializing the contents of the area.
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+unsigned long usbvision_kvirt_to_pa(unsigned long adr)
+{
+	unsigned long kva, ret;
+
+	kva = (unsigned long) page_address(vmalloc_to_page((void *)adr));
+	kva |= adr & (PAGE_SIZE-1); /* restore the offset */
+	ret = __pa(kva);
+	return ret;
+}
+#endif
+
+void *usbvision_rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr;
+
+	size = PAGE_ALIGN(size);
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+ adr = (unsigned long) mem;
+ while (size > 0) {
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+   mem_map_reserve(vmalloc_to_page((void *)adr));
+  #else
+   SetPageReserved(vmalloc_to_page((void *)adr));
+  #endif
+  adr += PAGE_SIZE;
+  size -= PAGE_SIZE;
+ }
+
+ return mem;
+}
+
+void usbvision_rvfree(void *mem, unsigned long size)
+{
+ unsigned long adr;
+
+ if (!mem)
+  return;
+
+ adr = (unsigned long) mem;
+ while ((long) size > 0) {
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+   mem_map_unreserve(vmalloc_to_page((void *)adr));
+  #else
+   ClearPageReserved(vmalloc_to_page((void *)adr));
+  #endif
+  adr += PAGE_SIZE;
+  size -= PAGE_SIZE;
+ }
+ vfree(mem);
+}
+
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,25)
+/* helper functions to access driver private data. */
+static inline void *video_get_drvdata(struct video_device *dev)
+{
+ return dev->priv;
+}
+
+static inline void video_set_drvdata(struct video_device *dev, void *data)
+{
+ dev->priv = data;
+}
+
+struct video_device *video_device_alloc(void)
+{
+ struct video_device *vfd;
+
+ vfd = kmalloc(sizeof(*vfd),GFP_KERNEL);
+ if (NULL == vfd)
+  return NULL;
+ memset(vfd,0,sizeof(*vfd));
+ return vfd;
+}
+
+void video_device_release(struct video_device *vfd)
+{
+ kfree(vfd);
+}
+#endif
+
+
+
+
+#if ENABLE_HEXDUMP
+static void usbvision_hexdump(const unsigned char *data, int len)
+{
+ char tmp[80];
+ int i, k;
+
+ for (i = k = 0; len > 0; i++, len--) {
+  if (i > 0 && (i % 16 == 0)) {
+   printk("%s\n", tmp);
+   k = 0;
+  }
+  k += sprintf(&tmp[k], "%02x ", data[i]);
+ }
+ if (k > 0)
+  printk("%s\n", tmp);
+}
+#endif
+
+
+/* These procedures handle the scratch ring buffer */
+int scratch_len(struct usb_usbvision *usbvision)    /*This returns the amount of data actually in the buffer */
+{
+	int len = usbvision->scratch_write_ptr - usbvision->scratch_read_ptr;
+	if (len < 0) {
+		len += scratch_buf_size;
+	}
+	PDEBUG(DBG_SCRATCH, "scratch_len() = %d\n", len);
+
+	return len;
+}
+
+
+/* This returns the free space left in the buffer */
+int scratch_free(struct usb_usbvision *usbvision)
+{
+	int free = usbvision->scratch_read_ptr - usbvision->scratch_write_ptr;
+	if (free <= 0) {
+		free += scratch_buf_size;
+	}
+	if (free) {
+		free -= 1;							/* at least one byte in the buffer must */
+										/* left blank, otherwise there is no chance to differ between full and empty */
+	}
+	PDEBUG(DBG_SCRATCH, "return %d\n", free);
+
+	return free;
+}
+
+
+void *debug_memcpy(void *dest, void *src, size_t len)
+{
+	printk(KERN_DEBUG "memcpy(%p, %p, %d);\n", dest, src, len);
+	return memcpy(dest, src, len);
+}
+
+
+/* This puts data into the buffer */
+int scratch_put(struct usb_usbvision *usbvision, unsigned char *data, int len)
+{
+	int len_part;
+
+	if (usbvision->scratch_write_ptr + len < scratch_buf_size) {
+		memcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len);
+		usbvision->scratch_write_ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - usbvision->scratch_write_ptr;
+		memcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len_part);
+		if (len == len_part) {
+			usbvision->scratch_write_ptr = 0;			/* just set write_ptr to zero */
+		}
+		else {
+			memcpy(usbvision->scratch, data + len_part, len - len_part);
+			usbvision->scratch_write_ptr = len - len_part;
+		}
+	}
+
+	PDEBUG(DBG_SCRATCH, "len=%d, new write_ptr=%d\n", len, usbvision->scratch_write_ptr);
+
+	return len;
+}
+
+/* This marks the write_ptr as position of new frame header */
+void scratch_mark_header(struct usb_usbvision *usbvision)
+{
+	PDEBUG(DBG_SCRATCH, "header at write_ptr=%d\n", usbvision->scratch_headermarker_write_ptr);
+
+	usbvision->scratch_headermarker[usbvision->scratch_headermarker_write_ptr] =
+				usbvision->scratch_write_ptr;
+	usbvision->scratch_headermarker_write_ptr += 1;
+	usbvision->scratch_headermarker_write_ptr %= USBVISION_NUM_HEADERMARKER;
+}
+
+/* This gets data from the buffer at the given "ptr" position */
+int scratch_get_extra(struct usb_usbvision *usbvision, unsigned char *data, int *ptr, int len)
+{
+	int len_part;
+	if (*ptr + len < scratch_buf_size) {
+		memcpy(data, usbvision->scratch + *ptr, len);
+		*ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - *ptr;
+		memcpy(data, usbvision->scratch + *ptr, len_part);
+		if (len == len_part) {
+			*ptr = 0;							/* just set the y_ptr to zero */
+		}
+		else {
+			memcpy(data + len_part, usbvision->scratch, len - len_part);
+			*ptr = len - len_part;
+		}
+	}
+
+	PDEBUG(DBG_SCRATCH, "len=%d, new ptr=%d\n", len, *ptr);
+
+	return len;
+}
+
+
+/* This sets the scratch extra read pointer */
+void scratch_set_extra_ptr(struct usb_usbvision *usbvision, int *ptr, int len)
+{
+	*ptr = (usbvision->scratch_read_ptr + len)%scratch_buf_size;
+
+	PDEBUG(DBG_SCRATCH, "ptr=%d\n", *ptr);
+}
+
+
+/*This increments the scratch extra read pointer */
+void scratch_inc_extra_ptr(int *ptr, int len)
+{
+	*ptr = (*ptr + len) % scratch_buf_size;
+
+	PDEBUG(DBG_SCRATCH, "ptr=%d\n", *ptr);
+}
+
+
+/* This gets data from the buffer */
+int scratch_get(struct usb_usbvision *usbvision, unsigned char *data, int len)
+{
+	int len_part;
+	if (usbvision->scratch_read_ptr + len < scratch_buf_size) {
+		memcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len);
+		usbvision->scratch_read_ptr += len;
+	}
+	else {
+		len_part = scratch_buf_size - usbvision->scratch_read_ptr;
+		memcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len_part);
+		if (len == len_part) {
+			usbvision->scratch_read_ptr = 0;				/* just set the read_ptr to zero */
+		}
+		else {
+			memcpy(data + len_part, usbvision->scratch, len - len_part);
+			usbvision->scratch_read_ptr = len - len_part;
+		}
+	}
+
+	PDEBUG(DBG_SCRATCH, "len=%d, new read_ptr=%d\n", len, usbvision->scratch_read_ptr);
+
+	return len;
+}
+
+
+/* This sets read pointer to next header and returns it */
+int scratch_get_header(struct usb_usbvision *usbvision,struct usbvision_frame_header *header)
+{
+	int errCode = 0;
+
+	PDEBUG(DBG_SCRATCH, "from read_ptr=%d", usbvision->scratch_headermarker_read_ptr);
+
+	while (usbvision->scratch_headermarker_write_ptr -
+		usbvision->scratch_headermarker_read_ptr != 0) {
+		usbvision->scratch_read_ptr =
+			usbvision->scratch_headermarker[usbvision->scratch_headermarker_read_ptr];
+		usbvision->scratch_headermarker_read_ptr += 1;
+		usbvision->scratch_headermarker_read_ptr %= USBVISION_NUM_HEADERMARKER;
+		scratch_get(usbvision, (unsigned char *)header, USBVISION_HEADER_LENGTH);
+		if ((header->magic_1 == USBVISION_MAGIC_1)
+			 && (header->magic_2 == USBVISION_MAGIC_2)
+			 && (header->headerLength == USBVISION_HEADER_LENGTH)) {
+			errCode = USBVISION_HEADER_LENGTH;
+			header->frameWidth  = header->frameWidthLo  + (header->frameWidthHi << 8);
+			header->frameHeight = header->frameHeightLo + (header->frameHeightHi << 8);
+			break;
+		}
+	}
+
+	return errCode;
+}
+
+
+/*This removes len bytes of old data from the buffer */
+void scratch_rm_old(struct usb_usbvision *usbvision, int len)
+{
+
+	usbvision->scratch_read_ptr += len;
+	usbvision->scratch_read_ptr %= scratch_buf_size;
+	PDEBUG(DBG_SCRATCH, "read_ptr is now %d\n", usbvision->scratch_read_ptr);
+}
+
+
+/*This resets the buffer - kills all data in it too */
+void scratch_reset(struct usb_usbvision *usbvision)
+{
+	PDEBUG(DBG_SCRATCH, "\n");
+
+	usbvision->scratch_read_ptr = 0;
+	usbvision->scratch_write_ptr = 0;
+	usbvision->scratch_headermarker_read_ptr = 0;
+	usbvision->scratch_headermarker_write_ptr = 0;
+	usbvision->isocstate = IsocState_NoFrame;
+}
+
+
+
+/* Here comes the OVERLAY stuff */
+
+/* Tell the interrupt handler what to to.  */
+static
+void usbvision_cap(struct usb_usbvision* usbvision, int on)
+{
+	DEBUG(printk(KERN_DEBUG "usbvision_cap: overlay was %d, set it to %d\n", usbvision->overlay, on);)
+
+	if (on) {
+		usbvision->overlay = 1;
+	}
+	else {
+		usbvision->overlay = 0;
+	}
+}
+
+
+
+
+/* append a new clipregion to the vector of video_clips */
+static
+void usbvision_new_clip(struct video_window* vw, struct video_clip* vcp, int x, int y, int w, int h)
+{
+	vcp[vw->clipcount].x = x;
+	vcp[vw->clipcount].y = y;
+	vcp[vw->clipcount].width = w;
+	vcp[vw->clipcount].height = h;
+	vw->clipcount++;
+}
+
+
+#define mark_pixel(x,y)  usbvision->clipmask[((x) + (y) * MAX_FRAME_WIDTH)/32] |= 0x00000001<<((x)%32)
+#define clipped_pixel(index) usbvision->clipmask[(index)/32] & (0x00000001<<((index)%32))
+
+static
+void usbvision_built_overlay(struct usb_usbvision* usbvision, int count, struct video_clip *vcp)
+{
+	usbvision->overlay_win = usbvision->overlay_base +
+		(signed int)usbvision->vid_win.x * usbvision->vid_buf.depth / 8 +
+		(signed int)usbvision->vid_win.y * usbvision->vid_buf.bytesperline;
+
+		IODEBUG(printk(KERN_DEBUG "built_overlay base=%p, win=%p, bpl=%d, clips=%d, size=%dx%d\n",
+					usbvision->overlay_base, usbvision->overlay_win,
+					usbvision->vid_buf.bytesperline, count,
+					usbvision->vid_win.width, usbvision->vid_win.height);)
+
+
+	/* Add here generation of clipping mask */
+{
+	int x_start, x_end, y_start, y_end;
+	int clip_index, x, y;
+
+	memset(usbvision->clipmask, 0, USBVISION_CLIPMASK_SIZE);
+
+	OVDEBUG(printk(KERN_DEBUG "clips = %d\n", count);)
+
+	for(clip_index = 0; clip_index < count; clip_index++) {
+		OVDEBUG(printk(KERN_DEBUG "clip: %d,%d,%d,%d\n", vcp[clip_index].x,
+				vcp[clip_index].y,
+				vcp[clip_index].width,
+				vcp[clip_index].height);)
+
+		x_start = vcp[clip_index].x;
+		if(x_start >= (int)usbvision->vid_win.width) {
+			OVDEBUG(printk(KERN_DEBUG "x_start=%d\n", x_start);)
+			continue; //clipping window is right of overlay window
+		}
+		x_end	= x_start + vcp[clip_index].width;
+		if(x_end <= 0) {
+			OVDEBUG(printk(KERN_DEBUG "x_end=%d\n", x_end);)
+			continue; //clipping window is left of overlay window
+		}
+
+		y_start = vcp[clip_index].y;
+		if(y_start >= (int)usbvision->vid_win.height) {
+			OVDEBUG(printk(KERN_DEBUG "y_start=%d\n", y_start);)
+			continue; //clipping window is below overlay window
+		}
+		y_end   = y_start + vcp[clip_index].height;
+		if(y_end <= 0) {
+			OVDEBUG(printk(KERN_DEBUG "y_end=%d\n", y_end);)
+			continue; //clipping window is above overlay window
+		}
+
+		//clip the clipping window
+		if (x_start < 0) {
+			x_start = 0;
+		}
+		if (x_end > (int)usbvision->vid_win.width) {
+			x_end = (int)usbvision->vid_win.width;
+		}
+		if (y_start < 0) {
+			y_start = 0;
+		}
+		if (y_end > (int)usbvision->vid_win.height) {
+			y_end = (int)usbvision->vid_win.height;
+		}
+
+		OVDEBUG(printk(KERN_DEBUG "clip_o: %d,%d,%d,%d\n", x_start,	y_start, x_end, y_end);)
+
+
+
+		for(y = y_start; y < y_end; y++) {
+			for(x = x_start; x < x_end; x++) {
+				mark_pixel(x,y);
+			}
+		}
+	}
+}
+
+}
+
+
+
+void usbvision_osd_char(struct usb_usbvision *usbvision,
+			struct usbvision_frame *frame, int x, int y, int ch)
+{
+	static const unsigned short digits[16] = {
+		0xF6DE,		/* 0 */
+		0x2492,		/* 1 */
+		0xE7CE,		/* 2 */
+		0xE79E,		/* 3 */
+		0xB792,		/* 4 */
+		0xF39E,		/* 5 */
+		0xF3DE,		/* 6 */
+		0xF492,		/* 7 */
+		0xF7DE,		/* 8 */
+		0xF79E,		/* 9 */
+		0x77DA,		/* a */
+		0xD75C,		/* b */
+		0xF24E,		/* c */
+		0xD6DC,		/* d */
+		0xF34E,		/* e */
+		0xF348		/* f */
+	};
+	unsigned short digit;
+	int ix, iy;
+
+	if ((usbvision == NULL) || (frame == NULL))
+		return;
+
+	if (ch >= '0' && ch <= '9')
+		ch -= '0';
+	else if (ch >= 'A' && ch <= 'F')
+		ch = 10 + (ch - 'A');
+	else if (ch >= 'a' && ch <= 'f')
+		ch = 10 + (ch - 'a');
+	else
+		return;
+	digit = digits[ch];
+
+	for (iy = 0; iy < 5; iy++) {
+		for (ix = 0; ix < 3; ix++) {
+			if (digit & 0x8000) {
+			//	USBVISION_PUTPIXEL(frame, x + ix, y + iy,
+			//			0xFF, 0xFF, 0xFF);
+			}
+			digit = digit << 1;
+		}
+	}
+}
+
+
+void usbvision_osd_string(struct usb_usbvision *usbvision,
+			  struct usbvision_frame *frame,
+			  int x, int y, const char *str)
+{
+	while (*str) {
+		usbvision_osd_char(usbvision, frame, x, y, *str);
+		str++;
+		x += 4;		/* 3 pixels character + 1 space */
+	}
+}
+
+/*
+ * usb_usbvision_osd_stats()
+ *
+ * On screen display of important debugging information.
+ *
+ */
+void usbvision_osd_stats(struct usb_usbvision *usbvision,
+			 struct usbvision_frame *frame)
+{
+	const int y_diff = 8;
+	char tmp[16];
+	int x = 10;
+	int y = 10;
+
+	sprintf(tmp, "%8x", usbvision->frame_num);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->isocUrbCount);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->urb_length);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->isocDataCount);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->header_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->scratch_ovf_count);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->isocSkipCount);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8lx", usbvision->isocErrCount);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.colour);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.hue);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.brightness >> 8);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8x", usbvision->vpic.contrast >> 12);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+
+	sprintf(tmp, "%8d", usbvision->vpic.whiteness >> 8);
+	usbvision_osd_string(usbvision, frame, x, y, tmp);
+	y += y_diff;
+}
+
+/*
+ * usbvision_testpattern()
+ *
+ * Procedure forms a test pattern (yellow grid on blue background).
+ *
+ * Parameters:
+ * fullframe:   if TRUE then entire frame is filled, otherwise the procedure
+ *	        continues from the current scanline.
+ * pmode	0: fill the frame with solid blue color (like on VCR or TV)
+ *	        1: Draw a colored grid
+ *
+ */
+void usbvision_testpattern(struct usb_usbvision *usbvision, int fullframe,
+			int pmode)
+{
+	static const char proc[] = "usbvision_testpattern";
+	struct usbvision_frame *frame;
+	unsigned char *f;
+	int num_cell = 0;
+	int scan_length = 0;
+	static int num_pass = 0;
+
+	if (usbvision == NULL) {
+		printk(KERN_ERR "%s: usbvision == NULL\n", proc);
+		return;
+	}
+	if ((usbvision->curFrameNum < 0)
+	    || (usbvision->curFrameNum >= USBVISION_NUMFRAMES)) {
+		printk(KERN_ERR "%s: usbvision->curFrameNum=%d.\n", proc,
+		       usbvision->curFrameNum);
+		return;
+	}
+
+	/* Grab the current frame */
+	frame = &usbvision->frame[usbvision->curFrameNum];
+
+	/* Optionally start at the beginning */
+	if (fullframe) {
+		frame->curline = 0;
+		frame->scanlength = 0;
+	}
+
+	/* Form every scan line */
+	for (; frame->curline < frame->frmheight; frame->curline++) {
+		int i;
+
+		f = frame->data + (usbvision->curwidth * 3 * frame->curline);
+		for (i = 0; i < usbvision->curwidth; i++) {
+			unsigned char cb = 0x80;
+			unsigned char cg = 0;
+			unsigned char cr = 0;
+
+			if (pmode == 1) {
+				if (frame->curline % 32 == 0)
+					cb = 0, cg = cr = 0xFF;
+				else if (i % 32 == 0) {
+					if (frame->curline % 32 == 1)
+						num_cell++;
+					cb = 0, cg = cr = 0xFF;
+				} else {
+					cb =
+					    ((num_cell * 7) +
+					     num_pass) & 0xFF;
+					cg =
+					    ((num_cell * 5) +
+					     num_pass * 2) & 0xFF;
+					cr =
+					    ((num_cell * 3) +
+					     num_pass * 3) & 0xFF;
+				}
+			} else {
+				/* Just the blue screen */
+			}
+
+			*f++ = cb;
+			*f++ = cg;
+			*f++ = cr;
+			scan_length += 3;
+		}
+	}
+
+	frame->grabstate = FrameState_Done;
+	frame->scanlength += scan_length;
+	++num_pass;
+
+	/* We do this unconditionally, regardless of FLAGS_OSD_STATS */
+	usbvision_osd_stats(usbvision, frame);
+}
+
+/*
+ * Here comes the data parsing stuff that is run as interrupt
+ */
+
+/*
+ * usbvision_find_header()
+ *
+ * Locate one of supported header markers in the scratch buffer.
+ */
+static enum ParseState usbvision_find_header(struct usb_usbvision *usbvision)
+{
+	struct usbvision_frame *frame;
+	int foundHeader = 0;
+
+	if (usbvision->overlay) {
+		frame = &usbvision->overlay_frame;
+	}
+	else {
+		frame = &usbvision->frame[usbvision->curFrameNum];
+	}
+
+	while (scratch_get_header(usbvision, &frame->isocHeader) == USBVISION_HEADER_LENGTH) {
+		// found header in scratch
+		PDEBUG(DBG_HEADER, "found header: 0x%02x%02x %d %d %d %d %#x 0x%02x %u %u",
+				frame->isocHeader.magic_2,
+				frame->isocHeader.magic_1,
+				frame->isocHeader.headerLength,
+				frame->isocHeader.frameNum,
+				frame->isocHeader.framePhase,
+				frame->isocHeader.frameLatency,
+				frame->isocHeader.dataFormat,
+				frame->isocHeader.formatParam,
+				frame->isocHeader.frameWidth,
+				frame->isocHeader.frameHeight);
+
+		if (usbvision->requestIntra) {
+			if (frame->isocHeader.formatParam & 0x80) {
+				foundHeader = 1;
+				usbvision->lastIsocFrameNum = -1; // do not check for lost frames this time
+				usbvision_unrequest_intra(usbvision);
+				break;
+			}
+		}
+		else {
+			foundHeader = 1;
+			break;
+		}
+	}
+
+	if (foundHeader) {
+		frame->frmwidth = frame->isocHeader.frameWidth * usbvision->stretch_width;
+		frame->frmheight = frame->isocHeader.frameHeight * usbvision->stretch_height;
+		frame->v4l_linesize = (frame->frmwidth * usbvision_v4l_format[frame->v4l_format].depth)>> 3;
+		usbvision->curFrame = frame;
+	}
+	else { // no header found
+		PDEBUG(DBG_HEADER, "skipping scratch data, no header");
+		scratch_reset(usbvision);
+		return ParseState_EndParse;
+	}
+
+	// found header
+	if (frame->isocHeader.dataFormat==ISOC_MODE_COMPRESS) {
+		//check isocHeader.frameNum for lost frames
+		if (usbvision->lastIsocFrameNum >= 0) {
+			if (((usbvision->lastIsocFrameNum + 1) % 32) != frame->isocHeader.frameNum) {
+				// unexpected frame drop: need to request new intra frame
+				PDEBUG(DBG_HEADER, "Lost frame before %d on USB", frame->isocHeader.frameNum);
+				usbvision_request_intra(usbvision);
+				return ParseState_NextFrame;
+			}
+		}
+		usbvision->lastIsocFrameNum = frame->isocHeader.frameNum;
+	}
+	usbvision->header_count++;
+	frame->scanstate = ScanState_Lines;
+	frame->curline = 0;
+
+	if (flags & FLAGS_FORCE_TESTPATTERN) {
+		usbvision_testpattern(usbvision, 1, 1);
+		return ParseState_NextFrame;
+	}
+	return ParseState_Continue;
+}
+
+static enum ParseState usbvision_parse_lines_422(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+	volatile struct usbvision_frame *frame;
+	unsigned char *f;
+	int len;
+	int i;
+	unsigned char yuyv[4]={180, 128, 10, 128}; // YUV components
+	unsigned char rv, gv, bv;	// RGB components
+	int clipmask_index, bytes_per_pixel;
+	int overlay = usbvision->overlay;
+	int stretch_bytes, clipmask_add;
+
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return ParseState_NextFrame;
+		}
+		f = usbvision->overlay_win + frame->curline *
+			usbvision->vid_buf.bytesperline;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curFrameNum];
+		f = frame->data + (frame->v4l_linesize * frame->curline);
+	}
+
+	/* Make sure there's enough data for the entire line */
+	len = (frame->isocHeader.frameWidth * 2)+5;
+	if (scratch_len(usbvision) < len) {
+		PDEBUG(DBG_PARSE, "out of data in line %d, need %u.\n", frame->curline, len);
+		return ParseState_Out;
+	}
+
+	if ((frame->curline + 1) >= frame->frmheight) {
+		return ParseState_NextFrame;
+	}
+
+	bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+	stretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;
+	clipmask_index = frame->curline * MAX_FRAME_WIDTH;
+	clipmask_add = usbvision->stretch_width;
+
+	for (i = 0; i < frame->frmwidth; i+=(2 * usbvision->stretch_width)) {
+
+		scratch_get(usbvision, &yuyv[0], 4);
+
+		if((overlay) && (clipped_pixel(clipmask_index))) {
+			f += bytes_per_pixel;
+		}
+		else if (frame->v4l_format == VIDEO_PALETTE_YUV422) {
+			*f++ = yuyv[0]; // Y
+			*f++ = yuyv[3]; // U
+		}
+		else {
+
+			YUV_TO_RGB_BY_THE_BOOK(yuyv[0], yuyv[1], yuyv[3], rv, gv, bv);
+			switch (frame->v4l_format) {
+				case VIDEO_PALETTE_RGB565:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 3));
+					*f++ = (0x07 & (gv >> 5)) | (0xF8 &  rv);
+					break;
+				case VIDEO_PALETTE_RGB24:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					break;
+				case VIDEO_PALETTE_RGB32:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					f++;
+					break;
+				case VIDEO_PALETTE_RGB555:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 2));
+					*f++ = (0x03 & (gv >> 6)) | (0x7C & (rv >> 1));
+					break;
+			}
+		}
+		clipmask_index += clipmask_add;
+		f += stretch_bytes;
+
+		if((overlay) && (clipped_pixel(clipmask_index))) {
+			f += bytes_per_pixel;
+		}
+		else if (frame->v4l_format == VIDEO_PALETTE_YUV422) {
+			*f++ = yuyv[2]; // Y
+			*f++ = yuyv[1]; // V
+		}
+		else {
+
+			YUV_TO_RGB_BY_THE_BOOK(yuyv[2], yuyv[1], yuyv[3], rv, gv, bv);
+			switch (frame->v4l_format) {
+				case VIDEO_PALETTE_RGB565:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 3));
+					*f++ = (0x07 & (gv >> 5)) | (0xF8 &  rv);
+					break;
+				case VIDEO_PALETTE_RGB24:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					break;
+				case VIDEO_PALETTE_RGB32:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					f++;
+					break;
+				case VIDEO_PALETTE_RGB555:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 2));
+					*f++ = (0x03 & (gv >> 6)) | (0x7C & (rv >> 1));
+					break;
+			}
+		}
+		clipmask_index += clipmask_add;
+		f += stretch_bytes;
+	}
+
+	frame->curline += usbvision->stretch_height;
+	*pcopylen += frame->v4l_linesize * usbvision->stretch_height;
+
+	if (frame->curline >= frame->frmheight) {
+		return ParseState_NextFrame;
+	}
+	else {
+		return ParseState_Continue;
+	}
+}
+
+
+static int usbvision_decompress(struct usb_usbvision *usbvision,unsigned char *Compressed,
+								unsigned char *Decompressed, int *StartPos,
+								int *BlockTypeStartPos, int Len)
+{
+	int RestPixel, Idx, MaxPos, Pos, ExtraPos, BlockLen, BlockTypePos, BlockTypeLen;
+	unsigned char BlockByte, BlockCode, BlockType, BlockTypeByte, Integrator;
+
+	Integrator = 0;
+	Pos = *StartPos;
+	BlockTypePos = *BlockTypeStartPos;
+	MaxPos = 396; //Pos + Len;
+	ExtraPos = Pos;
+	BlockLen = 0;
+	BlockByte = 0;
+	BlockCode = 0;
+	BlockType = 0;
+	BlockTypeByte = 0;
+	BlockTypeLen = 0;
+	RestPixel = Len;
+
+	for (Idx = 0; Idx < Len; Idx++) {
+
+		if (BlockLen == 0) {
+			if (BlockTypeLen==0) {
+				BlockTypeByte = Compressed[BlockTypePos];
+				BlockTypePos++;
+				BlockTypeLen = 4;
+			}
+			BlockType = (BlockTypeByte & 0xC0) >> 6;
+
+			//statistic:
+			usbvision->ComprBlockTypes[BlockType]++;
+
+			Pos = ExtraPos;
+			if (BlockType == 0) {
+				if(RestPixel >= 24) {
+					Idx += 23;
+					RestPixel -= 24;
+					Integrator = Decompressed[Idx];
+				} else {
+					Idx += RestPixel - 1;
+					RestPixel = 0;
+				}
+			} else {
+				BlockCode = Compressed[Pos];
+				Pos++;
+				if (RestPixel >= 24) {
+					BlockLen  = 24;
+				} else {
+					BlockLen = RestPixel;
+				}
+				RestPixel -= BlockLen;
+				ExtraPos = Pos + (BlockLen / 4);
+			}
+			BlockTypeByte <<= 2;
+			BlockTypeLen -= 1;
+		}
+		if (BlockLen > 0) {
+			if ((BlockLen%4) == 0) {
+				BlockByte = Compressed[Pos];
+				Pos++;
+			}
+			if (BlockType == 1) { //inter Block
+				Integrator = Decompressed[Idx];
+			}
+			switch (BlockByte & 0xC0) {
+				case 0x03<<6:
+					Integrator += Compressed[ExtraPos];
+					ExtraPos++;
+					break;
+				case 0x02<<6:
+					Integrator += BlockCode;
+					break;
+				case 0x00:
+					Integrator -= BlockCode;
+					break;
+			}
+			Decompressed[Idx] = Integrator;
+			BlockByte <<= 2;
+			BlockLen -= 1;
+		}
+	}
+	*StartPos = ExtraPos;
+	*BlockTypeStartPos = BlockTypePos;
+	return Idx;
+}
+
+
+/*
+ * usbvision_parse_compress()
+ *
+ * Parse compressed frame from the scratch buffer, put
+ * decoded RGB value into the current frame buffer and add the written
+ * number of bytes (RGB) to the *pcopylen.
+ *
+ */
+static enum ParseState usbvision_parse_compress(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+#define USBVISION_STRIP_MAGIC		0x5A
+#define USBVISION_STRIP_LEN_MAX		400
+#define USBVISION_STRIP_HEADER_LEN	3
+
+	struct usbvision_frame *frame;
+	unsigned char *f,*u = NULL ,*v = NULL;
+	unsigned char StripData[USBVISION_STRIP_LEN_MAX];
+	unsigned char StripHeader[USBVISION_STRIP_HEADER_LEN];
+	int Idx, IdxEnd, StripLen, StripPtr, StartBlockPos, BlockPos, BlockTypePos;
+	int clipmask_index, bytes_per_pixel, rc;
+	int overlay = usbvision->overlay;
+	int imageSize;
+	unsigned char rv, gv, bv;
+	static unsigned char *Y, *U, *V;
+
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		imageSize = frame->frmwidth * frame->frmheight; 
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return ParseState_NextFrame;
+		}
+		f = usbvision->overlay_win + frame->curline *
+			usbvision->vid_buf.bytesperline;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curFrameNum];
+		imageSize = frame->frmwidth * frame->frmheight; 				
+		if (frame->v4l_format >= VIDEO_PALETTE_PLANAR){       // this is a planar format 
+			                                               //... v4l_linesize not used here.
+			f = frame->data + (frame->width * frame->curline);
+		} else 
+			f = frame->data + (frame->v4l_linesize * frame->curline);
+		
+		if (frame->v4l_format == VIDEO_PALETTE_YUV422P){ //initialise u and v pointers
+			                                         // get base of u and b planes add halfoffset
+			
+			u = frame->data 
+				+ imageSize 	
+				+ (frame->frmwidth >>1) * frame->curline ;
+			v = u + (imageSize >>1 );
+			
+		} else if (frame->v4l_format == VIDEO_PALETTE_YUV420P){
+			
+		        v = frame->data + imageSize + ((frame->curline* (frame->width))>>2) ; 
+			u = v + (imageSize >>2) ;
+		}
+	}
+
+	if (frame->curline == 0) {
+		usbvision_adjust_compression(usbvision);
+	}
+
+	if (scratch_len(usbvision) < USBVISION_STRIP_HEADER_LEN) {
+		return ParseState_Out;
+	}
+
+	//get strip header without changing the scratch_read_ptr
+	scratch_set_extra_ptr(usbvision, &StripPtr, 0);
+	scratch_get_extra(usbvision, &StripHeader[0], &StripPtr,
+				USBVISION_STRIP_HEADER_LEN);
+
+	if (StripHeader[0] != USBVISION_STRIP_MAGIC) {
+		// wrong strip magic
+		usbvision->stripMagicErrors++;
+		return ParseState_NextFrame;
+	}
+
+	if (frame->curline != (int)StripHeader[2]) {
+		//line number missmatch error
+		usbvision->stripLineNumberErrors++;
+	}
+
+	StripLen = 2 * (unsigned int)StripHeader[1];
+	if (StripLen > USBVISION_STRIP_LEN_MAX) {
+		// strip overrun
+		// I think this never happens
+		usbvision_request_intra(usbvision);
+	}
+
+	if (scratch_len(usbvision) < StripLen) {
+		//there is not enough data for the strip
+		return ParseState_Out;
+	}
+
+	if (usbvision->IntraFrameBuffer) {
+		Y = usbvision->IntraFrameBuffer + frame->frmwidth * frame->curline;
+		U = usbvision->IntraFrameBuffer + imageSize + (frame->frmwidth / 2) * (frame->curline / 2);
+		V = usbvision->IntraFrameBuffer + imageSize / 4 * 5 + (frame->frmwidth / 2) * (frame->curline / 2);
+	}
+	else {
+		return ParseState_NextFrame;
+	}
+
+	bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+	clipmask_index = frame->curline * MAX_FRAME_WIDTH;
+
+	scratch_get(usbvision, StripData, StripLen);
+
+	IdxEnd = frame->frmwidth;
+	BlockTypePos = USBVISION_STRIP_HEADER_LEN;
+	StartBlockPos = BlockTypePos + (IdxEnd - 1) / 96 + (IdxEnd / 2 - 1) / 96 + 2;
+	BlockPos = StartBlockPos;
+
+	usbvision->BlockPos = BlockPos;
+
+	if ((rc = usbvision_decompress(usbvision, StripData, Y, &BlockPos, &BlockTypePos, IdxEnd)) != IdxEnd) {
+		//return ParseState_Continue;
+	}
+	if (StripLen > usbvision->maxStripLen) {
+		usbvision->maxStripLen = StripLen;
+	}
+
+	if (frame->curline%2) {
+		if ((rc = usbvision_decompress(usbvision, StripData, V, &BlockPos, &BlockTypePos, IdxEnd/2)) != IdxEnd/2) {
+		//return ParseState_Continue;
+		}
+	}
+	else {
+		if ((rc = usbvision_decompress(usbvision, StripData, U, &BlockPos, &BlockTypePos, IdxEnd/2)) != IdxEnd/2) {
+			//return ParseState_Continue;
+		}
+	}
+
+	if (BlockPos > usbvision->comprBlockPos) {
+		usbvision->comprBlockPos = BlockPos;
+	}
+	if (BlockPos > StripLen) {
+		usbvision->stripLenErrors++;
+	}
+	
+	for (Idx = 0; Idx < IdxEnd; Idx++) {
+		if((overlay) && (clipped_pixel(clipmask_index))) {
+			f += bytes_per_pixel;
+		}
+		else if(frame->v4l_format == VIDEO_PALETTE_YUV422) {
+			*f++ = Y[Idx];
+			*f++ = Idx & 0x01 ? U[Idx/2] : V[Idx/2];
+		}
+		else if(frame->v4l_format == VIDEO_PALETTE_YUV422P) {
+			*f++ = Y[Idx];
+			if ( Idx & 0x01)
+				*u++ = U[Idx>>1] ;
+			else
+				*v++ = V[Idx>>1];
+		}
+		else if (frame->v4l_format == VIDEO_PALETTE_YUV420P) {
+			*f++ = Y [Idx];
+			if ( !((  Idx & 0x01  ) | (  frame->curline & 0x01  )) ){ 
+		            
+/* 				 only need do this for 1 in 4 pixels */
+/* 				 intraframe buffer is YUV420 format */
+
+				*u++ = U[Idx >>1];
+				*v++ = V[Idx >>1];
+			}
+			
+		}
+		else {
+			YUV_TO_RGB_BY_THE_BOOK(Y[Idx], U[Idx/2], V[Idx/2], rv, gv, bv);
+			switch (frame->v4l_format) {
+				case VIDEO_PALETTE_GREY:
+					*f++ = Y[Idx];
+					break;
+				case VIDEO_PALETTE_RGB555:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 2));
+					*f++ = (0x03 & (gv >> 6)) | (0x7C & (rv >> 1));
+					break;
+				case VIDEO_PALETTE_RGB565:
+					*f++ = (0x1F & (bv >> 3)) | (0xE0 & (gv << 3));
+					*f++ = (0x07 & (gv >> 5)) | (0xF8 &  rv);
+					break;
+				case VIDEO_PALETTE_RGB24:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					break;
+				case VIDEO_PALETTE_RGB32:
+					*f++ = bv;
+					*f++ = gv;
+					*f++ = rv;
+					f++;
+					break;
+			}
+		}
+		clipmask_index++;
+	}
+	/* Deal with non-integer no. of bytes for YUV420P */ 
+ 	if (frame->v4l_format != VIDEO_PALETTE_YUV420P ) 
+ 		*pcopylen += frame->v4l_linesize; 
+ 	else 
+ 		*pcopylen += frame->curline & 0x01 ? frame->v4l_linesize : frame->v4l_linesize << 1;  
+  
+	frame->curline += 1;
+
+	if (frame->curline >= frame->frmheight) {
+		return ParseState_NextFrame;
+	}
+	else {
+		return ParseState_Continue;
+	}
+
+}
+
+
+/*
+ * usbvision_parse_lines_420()
+ *
+ * Parse two lines from the scratch buffer, put
+ * decoded RGB value into the current frame buffer and add the written
+ * number of bytes (RGB) to the *pcopylen.
+ *
+ */
+static enum ParseState usbvision_parse_lines_420(struct usb_usbvision *usbvision,
+					   long *pcopylen)
+{
+	struct usbvision_frame *frame;
+	unsigned char *f_even = NULL, *f_odd = NULL;
+	unsigned int pixel_per_line, block;
+	int pixel, block_split;
+	int y_ptr, u_ptr, v_ptr, y_odd_offset;
+	const int   y_block_size = 128;
+	const int  uv_block_size = 64;
+	const int sub_block_size = 32;
+	const int y_step[] = { 0, 0, 0, 2 },  y_step_size = 4;
+	const int uv_step[]= { 0, 0, 0, 4 }, uv_step_size = 4;
+	unsigned char y[2], u, v;	/* YUV components */
+	int y_, u_, v_, vb, uvg, ur;
+	int r_, g_, b_;			/* RGB components */
+	unsigned char g;
+	int clipmask_even_index, clipmask_odd_index, bytes_per_pixel;
+	int clipmask_add, stretch_bytes;
+	int overlay = usbvision->overlay;
+
+	if (overlay) {
+		frame  = &usbvision->overlay_frame;
+		if (usbvision->overlay_base == NULL) {
+			//video_buffer is not set yet
+			return ParseState_NextFrame;
+		}
+		f_even = usbvision->overlay_win + frame->curline *
+			 usbvision->vid_buf.bytesperline;
+		f_odd  = f_even + usbvision->vid_buf.bytesperline * usbvision->stretch_height;
+	}
+	else {
+		frame  = &usbvision->frame[usbvision->curFrameNum];
+		f_even = frame->data + (frame->v4l_linesize * frame->curline);
+		f_odd  = f_even + frame->v4l_linesize * usbvision->stretch_height;
+	}
+
+	/* Make sure there's enough data for the entire line */
+	/* In this mode usbvision transfer 3 bytes for every 2 pixels */
+	/* I need two lines to decode the color */
+	bytes_per_pixel = usbvision_v4l_format[frame->v4l_format].bytes_per_pixel;
+	stretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;
+	clipmask_even_index = frame->curline * MAX_FRAME_WIDTH;
+	clipmask_odd_index  = clipmask_even_index + MAX_FRAME_WIDTH;
+	clipmask_add = usbvision->stretch_width;
+	pixel_per_line = frame->isocHeader.frameWidth;
+
+	if (scratch_len(usbvision) < (int)pixel_per_line * 3) {
+		//printk(KERN_DEBUG "out of data, need %d\n", len);
+		return ParseState_Out;
+	}
+
+	if ((frame->curline + 1) >= frame->frmheight) {
+		return ParseState_NextFrame;
+	}
+
+	block_split = (pixel_per_line%y_block_size) ? 1 : 0;	//are some blocks splitted into different lines?
+
+	y_odd_offset = (pixel_per_line / y_block_size) * (y_block_size + uv_block_size)
+			+ block_split * uv_block_size;
+
+	scratch_set_extra_ptr(usbvision, &y_ptr, y_odd_offset);
+	scratch_set_extra_ptr(usbvision, &u_ptr, y_block_size);
+	scratch_set_extra_ptr(usbvision, &v_ptr, y_odd_offset
+			+ (4 - block_split) * sub_block_size);
+
+	for (block = 0; block < (pixel_per_line / sub_block_size);
+	     block++) {
+
+
+		for (pixel = 0; pixel < sub_block_size; pixel +=2) {
+			scratch_get(usbvision, &y[0], 2);
+			scratch_get_extra(usbvision, &u, &u_ptr, 1);
+			scratch_get_extra(usbvision, &v, &v_ptr, 1);
+
+			//I don't use the YUV_TO_RGB macro for better performance
+			v_ = v - 128;
+			u_ = u - 128;
+			vb =              132252 * v_;
+			uvg= -53281 * u_ - 25625 * v_;
+			ur = 104595 * u_;
+
+			if((overlay) && (clipped_pixel(clipmask_even_index))) {
+				f_even += bytes_per_pixel;
+			}
+			else if(frame->v4l_format == VIDEO_PALETTE_YUV422) {
+				*f_even++ = y[0];
+				*f_even++ = v;
+			}
+			else {
+				y_ = 76284 * (y[0] - 16);
+
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_even++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						f_even++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_even++ = (0x03 & (          g   >> 6)) |
+							    (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;
+				}
+			}
+			clipmask_even_index += clipmask_add;
+			f_even += stretch_bytes;
+
+			if((overlay) && (clipped_pixel(clipmask_even_index))) {
+				f_even += bytes_per_pixel;
+			}
+			else if(frame->v4l_format == VIDEO_PALETTE_YUV422) {
+				*f_even++ = y[1];
+				*f_even++ = u;
+			}
+			else {
+				y_ = 76284 * (y[1] - 16);
+
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_even++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_even++ = LIMIT_RGB(b_);
+						*f_even++ = LIMIT_RGB(g_);
+						*f_even++ = LIMIT_RGB(r_);
+						f_even++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_even++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_even++ = (0x03 & (          g   >> 6)) |
+							    (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;
+				}
+			}
+			clipmask_even_index += clipmask_add;
+			f_even += stretch_bytes;
+
+			scratch_get_extra(usbvision, &y[0], &y_ptr, 2);
+
+			if ((overlay) && (clipped_pixel(clipmask_odd_index))) {
+				f_odd += bytes_per_pixel;
+			}
+			else if(frame->v4l_format == VIDEO_PALETTE_YUV422) {
+				*f_odd++ = y[0];
+				*f_odd++ = v;
+			}
+			else {
+				y_ = 76284 * (y[0] - 16);
+
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_odd++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						f_odd++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_odd++ = (0x03 & (          g   >> 6)) |
+							   (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;
+				}
+			}
+			clipmask_odd_index += clipmask_add;
+			f_odd += stretch_bytes;
+
+			if((overlay) && (clipped_pixel(clipmask_odd_index))) {
+				f_odd += bytes_per_pixel;
+			}
+			else if(frame->v4l_format == VIDEO_PALETTE_YUV422) {
+				*f_odd++ = y[1];
+				*f_odd++ = u;
+			}
+			else {
+				y_ = 76284 * (y[1] - 16);
+
+				b_ = (y_ + vb) >> 16;
+				g_ = (y_ + uvg)>> 16;
+				r_ = (y_ + ur) >> 16;
+
+				switch (frame->v4l_format) {
+					case VIDEO_PALETTE_RGB565:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 3));
+						*f_odd++ = (0x07 & (          g   >> 5)) | (0xF8 & LIMIT_RGB(r_));
+						break;
+					case VIDEO_PALETTE_RGB24:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						break;
+					case VIDEO_PALETTE_RGB32:
+						*f_odd++ = LIMIT_RGB(b_);
+						*f_odd++ = LIMIT_RGB(g_);
+						*f_odd++ = LIMIT_RGB(r_);
+						f_odd++;
+						break;
+					case VIDEO_PALETTE_RGB555:
+						g = LIMIT_RGB(g_);
+						*f_odd++ = (0x1F & (LIMIT_RGB(b_) >> 3)) | (0xE0 & (g << 2));
+						*f_odd++ = (0x03 & (          g   >> 6)) |
+							   (0x7C & (LIMIT_RGB(r_) >> 1));
+						break;
+				}
+			}
+			clipmask_odd_index += clipmask_add;
+			f_odd += stretch_bytes;
+		}
+
+		scratch_rm_old(usbvision,y_step[block % y_step_size] * sub_block_size);
+		scratch_inc_extra_ptr(&y_ptr, y_step[(block + 2 * block_split) % y_step_size]
+				* sub_block_size);
+		scratch_inc_extra_ptr(&u_ptr, uv_step[block % uv_step_size]
+				* sub_block_size);
+		scratch_inc_extra_ptr(&v_ptr, uv_step[(block + 2 * block_split) % uv_step_size]
+				* sub_block_size);
+	}
+
+	scratch_rm_old(usbvision, pixel_per_line * 3 / 2
+			+ block_split * sub_block_size);
+
+	frame->curline += 2 * usbvision->stretch_height;
+	*pcopylen += frame->v4l_linesize * 2 * usbvision->stretch_height;
+
+	if (frame->curline >= frame->frmheight)
+		return ParseState_NextFrame;
+	else
+		return ParseState_Continue;
+}
+
+/*
+ * usbvision_parse_data()
+ *
+ * Generic routine to parse the scratch buffer. It employs either
+ * usbvision_find_header() or usbvision_parse_lines() to do most
+ * of work.
+ *
+ */
+static void usbvision_parse_data(struct usb_usbvision *usbvision)
+{
+	struct usbvision_frame *frame;
+	enum ParseState newstate;
+	long copylen = 0;
+
+	if (usbvision->overlay) {
+		frame = &usbvision->overlay_frame;
+	}
+	else {
+		frame = &usbvision->frame[usbvision->curFrameNum];
+	}
+
+	PDEBUG(DBG_PARSE, "parsing len=%d\n", scratch_len(usbvision));
+
+
+	while (1) {
+
+		newstate = ParseState_Out;
+		if (scratch_len(usbvision)) {
+			if (frame->scanstate == ScanState_Scanning) {
+				newstate = usbvision_find_header(usbvision);
+			}
+			else if (frame->scanstate == ScanState_Lines) {
+				if (usbvision->isocMode == ISOC_MODE_YUV420) {
+					newstate = usbvision_parse_lines_420(usbvision, &copylen);
+				}
+				else if (usbvision->isocMode == ISOC_MODE_YUV422) {
+					newstate = usbvision_parse_lines_422(usbvision, &copylen);
+				}
+				else if (usbvision->isocMode == ISOC_MODE_COMPRESS) {
+					newstate = usbvision_parse_compress(usbvision, &copylen);
+				}
+
+			}
+		}
+		if (newstate == ParseState_Continue) {
+			continue;
+		}
+		else if ((newstate == ParseState_NextFrame) || (newstate == ParseState_Out)) {
+			break;
+		}
+		else {
+			return;	/* ParseState_EndParse */
+		}
+	}
+
+	if (newstate == ParseState_NextFrame) {
+		frame->grabstate = FrameState_Done;
+		if (usbvision->overlay) {
+			frame->grabstate = FrameState_Grabbing;
+			frame->scanstate = ScanState_Scanning;
+			frame->scanlength = 0;
+			copylen = 0;
+		}
+		else {
+			usbvision->curFrameNum = -1;
+		}
+		usbvision->frame_num++;
+
+		/* Optionally display statistics on the screen */
+		if (flags & FLAGS_OSD_STATS)
+			usbvision_osd_stats(usbvision, frame);
+
+		/* This will cause the process to request another frame. */
+		if (waitqueue_active(&frame->wq)) {
+			wake_up_interruptible(&frame->wq);
+		}
+	}
+
+	/* Update the frame's uncompressed length. */
+	frame->scanlength += copylen;
+}
+
+
+/*
+ * Make all of the blocks of data contiguous
+ */
+static int usbvision_compress_isochronous(struct usb_usbvision *usbvision,
+				       struct urb *urb)
+{
+	unsigned char *packet_data;
+	int i, totlen = 0;
+
+	for (i = 0; i < urb->number_of_packets; i++) {
+		int packet_len = urb->iso_frame_desc[i].actual_length;
+		int packet_stat = urb->iso_frame_desc[i].status;
+
+		packet_data = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+
+		/* Detect and ignore errored packets */
+		if (packet_stat) {	// packet_stat != 0 ?????????????
+			PDEBUG(DBG_ISOC, "data error: [%d] len=%d, status=%X", i, packet_len, packet_stat);
+			usbvision->isocErrCount++;
+			continue;
+		}
+
+		/* Detect and ignore empty packets */
+		if (packet_len < 0) {
+			PDEBUG(DBG_ISOC, "error packet [%d]", i);
+			usbvision->isocSkipCount++;
+			continue;
+		}
+		else if (packet_len == 0) {	/* Frame end ????? */
+			PDEBUG(DBG_ISOC, "null packet [%d]", i);
+			usbvision->isocstate=IsocState_NoFrame;
+			usbvision->isocSkipCount++;
+			continue;
+		}
+		else if (packet_len > usbvision->isocPacketSize) {
+			PDEBUG(DBG_ISOC, "packet[%d] > isocPacketSize", i);
+			usbvision->isocSkipCount++;
+			continue;
+		}
+
+		PDEBUG(DBG_ISOC, "packet ok [%d] len=%d", i, packet_len);
+
+		if (usbvision->isocstate==IsocState_NoFrame) { //new frame begins
+			usbvision->isocstate=IsocState_InFrame;
+			scratch_mark_header(usbvision);
+			usbvision_measure_bandwidth(usbvision);
+			PDEBUG(DBG_ISOC, "packet with header");
+  }
+
+  /*
+   * If usbvision continues to feed us with data but there is no
+   * consumption (if, for example, V4L client fell asleep) we
+   * may overflow the buffer. We have to move old data over to
+   * free room for new data. This is bad for old data. If we
+   * just drop new data then it's bad for new data... choose
+   * your favorite evil here.
+   */
+  if (scratch_free(usbvision) < packet_len) {
+
+   usbvision->scratch_ovf_count++;
+   PDEBUG(DBG_ISOC, "scratch buf overflow! scr_len: %d, n: %d",
+           scratch_len(usbvision), packet_len);
+   scratch_rm_old(usbvision, packet_len - scratch_free(usbvision));
+  }
+
+  /* Now we know that there is enough room in scratch buffer */
+  scratch_put(usbvision, packet_data, packet_len);
+  totlen += packet_len;
+  usbvision->isocDataCount += packet_len;
+  usbvision->isocPacketCount++;
+ }
+#if ENABLE_HEXDUMP
+ if (totlen > 0) {
+  static int foo = 0;
+  if (foo < 1) {
+   printk(KERN_DEBUG "+%d.\n", usbvision->scratchlen);
+   usbvision_hexdump(data0, (totlen > 64) ? 64 : totlen);
+   ++foo;
+  }
+ }
+#endif
+ return totlen;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbvision_isocIrq(struct urb *urb)
+{
+#else
+static void usbvision_isocIrq(struct urb *urb, struct pt_regs *regs)
+{
+ int errCode = 0;
+#endif
+ int len;
+ struct usb_usbvision *usbvision = urb->context;
+ int i;
+ unsigned long startTime = jiffies;
+
+ /* We don't want to do anything if we are about to be removed! */
+ if (!USBVISION_IS_OPERATIONAL(usbvision))
+  return;
+
+ if (!usbvision->streaming) {
+  PDEBUG(DBG_IRQ, "oops, not streaming, but interrupt");
+  return;
+ }
+
+ /* Copy the data received into our scratch buffer */
+ len = usbvision_compress_isochronous(usbvision, urb);
+
+ usbvision->isocUrbCount++;
+ usbvision->urb_length = len;
+
+ for (i = 0; i < USBVISION_URB_FRAMES; i++) {
+  urb->iso_frame_desc[i].status = 0;
+  urb->iso_frame_desc[i].actual_length = 0;
+ }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+ 	urb->status = 0;
+	urb->dev = usbvision->dev;
+	errCode = usb_submit_urb (urb, GFP_ATOMIC);
+	if(errCode) {
+		err("%s: usb_submit_urb failed: error %d", __FUNCTION__, errCode);
+	}
+#endif
+
+	/* If we collected enough data let's parse! */
+	if (scratch_len(usbvision) > USBVISION_HEADER_LENGTH) {	/* 12 == header_length */
+		/*If we don't have a frame we're current working on, complain */
+		if ((usbvision->curFrameNum >= 0) || (usbvision->overlay))
+			usbvision_parse_data(usbvision);
+		else {
+			PDEBUG(DBG_IRQ, "received data, but no one needs it");
+			scratch_reset(usbvision);
+		}
+	}
+	usbvision->timeInIrq += jiffies - startTime;
+	return;
+}
+
+/*************************************/
+/* Low level usbvision access functions */
+/*************************************/
+
+/*
+ * usbvision_read_reg()
+ *
+ * return  < 0 -> Error
+ *        >= 0 -> Data
+ */
+
+static int usbvision_read_reg(struct usb_usbvision *usbvision, unsigned char reg)
+{
+	int errCode = 0;
+	unsigned char buffer[1];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -1;
+
+	errCode = usb_control_msg(usbvision->dev, usb_rcvctrlpipe(usbvision->dev, 1),
+				USBVISION_OP_CODE,
+				USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT,
+				0, (__u16) reg, buffer, 1, HZ);
+
+	if (errCode < 0) {
+		err("%s: failed: error %d", __FUNCTION__, errCode);
+		return errCode;
+	}
+	return buffer[0];
+}
+
+/*
+ * usbvision_write_reg()
+ *
+ * return 1 -> Reg written
+ *        0 -> usbvision is not yet ready
+ *       -1 -> Something went wrong
+ */
+
+static int usbvision_write_reg(struct usb_usbvision *usbvision, unsigned char reg,
+			    unsigned char value)
+{
+	int errCode = 0;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	errCode = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+				USBVISION_OP_CODE,
+				USB_DIR_OUT | USB_TYPE_VENDOR |
+				USB_RECIP_ENDPOINT, 0, (__u16) reg, &value, 1, HZ);
+
+	if (errCode < 0) {
+		err("%s: failed: error %d", __FUNCTION__, errCode);
+	}
+	return errCode;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbvision_ctrlUrb_complete(struct urb *urb)
+#else
+static void usbvision_ctrlUrb_complete(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)urb->context;
+
+	PDEBUG(DBG_IRQ, "");
+	usbvision->ctrlUrbBusy = 0;
+	if (waitqueue_active(&usbvision->ctrlUrb_wq)) {
+		wake_up_interruptible(&usbvision->ctrlUrb_wq);
+	}
+}
+
+
+static int usbvision_write_reg_irq(struct usb_usbvision *usbvision,int address,
+									unsigned char *data, int len)
+{
+	int errCode = 0;
+
+	PDEBUG(DBG_IRQ, "");
+	if (len > 8) {
+		return -EFAULT;
+	}
+//	down(&usbvision->ctrlUrbLock);
+	if (usbvision->ctrlUrbBusy) {
+//		up(&usbvision->ctrlUrbLock);
+		return -EBUSY;
+	}
+	usbvision->ctrlUrbBusy = 1;
+//	up(&usbvision->ctrlUrbLock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20)
+	usbvision->ctrlUrbSetup.requesttype = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;
+	usbvision->ctrlUrbSetup.request     = USBVISION_OP_CODE;
+	usbvision->ctrlUrbSetup.value       = 0;
+	usbvision->ctrlUrbSetup.index       = cpu_to_le16(address);
+	usbvision->ctrlUrbSetup.length      = cpu_to_le16(len);
+#else
+	usbvision->ctrlUrbSetup.bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;
+	usbvision->ctrlUrbSetup.bRequest     = USBVISION_OP_CODE;
+	usbvision->ctrlUrbSetup.wValue       = 0;
+	usbvision->ctrlUrbSetup.wIndex       = cpu_to_le16(address);
+	usbvision->ctrlUrbSetup.wLength      = cpu_to_le16(len);
+#endif
+	usb_fill_control_urb (usbvision->ctrlUrb, usbvision->dev,
+							usb_sndctrlpipe(usbvision->dev, 1),
+							(unsigned char *)&usbvision->ctrlUrbSetup,
+							(void *)usbvision->ctrlUrbBuffer, len,
+							usbvision_ctrlUrb_complete,
+							(void *)usbvision);
+
+	memcpy(usbvision->ctrlUrbBuffer, data, len);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	errCode = usb_submit_urb(usbvision->ctrlUrb);
+#else
+	errCode = usb_submit_urb(usbvision->ctrlUrb, GFP_ATOMIC);
+#endif
+	if (errCode < 0) {
+		// error in usb_submit_urb()
+		usbvision->ctrlUrbBusy = 0;
+	}
+	PDEBUG(DBG_IRQ, "submit %d byte: error %d", len, errCode);
+	return errCode;
+}
+
+
+#if 0
+static int usbvision_read_reg_irq(struct usb_usbvision *usbvision,int address,
+									unsigned char *data, int len)
+{
+	int errCode = 0;
+
+	PDEBUG(DBG_IRQ, "");
+	if (len > 8) {
+		return -EFAULT;
+	}
+
+	down(&usbvision->ctrlUrbLock);
+	if (usbvision->ctrlUrbBusy) {
+		up(&usbvision->ctrlUrbLock);
+		return -EBUSY;
+	}
+
+	usbvision->ctrlUrbBusy = 1;
+	up(&usbvision->ctrlUrbLock);
+
+	usbvision->ctrlUrbSetup.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;
+	usbvision->ctrlUrbSetup.bRequest     = USBVISION_OP_CODE;
+	usbvision->ctrlUrbSetup.wValue       = 0;
+	usbvision->ctrlUrbSetup.wIndex       = cpu_to_le16(address);
+	usbvision->ctrlUrbSetup.wLength      = cpu_to_le16(len);
+
+	usb_fill_control_urb (usbvision->ctrlUrb, usbvision->dev,
+							usb_rcvctrlpipe(usbvision->dev, 1),
+							(unsigned char *)&usbvision->ctrlUrbSetup,
+							(void *)usbvision->ctrlUrbBuffer, len,
+							usbvision_ctrlUrb_complete,
+							(void *)usbvision);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	errCode = usb_submit_urb(usbvision->ctrlUrb);
+#else
+	errCode = usb_submit_urb(usbvision->ctrlUrb, GFP_ATOMIC);
+#endif
+	if (errCode < 0) {
+		// error in usb_submit_urb()
+		usbvision->ctrlUrbBusy = 0;
+	}
+	else {
+		wait_event_interruptible(usbvision->ctrlUrb_wq, usbvision->ctrlUrbBusy == 0);
+		memcpy(data, usbvision->ctrlUrbBuffer, len);
+	}
+
+	PDEBUG(DBG_IRQ, "read %d byte: error %d", len, errCode);
+	return errCode;
+}
+#endif
+
+
+static int usbvision_init_compression(struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+
+	usbvision->lastIsocFrameNum = -1;
+	usbvision->isocDataCount = 0;
+	usbvision->isocPacketCount = 0;
+	usbvision->isocSkipCount = 0;
+	usbvision->comprLevel = 50;
+	usbvision->lastComprLevel = -1;
+	usbvision->isocUrbCount = 0;
+	usbvision->requestIntra = 1;
+	usbvision->isocMeasureBandwidthCount = 0;
+
+	return errCode;
+}
+
+/* this function measures the used bandwidth since last call
+ * return:    0 : no error
+ * sets usedBandwidth to 1-100 : 1-100% of full bandwidth resp. to isocPacketSize
+ */
+static int usbvision_measure_bandwidth (struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+
+	if (usbvision->isocMeasureBandwidthCount < 2) { // this gives an average bandwidth of 3 frames
+		usbvision->isocMeasureBandwidthCount++;
+		return errCode;
+	}
+	if ((usbvision->isocPacketSize > 0) && (usbvision->isocPacketCount > 0)) {
+		usbvision->usedBandwidth = usbvision->isocDataCount /
+					(usbvision->isocPacketCount + usbvision->isocSkipCount) *
+					100 / usbvision->isocPacketSize;
+	}
+	usbvision->isocMeasureBandwidthCount = 0;
+	usbvision->isocDataCount = 0;
+	usbvision->isocPacketCount = 0;
+	usbvision->isocSkipCount = 0;
+	return errCode;
+}
+
+static int usbvision_adjust_compression (struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+	unsigned char buffer[6];
+
+	PDEBUG(DBG_IRQ, "");
+	if ((adjustCompression) && (usbvision->usedBandwidth > 0)) {
+		usbvision->comprLevel += (usbvision->usedBandwidth - 90) / 2;
+		RESTRICT_TO_RANGE(usbvision->comprLevel, 0, 100);
+		if (usbvision->comprLevel != usbvision->lastComprLevel) {
+			int distorsion;
+			if (usbvision->bridgeType == BRIDGE_NT1004) {
+				buffer[0] = (unsigned char)(4 + 16 * usbvision->comprLevel / 100);	// PCM Threshold 1
+				buffer[1] = (unsigned char)(4 + 8 * usbvision->comprLevel / 100);	// PCM Threshold 2
+				distorsion = 7 + 248 * usbvision->comprLevel / 100;
+				buffer[2] = (unsigned char)(distorsion & 0xFF);				// Average distorsion Threshold (inter)
+				buffer[3] = (unsigned char)(distorsion & 0xFF);				// Average distorsion Threshold (intra)
+				distorsion = 1 + 42 * usbvision->comprLevel / 100;
+				buffer[4] = (unsigned char)(distorsion & 0xFF);				// Maximum distorsion Threshold (inter)
+				buffer[5] = (unsigned char)(distorsion & 0xFF);				// Maximum distorsion Threshold (intra)
+			}
+			else { //BRIDGE_NT1003
+				buffer[0] = (unsigned char)(4 + 16 * usbvision->comprLevel / 100);	// PCM threshold 1
+				buffer[1] = (unsigned char)(4 + 8 * usbvision->comprLevel / 100);	// PCM threshold 2
+				distorsion = 2 + 253 * usbvision->comprLevel / 100;
+				buffer[2] = (unsigned char)(distorsion & 0xFF);				// distorsion threshold bit0-7
+				buffer[3] = 0; 	//(unsigned char)((distorsion >> 8) & 0x0F);		// distorsion threshold bit 8-11
+				distorsion = 0 + 43 * usbvision->comprLevel / 100;
+				buffer[4] = (unsigned char)(distorsion & 0xFF);				// maximum distorsion bit0-7
+				buffer[5] = 0; //(unsigned char)((distorsion >> 8) & 0x01);		// maximum distorsion bit 8
+			}
+			errCode = usbvision_write_reg_irq(usbvision, USBVISION_PCM_THR1, buffer, 6);
+			if (errCode == 0){
+				PDEBUG(DBG_IRQ, "new compr params %#02x %#02x %#02x %#02x %#02x %#02x", buffer[0],
+								buffer[1], buffer[2], buffer[3], buffer[4], buffer[5]);
+				usbvision->lastComprLevel = usbvision->comprLevel;
+			}
+		}
+	}
+	return errCode;
+}
+
+static int usbvision_request_intra (struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+	unsigned char buffer[1];
+
+	PDEBUG(DBG_IRQ, "");
+	usbvision->requestIntra = 1;
+	buffer[0] = 1;
+	usbvision_write_reg_irq(usbvision, USBVISION_FORCE_INTRA, buffer, 1);
+	return errCode;
+}
+
+static int usbvision_unrequest_intra (struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+	unsigned char buffer[1];
+
+	PDEBUG(DBG_IRQ, "");
+	usbvision->requestIntra = 0;
+	buffer[0] = 0;
+	usbvision_write_reg_irq(usbvision, USBVISION_FORCE_INTRA, buffer, 1);
+	return errCode;
+}
+
+/* ----------------------------------------------------------------------- */
+/* I2C functions                                                           */
+/* ----------------------------------------------------------------------- */
+
+static void call_i2c_clients(struct usb_usbvision *usbvision, unsigned int cmd,
+			     void *arg)
+{
+#if 0  // new version from bttv-if.c
+	if (0 != btv->i2c_rc)
+		return;
+	i2c_clients_command(&btv->i2c_adap, cmd, arg);
+#endif
+
+	int i;
+
+	for (i = 0; i < USBVISION_I2C_CLIENTS_MAX; i++) {
+		if (NULL == usbvision->i2c_clients[i])
+			continue;
+		if (NULL == usbvision->i2c_clients[i]->driver->command)
+			continue;
+		usbvision->i2c_clients[i]->driver->command(usbvision->i2c_clients[i], cmd, arg);
+	}
+}
+
+static int attach_inform(struct i2c_client *client)
+{
+	struct usb_usbvision *usbvision;
+	int i;
+
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		usbvision = (struct usb_usbvision *)client->adapter->data;
+	#else
+		usbvision = (struct usb_usbvision *)i2c_get_adapdata(client->adapter);
+	#endif
+
+	for (i = 0; i < USBVISION_I2C_CLIENTS_MAX; i++) {
+		if (usbvision->i2c_clients[i] == NULL ||
+		    usbvision->i2c_clients[i]->driver->id ==
+		    client->driver->id) {
+			usbvision->i2c_clients[i] = client;
+			break;
+		}
+	}
+
+	if ((usbvision->have_tuner) && (usbvision->tuner_type != -1)) {
+
+		call_i2c_clients(usbvision, TUNER_SET_TYPE_ADDR, &usbvision->tuner_type);
+		call_i2c_clients(usbvision, VIDIOCSCHAN, &usbvision->vchan);
+	}
+	call_i2c_clients(usbvision, DECODER_SET_PICTURE, &usbvision->vpic);
+	i = usbvision->vchan.norm;
+	call_i2c_clients(usbvision, DECODER_SET_NORM, &i);
+
+	PDEBUG(DBG_I2C, "usbvision[%d] attaches %s", usbvision->nr, client->name);
+
+	return 0;
+}
+
+static int detach_inform(struct i2c_client *client)
+{
+	struct usb_usbvision *usbvision;
+	int i;
+
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		usbvision = (struct usb_usbvision *)client->adapter->data;
+	#else
+		usbvision = (struct usb_usbvision *)i2c_get_adapdata(client->adapter);
+	#endif
+
+	PDEBUG(DBG_I2C, "usbvision[%d] detaches %s", usbvision->nr, client->name);
+	for (i = 0; i < USBVISION_I2C_CLIENTS_MAX; i++) {
+		if (NULL != usbvision->i2c_clients[i] &&
+		    usbvision->i2c_clients[i]->driver->id ==
+		    client->driver->id) {
+			usbvision->i2c_clients[i] = NULL;
+			break;
+		}
+	}
+	return 0;
+}
+
+static int
+usbvision_i2c_read_max4(struct usb_usbvision *usbvision, unsigned char addr,
+		     char *buf, short len)
+{
+	int rc, retries;
+
+	for (retries = 5;;) {
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_ADRS, addr);
+		if (rc < 0)
+			return rc;
+
+		/* Initiate byte read cycle                    */
+		/* USBVISION_SER_CONT <- d0-d2 n. of bytes to r/w */
+		/*                    d3 0=Wr 1=Rd             */
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,
+				      (len & 0x07) | 0x18);
+		if (rc < 0)
+			return rc;
+
+		/* Test for Busy and ACK */
+		do {
+			/* USBVISION_SER_CONT -> d4 == 0 busy */
+			rc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);
+		} while (rc > 0 && ((rc & 0x10) != 0));	/* Retry while busy */
+		if (rc < 0)
+			return rc;
+
+		/* USBVISION_SER_CONT -> d5 == 1 Not ack */
+		if ((rc & 0x20) == 0)	/* Ack? */
+			break;
+
+		/* I2C abort */
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);
+		if (rc < 0)
+			return rc;
+
+		if (--retries < 0)
+			return -1;
+	}
+
+	switch (len) {
+	case 4:
+		buf[3] = usbvision_read_reg(usbvision, USBVISION_SER_DAT4);
+	case 3:
+		buf[2] = usbvision_read_reg(usbvision, USBVISION_SER_DAT3);
+	case 2:
+		buf[1] = usbvision_read_reg(usbvision, USBVISION_SER_DAT2);
+	case 1:
+		buf[0] = usbvision_read_reg(usbvision, USBVISION_SER_DAT1);
+		break;
+	default:
+		printk(KERN_ERR
+		       "usbvision_i2c_read_max4: buffer length > 4\n");
+	}
+
+	if (debug & DBG_I2C) {
+		int idx, debugAddr;
+		debugAddr = (int)addr;
+		for (idx = 0; idx < len; idx++) {
+			PDEBUG(DBG_I2C, "read %d from address %d", (int)buf[idx], debugAddr);
+		}
+	}
+	return len;
+}
+
+
+static int usbvision_i2c_write_max4(struct usb_usbvision *usbvision,
+				 unsigned char addr, const char *buf,
+				 short len)
+{
+	int rc, retries;
+	int i;
+	unsigned char value[6];
+	unsigned char ser_cont;
+
+	ser_cont = (len & 0x07) | 0x10;
+
+	value[0] = addr;
+	value[1] = ser_cont;
+	for (i = 0; i < len; i++)
+		value[i + 2] = buf[i];
+
+	for (retries = 5;;) {
+		rc = usb_control_msg(usbvision->dev,
+				     usb_sndctrlpipe(usbvision->dev, 1),
+				     USBVISION_OP_CODE,
+				     USB_DIR_OUT | USB_TYPE_VENDOR |
+				     USB_RECIP_ENDPOINT, 0,
+				     (__u16) USBVISION_SER_ADRS, value,
+				     len + 2, HZ);
+
+		if (rc < 0)
+			return rc;
+
+		rc = usbvision_write_reg(usbvision, USBVISION_SER_CONT,
+				      (len & 0x07) | 0x10);
+		if (rc < 0)
+			return rc;
+
+		/* Test for Busy and ACK */
+		do {
+			rc = usbvision_read_reg(usbvision, USBVISION_SER_CONT);
+		} while (rc > 0 && ((rc & 0x10) != 0));	/* Retry while busy */
+		if (rc < 0)
+			return rc;
+
+		if ((rc & 0x20) == 0)	/* Ack? */
+			break;
+
+		/* I2C abort */
+		usbvision_write_reg(usbvision, USBVISION_SER_CONT, 0x00);
+
+		if (--retries < 0)
+			return -1;
+
+	}
+
+	if (debug & DBG_I2C) {
+		int idx, debugAddr;
+		debugAddr = (int)addr;
+		for (idx = 0; idx < len; idx++) {
+			PDEBUG(DBG_I2C, "wrote %d at address %d", (int)buf[idx], debugAddr);
+		}
+	}
+	return len;
+}
+
+static int usbvision_i2c_write(void *data, unsigned char addr, char *buf,
+			    short len)
+{
+	char *bufPtr = buf;
+	int retval;
+	int wrcount = 0;
+	int count;
+	int maxLen = 2;
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) data;
+
+	while (len > 0) {
+		count = (len > maxLen) ? maxLen : len;
+		retval = usbvision_i2c_write_max4(usbvision, addr, bufPtr, count);
+		if (retval > 0) {
+			len -= count;
+			bufPtr += count;
+			wrcount += count;
+		} else
+			return (retval < 0) ? retval : -EFAULT;
+	}
+	return wrcount;
+}
+
+static int usbvision_i2c_read(void *data, unsigned char addr, char *buf,
+			   short len)
+{
+	char temp[4];
+	int retval, i;
+	int rdcount = 0;
+	int count;
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) data;
+
+	while (len > 0) {
+		count = (len > 3) ? 4 : len;
+		retval = usbvision_i2c_read_max4(usbvision, addr, temp, count);
+		if (retval > 0) {
+			for (i = 0; i < len; i++)
+				buf[rdcount + i] = temp[i];
+			len -= count;
+			rdcount += count;
+		} else
+			return (retval < 0) ? retval : -EFAULT;
+	}
+	return rdcount;
+}
+
+static struct i2c_algo_usb_data i2c_algo_template = {
+	.data		= NULL,
+	.inb		= usbvision_i2c_read,
+	.outb		= usbvision_i2c_write,
+	.udelay		= 10,
+	.mdelay		= 10,
+	.timeout	= 100,
+};
+
+static struct i2c_adapter i2c_adap_template = {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+#endif
+	.name              = "usbvision",
+	.id                = I2C_HW_B_BT848, /* FIXME */
+	.algo              = NULL,
+	.algo_data         = NULL,
+	.client_register   = attach_inform,
+	.client_unregister = detach_inform,
+#if defined (I2C_ADAP_CLASS_TV_ANALOG)
+	.class             = I2C_ADAP_CLASS_TV_ANALOG,
+#elif defined (I2C_CLASS_TV_ANALOG)
+	.class		   = I2C_CLASS_TV_ANALOG,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	.data              = NULL,
+#endif
+};
+
+static struct i2c_client i2c_client_template = {
+	.name		= "usbvision internal",
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	.id		= -1,
+#endif
+	.flags		= 0,
+	.addr		= 0,
+	.adapter	= NULL,
+	.driver		= NULL,
+};
+
+static int usbvision_init_i2c(struct usb_usbvision *usbvision)
+{
+	memcpy(&usbvision->i2c_adap, &i2c_adap_template,
+	       sizeof(struct i2c_adapter));
+	memcpy(&usbvision->i2c_algo, &i2c_algo_template,
+	       sizeof(struct i2c_algo_usb_data));
+	memcpy(&usbvision->i2c_client, &i2c_client_template,
+	       sizeof(struct i2c_client));
+
+	sprintf(usbvision->i2c_adap.name + strlen(usbvision->i2c_adap.name),
+		" #%d", usbvision->vdev->minor & 0x1f);
+	PDEBUG(DBG_I2C, "Adaptername: %s", usbvision->i2c_adap.name);
+
+	i2c_set_adapdata(&usbvision->i2c_adap, usbvision);
+	i2c_set_clientdata(&usbvision->i2c_client, usbvision);
+	i2c_set_algo_usb_data(&usbvision->i2c_algo, usbvision);
+
+	usbvision->i2c_adap.algo_data = &usbvision->i2c_algo;
+	usbvision->i2c_client.adapter = &usbvision->i2c_adap;
+
+	if (usbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_IIC_LRNACK) < 0) {
+		printk(KERN_ERR "usbvision_init_i2c: can't wirte reg\n");
+		return -EBUSY;
+	}
+
+#ifdef CONFIG_KMOD
+	/* Request the load of the i2c modules we need */
+	if (autoload) {
+		switch (usbvision_device_data[usbvision->DevModel].Codec) {
+			case CODEC_SAA7113:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				request_module("saa7113-new");
+#else				
+				request_module("saa7113");
+#endif
+				break;
+			case CODEC_SAA7111:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				request_module("saa7111-new");
+#else
+				request_module("saa7111");
+#endif
+				break;
+			case CODEC_BT819:
+				request_module("bt819");
+				break;
+		}
+		if (usbvision_device_data[usbvision->DevModel].Tuner == 1) {
+	    	request_module("tuner");
+		}
+	}
+#endif
+
+	usbvision->i2c_ok = i2c_usb_add_bus(&usbvision->i2c_adap);
+
+	return usbvision->i2c_ok;
+
+}
+
+
+/****************************/
+/* usbvision utility functions */
+/****************************/
+
+static int usbvision_power_off(struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+
+	PDEBUG(DBG_FUNC, "");
+
+	errCode = usbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN);
+	if (errCode == 1) {
+		usbvision->power = 0;
+	}
+	PDEBUG(DBG_FUNC, "%s: errCode %d", (errCode!=1)?"ERROR":"power is off", errCode);
+	return errCode;
+}
+
+
+// to call usbvision_power_off from task queue
+static void call_usbvision_power_off(void *_usbvision)
+{
+	struct usb_usbvision *usbvision = _usbvision;
+
+	PDEBUG(DBG_FUNC, "");
+	down_interruptible(&usbvision->lock);
+	if(usbvision->user == 0) {
+		i2c_usb_del_bus(&usbvision->i2c_adap);
+		usbvision_power_off(usbvision);
+		usbvision->initialized = 0;
+	}
+	up(&usbvision->lock);
+}
+
+
+/*
+ * usbvision_set_video_format()
+ *
+ */
+static int usbvision_set_video_format(struct usb_usbvision *usbvision, int format)
+{
+	static const char proc[] = "usbvision_set_video_format";
+	int rc;
+	unsigned char value[2];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	PDEBUG(DBG_FUNC, "isocMode %#02x", format);
+
+	if ((format != ISOC_MODE_YUV422)
+	    && (format != ISOC_MODE_YUV420)
+	    && (format != ISOC_MODE_COMPRESS)) {
+		printk(KERN_ERR "usbvision: unknown video format %02x, using default YUV420",
+		       format);
+		format = ISOC_MODE_YUV420;
+	}
+	value[0] = 0x0A;  //TODO: See the effect of the filter
+	value[1] = format;
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_FILT_CONT, value, 2, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%s: ERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+	}
+	usbvision->isocMode = format;
+	return rc;
+}
+
+/*
+ * usbvision_set_output()
+ *
+ */
+
+static int usbvision_set_output(struct usb_usbvision *usbvision, int width,
+				  int height)
+{
+	int errCode = 0;
+	int UsbWidth, UsbHeight;
+	unsigned int frameRate=0, frameDrop=0;
+	unsigned char value[4];
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision)) {
+		return 0;
+	}
+
+	if (width > MAX_USB_WIDTH) {
+		UsbWidth = width / 2;
+		usbvision->stretch_width = 2;
+	}
+	else {
+		UsbWidth = width;
+		usbvision->stretch_width = 1;
+	}
+
+	if (height > MAX_USB_HEIGHT) {
+		UsbHeight = height / 2;
+		usbvision->stretch_height = 2;
+	}
+	else {
+		UsbHeight = height;
+		usbvision->stretch_height = 1;
+	}
+
+	RESTRICT_TO_RANGE(UsbWidth, MIN_FRAME_WIDTH, MAX_USB_WIDTH);
+	UsbWidth &= ~(MIN_FRAME_WIDTH-1);
+	RESTRICT_TO_RANGE(UsbHeight, MIN_FRAME_HEIGHT, MAX_USB_HEIGHT);
+	UsbHeight &= ~(1);
+
+	PDEBUG(DBG_FUNC, "usb %dx%d; screen %dx%d; stretch %dx%d",
+						UsbWidth, UsbHeight, width, height,
+						usbvision->stretch_width, usbvision->stretch_height);
+
+	/* I'll not rewrite the same values */
+	if ((UsbWidth != usbvision->curwidth) || (UsbHeight != usbvision->curheight)) {
+		value[0] = UsbWidth & 0xff;		//LSB
+		value[1] = (UsbWidth >> 8) & 0x03;	//MSB
+		value[2] = UsbHeight & 0xff;		//LSB
+		value[3] = (UsbHeight >> 8) & 0x03;	//MSB
+
+		errCode = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT,
+				 0, (__u16) USBVISION_LXSIZE_O, value, 4, HZ);
+
+		if (errCode < 0) {
+			err("%s failed: error %d", __FUNCTION__, errCode);
+			return errCode;
+		}
+		usbvision->curwidth = usbvision->stretch_width * UsbWidth;
+		usbvision->curheight = usbvision->stretch_height * UsbHeight;
+	}
+
+	if (usbvision->isocMode == ISOC_MODE_YUV422) {
+		frameRate = (usbvision->isocPacketSize * 1000) / (UsbWidth * UsbHeight * 2);
+	}
+	else if (usbvision->isocMode == ISOC_MODE_YUV420) {
+		frameRate = (usbvision->isocPacketSize * 1000) / ((UsbWidth * UsbHeight * 12) / 8);
+	}
+	else {
+		frameRate = FRAMERATE_MAX;
+	}
+
+	if ((usbvision->vchan.norm == VIDEO_MODE_PAL) ||
+	    (usbvision->vchan.norm == VIDEO_MODE_SECAM)) {
+ 		frameDrop = frameRate * 32 / 25 - 1;
+	}
+	else if (usbvision->vchan.norm == VIDEO_MODE_NTSC) {
+		frameDrop = frameRate * 32 / 30 - 1;
+	}
+
+	RESTRICT_TO_RANGE(frameDrop, FRAMERATE_MIN, FRAMERATE_MAX);
+
+	PDEBUG(DBG_FUNC, "frameRate %d fps, frameDrop %d", frameRate, frameDrop);
+
+	frameDrop = FRAMERATE_MAX; 	// We can allow the maximum here, because dropping is controlled
+
+	/* frameDrop = 7; => framePhase = 1, 5, 9, 13, 17, 21, 25, 0, 4, 8, ...
+		=> frameSkip = 4;
+		=> frameRate = (7 + 1) * 25 / 32 = 200 / 32 = 6.25;
+
+	   frameDrop = 9; => framePhase = 1, 5, 8, 11, 14, 17, 21, 24, 27, 1, 4, 8, ...
+	    => frameSkip = 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4, ...
+		=> frameRate = (9 + 1) * 25 / 32 = 250 / 32 = 7.8125;
+	*/
+	errCode = usbvision_write_reg(usbvision, USBVISION_FRM_RATE, frameDrop);
+	return errCode;
+}
+
+
+/*
+ * usbvision_set_compress_params()
+ *
+ */
+
+static int usbvision_set_compress_params(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_set_compresion_params: ";
+	int rc;
+	unsigned char value[6];
+
+	value[0] = 0x0F;    // Intra-Compression cycle
+	value[1] = 0x01;    // Reg.45 one line per strip
+	value[2] = 0x00;    // Reg.46 Force intra mode on all new frames
+	value[3] = 0x00;    // Reg.47 FORCE_UP <- 0 normal operation (not force)
+	value[4] = 0xA2;    // Reg.48 BUF_THR I'm not sure if this does something in not compressed mode.
+        value[5] = 0x00;    // Reg.49 DVI_YUV This has nothing to do with compression
+
+	//catched values for NT1004
+	// value[0] = 0xFF; // Never apply intra mode automatically
+	// value[1] = 0xF1; // Use full frame height for virtual strip width; One line per strip
+	// value[2] = 0x01; // Force intra mode on all new frames
+	// value[3] = 0x00; // Strip size 400 Bytes; do not force up
+	// value[4] = 0xA2; //
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_INTRA_CYC, value, 5, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+	if (usbvision->bridgeType == BRIDGE_NT1004) {
+		value[0] =  20; // PCM Threshold 1
+		value[1] =  12; // PCM Threshold 2
+		value[2] = 255; // Distorsion Threshold inter
+		value[3] = 255; // Distorsion Threshold intra
+		value[4] =  43; // Max Distorsion inter
+		value[5] =  43; // Max Distorsion intra
+	}
+	else {
+		value[0] =  20; // PCM Threshold 1
+		value[1] =  12; // PCM Threshold 2
+		value[2] = 255; // Distorsion Threshold d7-d0
+		value[3] =   0; // Distorsion Threshold d11-d8
+		value[4] =  43; // Max Distorsion d7-d0
+		value[5] =   0; // Max Distorsion d8
+	}
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_PCM_THR1, value, 6, HZ);
+
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+
+	return rc;
+}
+
+
+/*
+ * usbvision_set_input()
+ *
+ * Set the input (saa711x, bt819 ...) size x y and other misc input params
+ * I've no idea if this parameters are right
+ *
+ */
+static int usbvision_set_input(struct usb_usbvision *usbvision)
+{
+	static const char proc[] = "usbvision_set_input: ";
+	int rc;
+	unsigned char value[8];
+	unsigned char dvi_yuv_value;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	/* Set input format expected from decoder*/
+	if (usbvision_device_data[usbvision->DevModel].Vin_Reg1 >= 0) {
+		value[0] = usbvision_device_data[usbvision->DevModel].Vin_Reg1 & 0xff;
+	} else if(usbvision_device_data[usbvision->DevModel].Codec == CODEC_SAA7113) {
+		/* SAA7113 uses 8 bit output */
+		value[0] = USBVISION_8_422_SYNC;
+	} else {
+		/* I'm sure only about d2-d0 [010] 16 bit 4:2:2 usin sync pulses
+		 * as that is how saa7111 is configured */
+		value[0] = USBVISION_16_422_SYNC;
+		/* | USBVISION_VSNC_POL | USBVISION_VCLK_POL);*/
+	}
+
+	rc = usbvision_write_reg(usbvision, USBVISION_VIN_REG1, value[0]);
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+
+	if (usbvision->vchan.norm == VIDEO_MODE_PAL) {
+		value[0] = 0xC0;
+		value[1] = 0x02;	//0x02C0 -> 704 Input video line length
+		value[2] = 0x20;
+		value[3] = 0x01;	//0x0120 -> 288 Input video n. of lines
+		value[4] = 0x60;
+		value[5] = 0x00;	//0x0060 -> 96 Input video h offset
+		value[6] = 0x16;
+		value[7] = 0x00;	//0x0016 -> 22 Input video v offset
+	} else if (usbvision->vchan.norm == VIDEO_MODE_SECAM) {
+		value[0] = 0xC0;
+		value[1] = 0x02;	//0x02C0 -> 704 Input video line length
+		value[2] = 0x20;
+		value[3] = 0x01;	//0x0120 -> 288 Input video n. of lines
+		value[4] = 0x01;
+		value[5] = 0x00;	//0x0001 -> 01 Input video h offset
+		value[6] = 0x01;
+		value[7] = 0x00;	//0x0001 -> 01 Input video v offset
+	} else {	/* VIDEO_MODE_NTSC */
+		value[0] = 0xD0;
+		value[1] = 0x02;	//0x02D0 -> 720 Input video line length
+		value[2] = 0xF0;
+		value[3] = 0x00;	//0x00F0 -> 240 Input video number of lines
+		value[4] = 0x50;
+		value[5] = 0x00;	//0x0050 -> 80 Input video h offset
+		value[6] = 0x10;
+		value[7] = 0x00;	//0x0010 -> 16 Input video v offset
+	}
+
+	if (usbvision_device_data[usbvision->DevModel].X_Offset >= 0) {
+		value[4]=usbvision_device_data[usbvision->DevModel].X_Offset & 0xff;
+		value[5]=(usbvision_device_data[usbvision->DevModel].X_Offset & 0x0300) >> 8;
+	}
+
+	if (usbvision_device_data[usbvision->DevModel].Y_Offset >= 0) {
+		value[6]=usbvision_device_data[usbvision->DevModel].Y_Offset & 0xff;
+		value[7]=(usbvision_device_data[usbvision->DevModel].Y_Offset & 0x0300) >> 8;
+	}
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,	/* USBVISION specific code */
+			     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_LXSIZE_I, value, 8, HZ);
+	if (rc < 0) {
+		printk(KERN_ERR "%sERROR=%d. USBVISION stopped - "
+		       "reconnect or reload driver.\n", proc, rc);
+		return rc;
+	}
+
+
+	dvi_yuv_value = 0x00;	/* U comes after V, Ya comes after U/V, Yb comes after Yb */
+
+	if(usbvision_device_data[usbvision->DevModel].Dvi_yuv >= 0){
+		dvi_yuv_value = usbvision_device_data[usbvision->DevModel].Dvi_yuv & 0xff;
+	}
+	else if(usbvision_device_data[usbvision->DevModel].Codec == CODEC_SAA7113) {
+        /* This changes as the fine sync control changes. Further investigation necessary */
+		dvi_yuv_value = 0x06;
+	}
+
+	return (usbvision_write_reg(usbvision, USBVISION_DVI_YUV, dvi_yuv_value));
+}
+
+
+/*
+ * usbvision_set_dram_settings()
+ *
+ * Set the buffer address needed by the usbvision dram to operate
+ * This values has been taken with usbsnoop.
+ *
+ */
+
+static int usbvision_set_dram_settings(struct usb_usbvision *usbvision)
+{
+	int rc;
+	unsigned char value[8];
+
+	if (usbvision->isocMode == ISOC_MODE_COMPRESS) {
+		value[0] = 0x42;
+		value[1] = 0x71;
+		value[2] = 0xff;
+		value[3] = 0x00;
+		value[4] = 0x98;
+		value[5] = 0xe0;
+		value[6] = 0x71;
+		value[7] = 0xff;
+		// UR:  0x0E200-0x3FFFF = 204288 Words (1 Word = 2 Byte)
+		// FDL: 0x00000-0x0E099 =  57498 Words
+		// VDW: 0x0E3FF-0x3FFFF
+	}
+	else {
+		value[0] = 0x42;
+		value[1] = 0x00;
+		value[2] = 0xff;
+		value[3] = 0x00;
+		value[4] = 0x00;
+		value[5] = 0x00;
+		value[6] = 0x00;
+		value[7] = 0xff;
+	}
+	/* These are the values of the address of the video buffer,
+	 * they have to be loaded into the USBVISION_DRM_PRM1-8
+	 *
+	 * Start address of video output buffer for read: 	drm_prm1-2 -> 0x00000
+	 * End address of video output buffer for read: 	drm_prm1-3 -> 0x1ffff
+	 * Start address of video frame delay buffer: 		drm_prm1-4 -> 0x20000
+	 *    Only used in compressed mode
+	 * End address of video frame delay buffer: 		drm_prm1-5-6 -> 0x3ffff
+	 *    Only used in compressed mode
+	 * Start address of video output buffer for write: 	drm_prm1-7 -> 0x00000
+	 * End address of video output buffer for write: 	drm_prm1-8 -> 0x1ffff
+	 */
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return 0;
+
+	rc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),
+			     USBVISION_OP_CODE,	/* USBVISION specific code */
+			     USB_DIR_OUT | USB_TYPE_VENDOR |
+			     USB_RECIP_ENDPOINT, 0,
+			     (__u16) USBVISION_DRM_PRM1, value, 8, HZ);
+
+	if (rc < 0) {
+		err("%sERROR=%d", __FUNCTION__, rc);
+		return rc;
+	}
+
+	/* Restart the video buffer logic */
+	if ((rc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, USBVISION_RES_UR |
+				   USBVISION_RES_FDL | USBVISION_RES_VDW)) < 0)
+		return rc;
+	rc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, 0x00);
+
+	return rc;
+}
+
+/*
+ * ()
+ *
+ * Power on the device, enables suspend-resume logic
+ * &  reset the isoc End-Point
+ *
+ */
+
+static int usbvision_power_on(struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+
+	PDEBUG(DBG_FUNC, "");
+
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN);
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			 USBVISION_SSPND_EN | USBVISION_RES2);
+#if 0
+	/* Set input format expected from decoder, should this be moved to usbvision_set_input() ?? */
+	if(usbvision_device_data[usbvision->DevModel].Codec == CODEC_SAA7113) {
+		/* SAA7113 uses 8 bit output */
+		usbvision_write_reg(usbvision, USBVISION_VIN_REG1, USBVISION_8_422_SYNC);
+	} else {
+		/* I'm sure only about d2-d0 [010] 16 bit 4:2:2 usin sync pulses
+		 * as that is how saa7111 is configured */
+		usbvision_write_reg(usbvision, USBVISION_VIN_REG1, USBVISION_16_422_SYNC);
+		/* | USBVISION_VSNC_POL | USBVISION_VCLK_POL);*/
+	}
+#endif
+	usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			 USBVISION_SSPND_EN | USBVISION_PWR_VID);
+#if 0
+#define ajblah(x) ((flags & (x)) ? #x : "")
+       printk(KERN_DEBUG "usbvision_power_on (%s,%s,%s,%s,%s,%s,%s)\n",
+               ajblah(FLAGS_RETRY_VIDIOCSYNC),
+               ajblah(FLAGS_MONOCHROME),
+               ajblah(FLAGS_DISPLAY_HINTS),
+               ajblah(FLAGS_OSD_STATS),
+               ajblah(FLAGS_FORCE_TESTPATTERN),
+               ajblah(FLAGS_SEPARATE_FRAMES),
+               ajblah(FLAGS_CLEAN_FRAMES));
+#endif
+	errCode = usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+						USBVISION_SSPND_EN | USBVISION_PWR_VID | USBVISION_RES2);
+	if (errCode == 1) {
+		usbvision->power = 1;
+	}
+	PDEBUG(DBG_FUNC, "%s: errCode %d", (errCode<0)?"ERROR":"power is on", errCode);
+	return errCode;
+}
+
+
+static void usbvision_powerOffTimer(unsigned long data)
+{
+	struct usb_usbvision *usbvision = (void *) data;
+
+	PDEBUG(DBG_FUNC, "");
+	del_timer(&usbvision->powerOffTimer);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	INIT_TQUEUE(&usbvision->powerOffTask, call_usbvision_power_off, usbvision);
+	(void) schedule_task(&usbvision->powerOffTask);
+#else
+	INIT_WORK(&usbvision->powerOffWork, call_usbvision_power_off, usbvision);
+	(void) schedule_work(&usbvision->powerOffWork);
+#endif
+	
+}
+
+
+/*
+ * usbvision_begin_streaming()
+ * Sure you have to put bit 7 to 0, if not incoming frames are droped, but no
+ * idea about the rest
+ */
+static int usbvision_begin_streaming(struct usb_usbvision *usbvision)
+{
+	int errCode = 0;
+
+	if (usbvision->isocMode == ISOC_MODE_COMPRESS) {
+		usbvision_init_compression(usbvision);
+	}
+	errCode = usbvision_write_reg(usbvision, USBVISION_VIN_REG2, USBVISION_NOHVALID |
+										usbvision->Vin_Reg2_Preset);
+	return errCode;
+}
+
+/*
+ * usbvision_restart_isoc()
+ * Not sure yet if touching here PWR_REG make loose the config
+ */
+
+static int usbvision_restart_isoc(struct usb_usbvision *usbvision)
+{
+	int ret;
+
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			      USBVISION_SSPND_EN | USBVISION_PWR_VID)) < 0)
+		return ret;
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_PWR_REG,
+			      USBVISION_SSPND_EN | USBVISION_PWR_VID |
+			      USBVISION_RES2)) < 0)
+		return ret;
+	if (
+	    (ret =
+	     usbvision_write_reg(usbvision, USBVISION_VIN_REG2,
+			      USBVISION_KEEP_BLANK | USBVISION_NOHVALID |
+				  usbvision->Vin_Reg2_Preset)) < 0) return ret;
+
+	/* TODO: schedule timeout */
+	while ((usbvision_read_reg(usbvision, USBVISION_STATUS_REG) && 0x01) != 1);
+
+	return 0;
+}
+
+static int usbvision_audio_on(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, usbvision->AudioChannel) < 0) {
+		printk(KERN_ERR "usbvision_audio_on: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_on: channel %d\n", usbvision->AudioChannel));
+	usbvision->AudioMute = 0;
+	return 0;
+}
+
+static int usbvision_audio_mute(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, 0x03) < 0) {
+		printk(KERN_ERR "usbvision_audio_mute: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_mute: audio mute\n"));
+	usbvision->AudioMute = 1;
+	return 0;
+}
+
+static int usbvision_audio_off(struct usb_usbvision *usbvision)
+{
+	if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, USBVISION_AUDIO_MUTE) < 0) {
+		printk(KERN_ERR "usbvision_audio_off: can't wirte reg\n");
+		return -1;
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_audio_off: audio off\n"));
+	usbvision->AudioMute = 0;
+	usbvision->AudioChannel = USBVISION_AUDIO_MUTE;
+	return 0;
+}
+
+static int usbvision_set_audio(struct usb_usbvision *usbvision, int AudioChannel)
+{
+	if (!usbvision->AudioMute) {
+		if (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, AudioChannel) < 0) {
+			printk(KERN_ERR "usbvision_set_audio: can't write iopin register for audio switching\n");
+			return -1;
+		}
+	}
+	DEBUG(printk(KERN_DEBUG "usbvision_set_audio: channel %d\n", AudioChannel));
+	usbvision->AudioChannel = AudioChannel;
+	return 0;
+}
+
+static int usbvision_setup(struct usb_usbvision *usbvision)
+{
+	usbvision_set_video_format(usbvision, isocMode);
+	usbvision_set_dram_settings(usbvision);
+	usbvision_set_compress_params(usbvision);
+	usbvision_set_input(usbvision);
+	usbvision_set_output(usbvision, MAX_USB_WIDTH, MAX_USB_HEIGHT);
+	usbvision_restart_isoc(usbvision);
+	
+	/* cosas del PCM */
+	return USBVISION_IS_OPERATIONAL(usbvision);
+}
+
+
+/*
+ * usbvision_init_isoc()
+ *
+ */
+static int usbvision_init_isoc(struct usb_usbvision *usbvision)
+{
+	struct usb_device *dev = usbvision->dev;
+	int bufIdx, errCode, regValue;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	usbvision->curFrameNum = -1;
+	scratch_reset(usbvision);
+
+	/* Alternate interface 1 is is the biggest frame size */
+	errCode = usb_set_interface(dev, usbvision->iface, usbvision->ifaceAltActive);
+	if (errCode < 0) {
+		usbvision->last_error = errCode;
+		return -EBUSY;
+	}
+
+	regValue = (16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;
+	usbvision->isocPacketSize = (regValue == 0) ? 0 : (regValue * 64) - 1;
+	PDEBUG(DBG_ISOC, "ISO Packet Length:%d", usbvision->isocPacketSize);
+
+	usbvision->usb_bandwidth = regValue >> 1;
+	PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec", usbvision->usb_bandwidth);
+
+
+
+	/* We double buffer the Iso lists */
+
+	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
+		int j, k;
+		struct urb *urb;
+
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			urb = usb_alloc_urb(USBVISION_URB_FRAMES);
+		#else
+			urb = usb_alloc_urb(USBVISION_URB_FRAMES, GFP_KERNEL);
+		#endif
+		if (urb == NULL) {
+			err("%s: usb_alloc_urb() failed", __FUNCTION__);
+			return -ENOMEM;
+		}
+		usbvision->sbuf[bufIdx].urb = urb;
+		urb->dev = dev;
+		urb->context = usbvision;
+		urb->pipe = usb_rcvisocpipe(dev, usbvision->video_endp);
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		urb->transfer_flags = USB_ISO_ASAP;
+	#else
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->interval = 1;
+	#endif
+		urb->transfer_buffer = usbvision->sbuf[bufIdx].data;
+		urb->complete = usbvision_isocIrq;
+		urb->number_of_packets = USBVISION_URB_FRAMES;
+		urb->transfer_buffer_length =
+		    usbvision->isocPacketSize * USBVISION_URB_FRAMES;
+		for (j = k = 0; j < USBVISION_URB_FRAMES; j++,
+		     k += usbvision->isocPacketSize) {
+			urb->iso_frame_desc[j].offset = k;
+			urb->iso_frame_desc[j].length = usbvision->isocPacketSize;
+		}
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	/* Link URBs into a ring so that they invoke each other infinitely */
+	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
+		if ((bufIdx + 1) < USBVISION_NUMSBUF) {
+			usbvision->sbuf[bufIdx].urb->next = usbvision->sbuf[bufIdx + 1].urb;
+		}
+		else {
+			usbvision->sbuf[bufIdx].urb->next = usbvision->sbuf[0].urb;
+		}
+	}
+#endif
+
+	/* Submit all URBs */
+	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			errCode = usb_submit_urb(usbvision->sbuf[bufIdx].urb);
+		#else
+			errCode = usb_submit_urb(usbvision->sbuf[bufIdx].urb, GFP_KERNEL);
+		#endif
+		if (errCode) {
+			err("%s: usb_submit_urb(%d) failed: error %d", __FUNCTION__, bufIdx, errCode);
+		}
+	}
+
+	usbvision->streaming = 1;
+	PDEBUG(DBG_ISOC, "%s: streaming=1 usbvision->video_endp=$%02x", __FUNCTION__, usbvision->video_endp);
+	return 0;
+}
+
+/*
+ * usbvision_stop_isoc()
+ *
+ * This procedure stops streaming and deallocates URBs. Then it
+ * activates zero-bandwidth alt. setting of the video interface.
+ *
+ */
+static void usbvision_stop_isoc(struct usb_usbvision *usbvision)
+{
+	int bufIdx, errCode, regValue;
+
+	if (!usbvision->streaming || (usbvision->dev == NULL))
+		return;
+
+	/* Unschedule all of the iso td's */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
+		usb_kill_urb(usbvision->sbuf[bufIdx].urb);
+		usb_free_urb(usbvision->sbuf[bufIdx].urb);
+		usbvision->sbuf[bufIdx].urb = NULL;
+        }
+#else	
+	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
+		 errCode = usb_unlink_urb(usbvision->sbuf[bufIdx].urb);
+		 if (errCode < 0)
+			 err("%s: usb_unlink_urb() failed: error %d", __FUNCTION__, errCode);
+	}
+
+	 /* Delete them all */ 	 
+         for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) 	 
+                 usb_free_urb(usbvision->sbuf[bufIdx].urb); 	 
+#endif
+
+
+	PDEBUG(DBG_ISOC, "%s: streaming=0\n", __FUNCTION__);
+	usbvision->streaming = 0;
+			
+
+	if (!usbvision->remove_pending) {
+
+		/* Set packet size to 0 */
+		errCode = usb_set_interface(usbvision->dev, usbvision->iface,
+				      usbvision->ifaceAltInactive);
+		if (errCode < 0) {
+			err("%s: usb_set_interface() failed: error %d", __FUNCTION__, errCode);
+			usbvision->last_error = errCode;
+		}
+		regValue = (16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;
+		usbvision->isocPacketSize = (regValue == 0) ? 0 : (regValue * 64) - 1;
+		PDEBUG(DBG_ISOC, "ISO Packet Length:%d", usbvision->isocPacketSize);
+
+		usbvision->usb_bandwidth = regValue >> 1;
+		PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec", usbvision->usb_bandwidth);
+	}
+}
+
+/*
+ * usbvision_new_frame()
+ *
+ */
+static int usbvision_new_frame(struct usb_usbvision *usbvision, int framenum)
+{
+	struct usbvision_frame *frame;
+	int n; //byhec  , width, height;
+
+	/* If we're not grabbing a frame right now and the other frame is */
+	/*  ready to be grabbed into, then use it instead */
+	if (usbvision->curFrameNum != -1)
+		return 0;
+
+	n = (framenum - 1 + USBVISION_NUMFRAMES) % USBVISION_NUMFRAMES;
+	if (usbvision->frame[n].grabstate == FrameState_Ready)
+		framenum = n;
+
+	frame = &usbvision->frame[framenum];
+
+	frame->grabstate = FrameState_Grabbing;
+	frame->scanstate = ScanState_Scanning;
+	frame->scanlength = 0;	/* Accumulated in usbvision_parse_data() */
+	usbvision->curFrameNum = framenum;
+
+	/*
+	 * Normally we would want to copy previous frame into the current one
+	 * before we even start filling it with data; this allows us to stop
+	 * filling at any moment; top portion of the frame will be new and
+	 * bottom portion will stay as it was in previous frame. If we don't
+	 * do that then missing chunks of video stream will result in flickering
+	 * portions of old data whatever it was before.
+	 *
+	 * If we choose not to copy previous frame (to, for example, save few
+	 * bus cycles - the frame can be pretty large!) then we have an option
+	 * to clear the frame before using. If we experience losses in this
+	 * mode then missing picture will be black (flickering).
+	 *
+	 * Finally, if user chooses not to clean the current frame before
+	 * filling it with data then the old data will be visible if we fail
+	 * to refill entire frame with new data.
+	 */
+	if (!(flags & FLAGS_SEPARATE_FRAMES)) {
+		/* This copies previous frame into this one to mask losses */
+		memmove(frame->data, usbvision->frame[1 - framenum].data,
+			MAX_FRAME_SIZE);
+	} else {
+		if (flags & FLAGS_CLEAN_FRAMES) {
+			/*This provides a "clean" frame but slows things down */
+			memset(frame->data, 0, MAX_FRAME_SIZE);
+		}
+	}
+	return 0;
+}
+
+static int usbvision_muxsel(struct usb_usbvision *usbvision, int channel, int norm)
+{
+	int mode[4];
+	int audio[]= {1, 0, 0, 0};	
+	//channel 0 is TV with audiochannel 1 (tuner mono)
+	//channel 1 is Composite with audio channel 0 (line in)
+	//channel 2 is S-Video with audio channel 0 (line in)
+	//channel 3 is additional video inputs to the device with audio channel 0 (line in)
+
+	RESTRICT_TO_RANGE(channel, 0, usbvision->video_inputs);
+	/* set the new video norm */
+	if (usbvision->vchan.norm != norm) {
+		int video_command = norm; 					//VIDEO_MODE_AUTO;
+		call_i2c_clients(usbvision, DECODER_SET_NORM, &video_command);	//set norm in video-codec
+		usbvision->vchan.norm = norm;
+		call_i2c_clients(usbvision, VIDIOCSCHAN, &usbvision->vchan);	//set norm in tuner
+		video_command = 1;
+		call_i2c_clients(usbvision, DECODER_ENABLE_OUTPUT,
+				 &video_command);
+	}
+
+	// set the new channel
+	// Regular USB TV Tuners -> channel: 0 = Television, 1 = Composite, 2 = S-Video
+	// Four video input devices -> channel: 0 = Chan White, 1 = Chan Green, 2 = Chan Yellow, 3 = Chan Red 
+
+	switch (usbvision_device_data[usbvision->DevModel].Codec) {
+		case CODEC_SAA7113:
+			if (SwitchSVideoInput) { // To handle problems with S-Video Input for some devices.  Use SwitchSVideoInput parameter when loading the module.
+				mode[2] = 1;
+			}
+			else {
+				mode[2] = 7;
+			}
+			if (usbvision_device_data[usbvision->DevModel].VideoChannels == 4) { 
+				mode[0] = 0; mode[1] = 2; mode[3] = 3;  // Special for four input devices
+			}
+			else {  
+				mode[0] = 0; mode[1] = 2; //modes for regular saa7113 devices
+			}
+			break;
+		case CODEC_SAA7111:
+			mode[0] = 0; mode[1] = 1; mode[2] = 7; //modes for saa7111
+			break;
+		case CODEC_BT819:
+			// FIXME: missing modes for bt819! Using the the saa7111 modes as default.
+			mode[0] = 0; mode[1] = 1; mode[2] = 7; //modes for bt819
+			break;
+		default:
+			mode[0] = 0; mode[1] = 1; mode[2] = 7; //default modes
+	}
+	call_i2c_clients(usbvision, DECODER_SET_INPUT, &mode[channel]);
+	usbvision->channel = channel;
+	usbvision_set_audio(usbvision, audio[channel]);
+	return 0;
+}
+
+
+/*
+ * usbvision_open()
+ *
+ * This is part of Video 4 Linux API. The driver can be opened by one
+ * client only (checks internal counter 'usbvision->user'). The procedure
+ * then allocates buffers needed for video processing.
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static int usbvision_v4l_open(struct video_device *dev, int flags)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+#else
+static int usbvision_v4l_open(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+#endif
+	const int sb_size = USBVISION_URB_FRAMES * USBVISION_MAX_ISOC_PACKET_SIZE;
+	int i, errCode = 0;
+
+	PDEBUG(DBG_IO, "open");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#endif
+
+	if (timer_pending(&usbvision->powerOffTimer)) {
+		del_timer(&usbvision->powerOffTimer);
+	}
+
+	if (usbvision->user)
+		errCode = -EBUSY;
+	else {
+		/* Clean pointers so we know if we allocated something */
+		for (i = 0; i < USBVISION_NUMSBUF; i++)
+			usbvision->sbuf[i].data = NULL;
+
+		/* Allocate memory for the frame buffers */
+		usbvision->max_frame_size = MAX_FRAME_SIZE;
+		usbvision->fbuf_size = USBVISION_NUMFRAMES * usbvision->max_frame_size;
+		usbvision->fbuf = usbvision_rvmalloc(usbvision->fbuf_size);
+		usbvision->scratch = vmalloc(scratch_buf_size);
+		scratch_reset(usbvision);
+		if ((usbvision->fbuf == NULL) || (usbvision->scratch == NULL)) {
+			err("%s: unable to allocate %d bytes for fbuf and %d bytes for scratch",
+					__FUNCTION__, usbvision->fbuf_size, scratch_buf_size);
+			errCode = -ENOMEM;
+		}
+		else {
+			/* Allocate all buffers */
+			for (i = 0; i < USBVISION_NUMFRAMES; i++) {
+				usbvision->frame[i].grabstate = FrameState_Unused;
+				usbvision->frame[i].data = usbvision->fbuf +
+				    i * MAX_FRAME_SIZE;
+				/*
+				 * Set default sizes in case IOCTL
+				 * (VIDIOCMCAPTURE)
+				 * is not used (using read() instead).
+				 */
+				usbvision->stretch_width = 1;
+				usbvision->stretch_height = 1;
+				usbvision->frame[i].width = usbvision->curwidth;
+				usbvision->frame[i].height = usbvision->curheight;
+				usbvision->frame[i].bytes_read = 0;
+			}
+			if (dga) { //set default for DGA
+				usbvision->overlay_frame.grabstate = FrameState_Unused;
+				usbvision->overlay_frame.scanstate = ScanState_Scanning;
+				usbvision->overlay_frame.data = NULL;
+				usbvision->overlay_frame.width = usbvision->curwidth;
+				usbvision->overlay_frame.height = usbvision->curheight;
+				usbvision->overlay_frame.bytes_read = 0;
+			}
+
+			for (i = 0; i < USBVISION_NUMSBUF; i++) {
+				usbvision->sbuf[i].data =
+				    kmalloc(sb_size, GFP_KERNEL);
+				if (usbvision->sbuf[i].data == NULL) {
+					err("%s: unable to allocate %d bytes for sbuf", __FUNCTION__, sb_size);
+					errCode = -ENOMEM;
+					break;
+				}
+			}
+		}
+		if ((!errCode) && (usbvision->isocMode==ISOC_MODE_COMPRESS)) {
+			int IFB_size = MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT * 3 / 2;
+			usbvision->IntraFrameBuffer = vmalloc(IFB_size);
+			if (usbvision->IntraFrameBuffer == NULL) {
+				err("%s: unable to allocate %d for compr. frame buffer", __FUNCTION__, IFB_size);
+				errCode = -ENOMEM;
+			}
+			else {
+				memset(usbvision->IntraFrameBuffer, 128, IFB_size);
+			}
+		}
+		if (errCode) {
+			/* Have to free all that memory */
+			if (usbvision->fbuf != NULL) {
+				usbvision_rvfree(usbvision->fbuf, usbvision->fbuf_size);
+				usbvision->fbuf = NULL;
+			}
+			if (usbvision->scratch != NULL) {
+				vfree(usbvision->scratch);
+				usbvision->scratch = NULL;
+			}
+			for (i = 0; i < USBVISION_NUMSBUF; i++) {
+				if (usbvision->sbuf[i].data != NULL) {
+					kfree(usbvision->sbuf[i].data);
+					usbvision->sbuf[i].data = NULL;
+				}
+			}
+			if (usbvision->IntraFrameBuffer != NULL) {
+				vfree(usbvision->IntraFrameBuffer);
+				usbvision->IntraFrameBuffer = NULL;
+			}
+		}
+	}
+
+	/* If so far no errors then we shall start the camera */
+	if (!errCode) {
+		down(&usbvision->lock);
+		if (usbvision->power == 0) {
+			usbvision_power_on(usbvision);
+			usbvision_init_i2c(usbvision);
+		}
+
+		/* Send init sequence only once, it's large! */
+		if (!usbvision->initialized) {
+			int setup_ok = 0;
+			setup_ok = usbvision_setup(usbvision);
+			if (setup_ok)
+				usbvision->initialized = 1;
+			else
+				errCode = -EBUSY;
+		}
+
+		if (!errCode) {
+			usbvision_begin_streaming(usbvision);
+			errCode = usbvision_init_isoc(usbvision);
+			usbvision->user++;
+		}
+		else {
+			if (PowerOnAtOpen) {
+				i2c_usb_del_bus(&usbvision->i2c_adap);
+				usbvision_power_off(usbvision);
+				usbvision->initialized = 0;
+			}
+		}
+		up(&usbvision->lock);
+	}
+
+	if (errCode) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		MOD_DEC_USE_COUNT;
+#endif
+	}
+
+	PDEBUG(DBG_IO, "success");
+	return errCode;
+}
+
+/*
+ * usbvision_v4l_close()
+ *
+ * This is part of Video 4 Linux API. The procedure
+ * stops streaming and deallocates all buffers that were earlier
+ * allocated in usbvision_v4l_open().
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static void usbvision_v4l_close(struct video_device *dev)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+#else
+static int usbvision_v4l_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+#endif
+	int i;
+
+	PDEBUG(DBG_IO, "close");
+	down(&usbvision->lock);
+
+	usbvision_audio_off(usbvision);
+	usbvision_restart_isoc(usbvision);
+	usbvision_stop_isoc(usbvision);
+
+	if (usbvision->IntraFrameBuffer != NULL) {
+		vfree(usbvision->IntraFrameBuffer);
+		usbvision->IntraFrameBuffer = NULL;
+	}
+
+	usbvision_rvfree(usbvision->fbuf, usbvision->fbuf_size);
+	vfree(usbvision->scratch);
+	for (i = 0; i < USBVISION_NUMSBUF; i++)
+		kfree(usbvision->sbuf[i].data);
+
+	usbvision->user--;
+
+	if (PowerOnAtOpen) {
+		mod_timer(&usbvision->powerOffTimer, jiffies + USBVISION_POWEROFF_TIME);
+		usbvision->initialized = 0;
+	}
+
+	up(&usbvision->lock);
+
+	if (usbvision->remove_pending) {
+		info("%s: Final disconnect", __FUNCTION__);
+		usbvision_release(usbvision);
+	}
+
+	PDEBUG(DBG_IO, "success");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,19)
+	return 0;
+#endif
+}
+
+
+/*
+ * usbvision_ioctl()
+ *
+ * This is part of Video 4 Linux API. The procedure handles ioctl() calls.
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static int usbvision_v4l_do_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+#else
+static int usbvision_v4l_do_ioctl(struct inode *inode, struct file *file,
+				 unsigned int cmd, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+#endif
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	switch (cmd) {
+		case UVIOCSREG:
+		{
+			struct usbvision_reg *usbvision_reg = arg;
+			int errCode;
+
+			errCode = usbvision_write_reg(usbvision, usbvision_reg->addr, usbvision_reg->value);
+
+			if (errCode < 0) {
+				err("%s: UVIOCSREG failed: error %d", __FUNCTION__, errCode);
+			}
+			else {
+				PDEBUG(DBG_IOCTL, "UVIOCSREG addr=0x%02X, value=0x%02X",
+							usbvision_reg->addr, usbvision_reg->value);
+				errCode = 0;
+			}
+			return errCode;
+		}
+		case UVIOCGREG:
+		{
+			struct usbvision_reg *usbvision_reg = arg;
+			int errCode;
+
+			errCode = usbvision_read_reg(usbvision, usbvision_reg->addr);
+
+			if (errCode < 0) {
+				err("%s: UVIOCGREG failed: error %d", __FUNCTION__, errCode);
+			}
+			else {
+				usbvision_reg->value=(unsigned char)errCode;
+				PDEBUG(DBG_IOCTL, "UVIOCGREG addr=0x%02X, value=0x%02X",
+							usbvision_reg->addr, usbvision_reg->value);
+				errCode = 0; // No error
+			}
+			return errCode;
+		}
+		case VIDIOCGCAP:
+		{
+			struct video_capability *vc = arg;
+			*vc = usbvision->vcap;
+			PDEBUG(DBG_IOCTL, "VIDIOCGCAP");
+			return 0;
+		}
+		case VIDIOCGCHAN:
+		{
+			int chan;
+			struct video_channel *vc = arg;
+
+			vc->flags = usbvision->vchan.flags;
+			vc->tuners = usbvision->vchan.tuners;
+			vc->type = usbvision->vchan.type;
+			vc->norm = usbvision->vchan.norm;
+			if ((vc->channel >= usbvision->video_inputs) || (vc->channel < 0) )
+				return -EINVAL;
+			if (usbvision->have_tuner) {
+				chan = vc->channel;
+			}
+			else {
+				chan = vc->channel + 1; //skip Television string
+			}
+			switch(chan) {
+				case 0:
+					if (usbvision_device_data[usbvision->DevModel].VideoChannels == 4) {
+						strcpy(vc->name, "White Video Input");
+					} 
+					else {	
+						strcpy(vc->name, "Television");
+						vc->flags |= VIDEO_VC_TUNER;
+						vc->type = VIDEO_TYPE_TV;
+						vc->tuners = usbvision->have_tuner;
+					}
+					break;
+				case 1:
+					if (usbvision_device_data[usbvision->DevModel].VideoChannels == 4) {
+						strcpy(vc->name, "Green Video Input");
+					} 
+					else {	
+						strcpy(vc->name, "Composite Video Input");
+					}
+					break;
+				case 2:
+					if (usbvision_device_data[usbvision->DevModel].VideoChannels == 4) {
+						strcpy(vc->name, "Yellow Video Input");
+					} 
+					else {	
+					strcpy(vc->name, "S-Video Input");
+					}
+					break;
+				case 3:
+					strcpy(vc->name, "Red Video Input");
+					break; 
+			}
+			PDEBUG(DBG_IOCTL, "VIDIOCGCHAN name=%s:%d tuners=%d type=%d norm=%d", vc->name, vc->channel, vc->tuners,vc->type,vc->norm);
+			return 0;
+		}
+		case VIDIOCSCHAN:
+		{
+			struct video_channel *vc = arg;
+
+			PDEBUG(DBG_IOCTL, "VIDIOCSCHAN channel=%d norm=%d", vc->channel,vc->norm);
+
+			if ( (vc->channel > usbvision->video_inputs) || vc->channel < 0  )
+				return -EINVAL;
+
+			usbvision->vchan.channel = vc->channel;
+			down(&usbvision->lock);
+			usbvision_muxsel(usbvision, vc->channel, vc->norm);
+			usbvision_set_input(usbvision);
+			usbvision_set_output(usbvision, usbvision->curwidth, usbvision->curheight);
+			up(&usbvision->lock);
+			return 0;
+		}
+		case VIDIOCGTUNER:
+		{
+			struct video_tuner *vt = arg;
+			int status = 0;
+
+			if (!usbvision->have_tuner || vt->tuner)	// Only tuner 0
+				return -EINVAL;
+
+			strcpy(vt->name, "Television");
+			vt->rangelow = 0;
+			vt->rangehigh = ~0;
+			vt->flags = VIDEO_TUNER_PAL | VIDEO_TUNER_NTSC | VIDEO_TUNER_SECAM;
+			vt->mode = usbvision->vchan.norm;
+						
+			call_i2c_clients(usbvision,DECODER_GET_STATUS,&status);
+			vt->signal = ((status & DECODER_STATUS_GOOD ) != 0) ;
+						
+			PDEBUG(DBG_IOCTL, "VIDIOCGTUNER");
+			return 0;
+		}
+		case VIDIOCSTUNER:
+		{
+			struct video_tuner *vt = arg;
+
+			// Only no or one tuner for now
+			if (!usbvision->have_tuner || vt->tuner)
+				return -EINVAL;
+
+			// and it only has certain valid modes
+			if (vt->mode != VIDEO_MODE_PAL && vt->mode != VIDEO_MODE_NTSC &&
+			    vt->mode != VIDEO_MODE_SECAM)
+				return -EOPNOTSUPP;
+
+			PDEBUG(DBG_IOCTL, "VIDIOCSTUNER tuner=%d, mode=%d", vt->tuner, vt->mode);
+			return usbvision_muxsel(usbvision, vt->tuner, vt->mode);
+		}
+		case VIDIOCGFREQ:
+		{
+			unsigned long *freq = arg;
+			*freq = usbvision->freq;
+			PDEBUG(DBG_IOCTL, "VIDIOCGFREQ freq=0x%lX", *freq);
+			return 0;
+		}
+		case VIDIOCSFREQ:
+		{
+			unsigned long *freq = arg;
+			usbvision->freq = *freq;
+			call_i2c_clients(usbvision, cmd, freq);
+			PDEBUG(DBG_IOCTL, "VIDIOCSFREQ freq=0x%lX", *freq);
+			return 0;
+		}
+		case VIDIOCGAUDIO:
+		{
+			struct video_audio *v = arg;
+			memset(v,0, sizeof(v));
+			v->flags|=VIDEO_AUDIO_MUTABLE;
+			v->mode=VIDEO_SOUND_MONO;
+			v->volume=1;
+			v->step=1;
+			strcpy(v->name, "TV");
+			PDEBUG(DBG_IOCTL, "VIDIOCGAUDIO");
+			return 0;
+		}
+		case VIDIOCSAUDIO:
+		{
+			struct video_audio *v = arg;
+			if(v->audio) {
+				return -EINVAL;
+			}
+			PDEBUG(DBG_IOCTL, "VIDIOCSAUDIO(flags:0x%x)", v->flags);
+			if(v->flags & VIDEO_AUDIO_MUTE) {
+				if (usbvision_audio_mute(usbvision)) {
+					return -EFAULT;
+				}
+			}
+			else
+				if (usbvision_audio_on(usbvision)) {
+					return -EFAULT;
+				}
+			return 0;
+		}
+		case VIDIOCGPICT:
+		{
+			struct video_picture *vp = arg;
+			*vp = usbvision->vpic;
+			PDEBUG(DBG_IOCTL, "VIDIOCGPICT depth=%d, palette=%d",
+						vp->depth, vp->palette);
+			return 0;
+		}
+		case VIDIOCSPICT:
+		{
+			struct video_picture *vp = arg;
+			PDEBUG(DBG_IOCTL, "VIDIOCSPICT depth=%d, palette=%d",
+						vp->depth, vp->palette);
+			
+			if ( vp->palette >= USBVISION_SUPPORTED_PALETTES || 
+			     (usbvision_v4l_format[vp->palette].supported == 0)) 
+				return -EINVAL ;
+			
+			call_i2c_clients(usbvision, DECODER_SET_PICTURE, vp);
+			return 0;
+		}
+		case VIDIOCGMBUF:
+		{
+			struct video_mbuf *vm = arg;
+
+			memset(vm, 0, sizeof(struct video_mbuf));
+			vm->size = MAX_FRAME_SIZE * 2;
+			vm->frames = 2;
+			vm->offsets[0] = 0;
+			vm->offsets[1] = MAX_FRAME_SIZE;
+			PDEBUG(DBG_IOCTL, "VIDIOCGMBUF size=%d, off[0]=%d, off[1]=%d",
+						vm->size, vm->offsets[0], vm->offsets[1]);
+			return 0;
+		}
+		case VIDIOCMCAPTURE:
+		{
+			struct video_mmap *vm = arg;
+			struct usbvision_frame *frame;
+
+			PDEBUG(DBG_IOCTL, "VIDIOCMCAPTURE frame=%d, size=%dx%d, format=%d",
+			       vm->frame, vm->width, vm->height, vm->format);
+
+			if ((vm->format >= USBVISION_SUPPORTED_PALETTES) ||
+		    	(usbvision_v4l_format[vm->format].supported == 0)) {
+		    	err("%s: VIDIOCMCAPTURE format %d not supported", __FUNCTION__, vm->format);
+				return -EINVAL;
+			}
+
+			if (vm->frame >= USBVISION_NUMFRAMES) {
+		    	err("%s: VIDIOCMCAPTURE frame %d not supported", __FUNCTION__, vm->frame);
+				return -EINVAL;
+			}
+			frame = &usbvision->frame[vm->frame];
+
+			if (frame->grabstate == FrameState_Grabbing) {
+				return -EBUSY;
+			}
+
+			usbvision_set_output(usbvision, vm->width, vm->height);
+
+			frame->width = vm->width;
+			frame->height = vm->height;
+			frame->v4l_format = vm->format;
+			/* Mark it as ready */
+			frame->grabstate = FrameState_Ready;
+
+			return usbvision_new_frame(usbvision, vm->frame);
+		}
+		case VIDIOCSYNC:
+		{
+			int *frame = arg;
+			int errCode = 0;
+
+			DECLARE_WAITQUEUE(wait, current);
+
+			PDEBUG(DBG_IOCTL, "VIDIOCSYNC frame=%d, grabstate=%d",
+				       *frame, usbvision->frame[*frame].grabstate);
+
+			switch (usbvision->frame[*frame].grabstate) {
+				case FrameState_Unused:
+					errCode = -EINVAL;
+					break;
+				case FrameState_Grabbing:
+					add_wait_queue(&usbvision->frame[*frame].wq, &wait);
+					current->state = TASK_INTERRUPTIBLE;
+					while (usbvision->frame[*frame].grabstate == FrameState_Grabbing) {
+						schedule();
+						if (signal_pending(current)) {
+							remove_wait_queue(&usbvision->frame[*frame].wq, &wait);
+							current->state = TASK_RUNNING;
+							return -EINTR;
+						}
+					}
+					remove_wait_queue(&usbvision->frame [*frame].wq, &wait);
+					current->state = TASK_RUNNING;
+				case FrameState_Ready:
+				case FrameState_Error:
+				case FrameState_Done:
+					errCode = (usbvision->frame[*frame].grabstate == FrameState_Error) ? -EIO : 0;
+					usbvision->frame[*frame].grabstate = FrameState_Unused;
+					break;
+			}
+
+			usbvision->frame[*frame].grabstate = FrameState_Unused;
+			return errCode;
+		}
+		case VIDIOCGFBUF:
+		{
+			struct video_buffer *vb = arg;
+
+			if (dga) {
+				*vb = usbvision->vid_buf;
+			}
+			else {
+				memset(vb, 0, sizeof(vb)); //dga not supported, not used
+			}
+			PDEBUG(DBG_IOCTL, "VIDIOCGFBUF base=%p, width=%d, height=%d, depth=%d, bpl=%d",
+					vb->base, vb->width, vb->height, vb->depth,vb->bytesperline);
+			return 0;
+		}
+		case VIDIOCSFBUF:
+		{
+			struct video_buffer *vb = arg;
+			int formatIdx;
+
+			if (dga == 0) {
+				return -EINVAL;
+			}
+
+			if(!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_ADMIN)) {
+				return -EPERM;
+			}
+
+			PDEBUG(DBG_IOCTL, "VIDIOCSFBUF base=%p, width=%d, height=%d, depth=%d, bpl=%d",
+					vb->base, vb->width, vb->height, vb->depth,vb->bytesperline);
+
+			for (formatIdx=0; formatIdx <= USBVISION_SUPPORTED_PALETTES; formatIdx++) {
+				if (formatIdx == USBVISION_SUPPORTED_PALETTES) {
+					return -EINVAL; // no matching video_format
+				}
+				if ((vb->depth == usbvision_v4l_format[formatIdx].depth) &&
+				    (usbvision_v4l_format[formatIdx].supported)) {
+					break; //found matching video_format
+				}
+			}
+
+			if (vb->bytesperline<1) {
+				return -EINVAL;
+			}
+			if (usbvision->overlay) {
+				return -EBUSY;
+			}
+			down(&usbvision->lock);
+			if (usbvision->overlay_base) {
+				iounmap(usbvision->overlay_base);
+				usbvision->vid_buf_valid = 0;
+			}
+			usbvision->overlay_base = ioremap((ulong)vb->base, vb->height * vb->bytesperline);
+			if (usbvision->overlay_base) {
+				usbvision->vid_buf_valid = 1;
+			}
+			usbvision->vid_buf = *vb;
+			usbvision->overlay_frame.v4l_format = formatIdx;
+			up(&usbvision->lock);
+			return 0;
+		}
+		case VIDIOCGWIN:
+		{
+			struct video_window *vw = arg;
+
+			if ( (dga == 0) || (usbvision->vpic.palette >= VIDEO_PALETTE_PLANAR) ) { 
+				return -EINVAL;
+			}
+
+			down(&usbvision->lock);
+			*vw = usbvision->vid_win;
+			up(&usbvision->lock);
+
+			PDEBUG(DBG_IOCTL, "VIDIOCGWIN x=%d, y=%d, w=%d, h=%d, chroma=%x, flags=%x, clips=%d",
+					vw->x, vw->y, vw->width, vw->height, vw->chromakey, vw->flags, vw->clipcount);
+			return 0;
+		}
+		case VIDIOCSWIN:
+		{
+			struct video_window *vw = arg;
+			struct video_clip *vc;
+			int on;
+
+			if ( (dga == 0) || (usbvision->vpic.palette >= VIDEO_PALETTE_PLANAR)) { 
+				return -EINVAL;
+			}
+
+			PDEBUG(DBG_IOCTL, "VIDIOCSWIN x=%d, y=%d, w=%d, h=%d, chroma=%x, flags=%x, clips=%d",
+					vw->x, vw->y, vw->width, vw->height, vw->chromakey, vw->flags, vw->clipcount);
+
+			if (vw->flags) {
+				return -EINVAL;
+			}
+
+			if (vw->clipcount>256) {
+				return -EDOM;   /* Too many clips! */
+			}
+			// Do every clips.
+			vc = vmalloc(sizeof(struct video_clip)*(vw->clipcount+4));
+			if (vc == NULL) {
+				return -ENOMEM;
+			}
+			if (vw->clipcount && copy_from_user(vc,vw->clips,sizeof(struct video_clip)*vw->clipcount)) {
+				return -EFAULT;
+			}
+			on = usbvision->overlay;	// Save overlay state
+			if (on) {
+				usbvision_cap(usbvision, 0);
+			}
+			// strange, it seems xawtv sometimes calls us with 0
+			// width and/or height. Ignore these values
+
+			if (vw->x == 0) {
+				vw->x = usbvision->vid_win.x;
+			}
+			if (vw->y == 0) {
+				vw->y = usbvision->vid_win.y;
+			}
+
+			// by now we are committed to the new data...
+			down(&usbvision->lock);
+			RESTRICT_TO_RANGE(vw->width, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);
+			RESTRICT_TO_RANGE(vw->height, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);
+			usbvision->vid_win = *vw;
+			usbvision->overlay_frame.width = vw->width;
+			usbvision->overlay_frame.height = vw->height;
+			usbvision_set_output(usbvision, vw->width, vw->height);
+			up(&usbvision->lock);
+
+			// Impose display clips
+			if (vw->x+vw->width > (unsigned int)usbvision->vid_buf.width) {
+				usbvision_new_clip(vw, vc, usbvision->vid_buf.width-vw->x, 0, vw->width-1, vw->height-1);
+			}
+			if (vw->y+vw->height > (unsigned int)usbvision->vid_buf.height) {
+				usbvision_new_clip(vw, vc, 0, usbvision->vid_buf.height-vw->y, vw->width-1, vw->height-1);
+			}
+
+			// built the requested clipping zones
+			usbvision_built_overlay(usbvision, vw->clipcount, vc);
+			vfree(vc);
+
+			// restore overlay state
+			if (on) {
+				usbvision_cap(usbvision, 1);
+			}
+			usbvision->vid_win_valid = 1;
+			PDEBUG(DBG_IOCTL, "VIDIOCSWIN x=%d, y=%d, w=%d, h=%d, chroma=%x, flags=%x, clips=%d",
+					vw->x, vw->y, vw->width, vw->height, vw->chromakey, vw->flags, vw->clipcount);
+			return 0;
+		}
+		case VIDIOCKEY:
+		{
+			return 0;
+		}
+		case VIDIOCCAPTURE:
+		{
+			int *v = arg;
+
+			if ( (dga == 0) || (usbvision->vpic.palette >= VIDEO_PALETTE_PLANAR) ) { 
+				PDEBUG(DBG_IOCTL, "VIDIOCCAPTURE  DGA disabled");
+				return -EINVAL;
+			}
+
+			if (*v == 0) {
+				usbvision_cap(usbvision, 0);
+			}
+			else {
+				// are VIDIOCSFBUF and VIDIOCSWIN done?
+				if ((usbvision->vid_buf_valid == 0) || (usbvision->vid_win_valid == 0)) {
+					PDEBUG(DBG_IOCTL, "VIDIOCCAPTURE  vid_buf_valid %d; vid_win_valid %d",
+							usbvision->vid_buf_valid, usbvision->vid_win_valid);
+					return -EINVAL;
+				}
+				usbvision_cap(usbvision, 1);
+			}
+			PDEBUG(DBG_IOCTL, "VIDIOCCAPTURE %s", (*v)?"on":"off");
+			return 0;
+		}
+		default:
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static int usbvision_v4l_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+{
+	return video_usercopy(inode, file, cmd, arg, usbvision_v4l_do_ioctl);
+}
+#else
+static int usbvision_v4l_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, usbvision_v4l_do_ioctl);
+}
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static long usbvision_v4l_read(struct video_device *dev, char *buf,
+					unsigned long count, int noblock)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+#else
+static ssize_t usbvision_v4l_read(struct file *file, char *buf,
+		      size_t count, loff_t *ppos)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+	int noblock = file->f_flags & O_NONBLOCK;
+#endif
+
+	int frmx = -1;
+	int rc = 0;
+	struct usbvision_frame *frame;
+
+	PDEBUG(DBG_IO, "%s: %ld bytes, noblock=%d", __FUNCTION__, (unsigned long)count, noblock);
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision) || (buf == NULL))
+		return -EFAULT;
+
+	down(&usbvision->lock);
+	//code for testing compression
+	if (usbvision->isocMode == ISOC_MODE_COMPRESS) {
+		usbvision->frame[0].v4l_format = VIDEO_PALETTE_GREY;
+		usbvision->frame[1].v4l_format = VIDEO_PALETTE_GREY;
+	}
+
+	// See if a frame is completed, then use it.
+	if (usbvision->frame[0].grabstate >= FrameState_Done) // _Done or _Error
+		frmx = 0;
+	else if (usbvision->frame[1].grabstate >= FrameState_Done)// _Done or _Error
+		frmx = 1;
+
+	if (noblock && (frmx == -1)) {
+		count = -EAGAIN;
+		goto usbvision_v4l_read_done;
+	}
+
+	// If no FRAME_DONE, look for a FRAME_GRABBING state.
+	// See if a frame is in process (grabbing), then use it.
+	if (frmx == -1) {
+		if (usbvision->frame[0].grabstate == FrameState_Grabbing)
+			frmx = 0;
+		else if (usbvision->frame[1].grabstate == FrameState_Grabbing)
+			frmx = 1;
+	}
+
+	// If no frame is active, start one.
+	if (frmx == -1)
+		usbvision_new_frame(usbvision, frmx = 0);
+
+	frame = &usbvision->frame[frmx];
+
+      restart:
+	if (!USBVISION_IS_OPERATIONAL(usbvision)) {
+		count = -EIO;
+		goto usbvision_v4l_read_done;
+	}
+	PDEBUG(DBG_IO, "Waiting frame grabbing");
+	rc = wait_event_interruptible(frame->wq, (frame->grabstate == FrameState_Done) || 
+						 (frame->grabstate == FrameState_Error));
+	if (rc) {
+		goto usbvision_v4l_read_done;
+	}
+
+	if (frame->grabstate == FrameState_Error) {
+		frame->bytes_read = 0;
+		if (usbvision_new_frame(usbvision, frmx)) {
+			err("%s: usbvision_new_frame() failed", __FUNCTION__);
+		}
+		goto restart;
+	}
+
+	PDEBUG(DBG_IO, "%s: frmx=%d, bytes_read=%ld, scanlength=%ld", __FUNCTION__,
+		       frmx, frame->bytes_read, frame->scanlength);
+
+	/* copy bytes to user space; we allow for partials reads */
+	if ((count + frame->bytes_read) > (unsigned long)frame->scanlength)
+		count = frame->scanlength - frame->bytes_read;
+
+	if (copy_to_user(buf, frame->data + frame->bytes_read, count)) {
+		count = -EFAULT;
+		goto usbvision_v4l_read_done;
+	}
+
+	frame->bytes_read += count;
+	PDEBUG(DBG_IO, "%s: {copy} count used=%ld, new bytes_read=%ld", __FUNCTION__,
+		       (unsigned long)count, frame->bytes_read);
+
+	if (frame->bytes_read >= frame->scanlength) {// All data has been read
+		frame->bytes_read = 0;
+
+		/* Mark it as available to be used again. */
+		usbvision->frame[frmx].grabstate = FrameState_Unused;
+		if (usbvision_new_frame(usbvision, frmx ? 0 : 1))
+			err("%s: usbvision_new_frame() failed", __FUNCTION__);
+	}
+
+usbvision_v4l_read_done:
+	up(&usbvision->lock);
+	return count;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+int usbvision_v4l_mmap(struct video_device *dev, const char *adr, unsigned long size)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) dev;
+	unsigned long start = (unsigned long) adr;
+
+#else
+static int usbvision_v4l_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end-vma->vm_start;
+#endif
+
+	unsigned long page, pos;
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EFAULT;
+
+	if (size > (((USBVISION_NUMFRAMES * usbvision->max_frame_size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)))
+		return -EINVAL;
+
+	pos = (unsigned long) usbvision->fbuf;
+	while (size > 0) {
+		
+// Really ugly....
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)                                     //Compatibility for 2.4.x kernels
+		page = usbvision_kvirt_to_pa(pos);		
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+			return -EAGAIN;
+		}
+#else
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)	                   //Compatibility for 2.6.10+ kernels
+		page = vmalloc_to_pfn((void *)pos);
+		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) { 
+			return -EAGAIN;
+		}
+	#else                                                                      //Compatibility for 2.6.0 - 2.6.9 kernels
+		page = usbvision_kvirt_to_pa(pos);
+		if (remap_page_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {
+			return -EAGAIN;
+		}
+	#endif
+#endif
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Here comes the stuff for radio on usbvision based devices
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static int usbvision_radio_open(struct video_device *dev, int flags)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+#else
+static int usbvision_radio_open(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+#endif
+	unsigned long freq;
+	int errCode = 0;
+
+	PDEBUG(DBG_RIO, "%s:", __FUNCTION__);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#endif
+	down(&usbvision->lock);
+
+	if (usbvision->user) {
+		err("%s: Someone tried to open an already opened USBVision Radio!", __FUNCTION__);
+		errCode = -EBUSY;
+	}
+	else {
+		if(PowerOnAtOpen) {
+			if (timer_pending(&usbvision->powerOffTimer)) {
+				del_timer(&usbvision->powerOffTimer);
+			}
+			if (usbvision->power == 0) {
+				usbvision_power_on(usbvision);
+				usbvision_init_i2c(usbvision);
+			}
+		}
+
+		// If so far no errors then we shall start the radio
+		usbvision->radio = 1;
+		call_i2c_clients(usbvision,AUDC_SET_RADIO,&usbvision->tuner_type);
+		freq = 1517; //SWR3 @ 94.8MHz
+		call_i2c_clients(usbvision, VIDIOCSFREQ, &freq);
+		usbvision_set_audio(usbvision, USBVISION_AUDIO_RADIO);
+		usbvision->user++;
+	}
+
+	if (errCode) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		MOD_DEC_USE_COUNT;
+#endif
+		if (PowerOnAtOpen) {
+			i2c_usb_del_bus(&usbvision->i2c_adap);
+			usbvision_power_off(usbvision);
+			usbvision->initialized = 0;
+		}
+	}
+	up(&usbvision->lock);
+	return errCode;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static void usbvision_radio_close(struct video_device *dev)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+#else
+static int usbvision_radio_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+	int errCode = 0;
+#endif
+
+	PDEBUG(DBG_RIO, "");
+
+	down(&usbvision->lock);
+
+	usbvision_audio_off(usbvision);
+	usbvision->radio=0;
+	usbvision->user--;
+
+	if (PowerOnAtOpen) {
+		mod_timer(&usbvision->powerOffTimer, jiffies + USBVISION_POWEROFF_TIME);
+		usbvision->initialized = 0;
+	}
+
+	up(&usbvision->lock);
+
+	if (usbvision->remove_pending) {
+		info("%s: Final disconnect", __FUNCTION__);
+		usbvision_release(usbvision);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+
+	PDEBUG(DBG_RIO, "success");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,19)
+	return errCode;
+#endif
+}
+
+static int usbvision_do_radio_ioctl(struct inode *inode, struct file *file,
+				 unsigned int cmd, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EIO;
+
+	switch (cmd) {
+		case VIDIOCGCAP:
+		{
+			struct video_capability *vc = arg;
+
+			memset(vc, 0, sizeof(struct video_capability));
+			strcpy(vc->name,usbvision->vcap.name);
+			vc->type = VID_TYPE_TUNER;
+			vc->channels = 1;
+			vc->audios = 1;
+			PDEBUG(DBG_RIO, "%s: VIDIOCGCAP", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCGTUNER:
+		{
+			struct video_tuner *vt = arg;
+
+			if((vt->tuner) || (usbvision->channel)) {	/* Only tuner 0 */
+				return -EINVAL;
+			}
+			strcpy(vt->name, "Radio");
+			// japan:          76.0 MHz -  89.9 MHz
+			// western europe: 87.5 MHz - 108.0 MHz
+			// russia:         65.0 MHz - 108.0 MHz
+			vt->rangelow=(int)(65*16);
+			vt->rangehigh=(int)(108*16);
+			vt->flags= 0;
+			vt->mode = 0;
+			call_i2c_clients(usbvision,cmd,vt);
+			PDEBUG(DBG_RIO, "%s: VIDIOCGTUNER signal=%d", __FUNCTION__, vt->signal);
+			return 0;
+		}
+		case VIDIOCSTUNER:
+		{
+			struct video_tuner *vt = arg;
+
+			// Only channel 0 has a tuner
+			if((vt->tuner) || (usbvision->channel)) {
+				return -EINVAL;
+			}
+			PDEBUG(DBG_RIO, "%s: VIDIOCSTUNER", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCGAUDIO:
+		{
+			struct video_audio *va = arg;
+			memset(va,0, sizeof(struct video_audio));
+			call_i2c_clients(usbvision, cmd, va);
+			va->flags|=VIDEO_AUDIO_MUTABLE;
+			va->volume=1;
+			va->step=1;
+			strcpy(va->name, "Radio");
+			PDEBUG(DBG_RIO, "%s: VIDIOCGAUDIO", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCSAUDIO:
+		{
+			struct video_audio *va = arg;
+			if(va->audio) {
+				return -EINVAL;
+			}
+
+			if(va->flags & VIDEO_AUDIO_MUTE) {
+				if (usbvision_audio_mute(usbvision)) {
+					return -EFAULT;
+				}
+			}
+			else {
+				if (usbvision_audio_on(usbvision)) {
+					return -EFAULT;
+				}
+			}
+			PDEBUG(DBG_RIO, "%s: VIDIOCSAUDIO flags=0x%x)", __FUNCTION__, va->flags);
+			return 0;
+		}
+		case VIDIOCGFREQ:
+		{
+			unsigned long *freq = arg;
+
+			*freq = usbvision->freq;
+			PDEBUG(DBG_RIO, "%s: VIDIOCGFREQ freq = %ld00 kHz", __FUNCTION__, (*freq * 10)>>4);
+			return 0;
+		}
+		case VIDIOCSFREQ:
+		{
+			unsigned long *freq = arg;
+
+			usbvision->freq = *freq;
+			call_i2c_clients(usbvision, cmd, freq);
+			PDEBUG(DBG_RIO, "%s: VIDIOCSFREQ freq = %ld00 kHz", __FUNCTION__, (*freq * 10)>>4);
+			return 0;
+		}
+		default:
+		{
+			PDEBUG(DBG_RIO, "%s: Unknown command %d", __FUNCTION__, cmd);
+			return -ENOIOCTLCMD;
+		}
+	}
+	return 0;
+}
+
+
+static int usbvision_radio_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, usbvision_do_radio_ioctl);
+}
+
+
+/*
+ * Here comes the stuff for vbi on usbvision based devices
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static int usbvision_vbi_open(struct video_device *dev, int flags)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+#else
+static int usbvision_vbi_open(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+#endif
+	unsigned long freq;
+	int errCode = 0;
+
+	PDEBUG(DBG_RIO, "%s:", __FUNCTION__);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#endif
+	down(&usbvision->lock);
+
+	if (usbvision->user) {
+		err("%s: Someone tried to open an already opened USBVision VBI!", __FUNCTION__);
+		errCode = -EBUSY;
+	}
+	else {
+		if(PowerOnAtOpen) {
+			if (timer_pending(&usbvision->powerOffTimer)) {
+				del_timer(&usbvision->powerOffTimer);
+			}
+			if (usbvision->power == 0) {
+				usbvision_power_on(usbvision);
+				usbvision_init_i2c(usbvision);
+			}
+		}
+
+		// If so far no errors then we shall start the vbi device
+		//usbvision->vbi = 1;
+		call_i2c_clients(usbvision,AUDC_SET_RADIO,&usbvision->tuner_type);
+		freq = 1517; //SWR3 @ 94.8MHz
+		call_i2c_clients(usbvision, VIDIOCSFREQ, &freq);
+		usbvision_set_audio(usbvision, USBVISION_AUDIO_RADIO);
+		usbvision->user++;
+	}
+
+	if (errCode) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		MOD_DEC_USE_COUNT;
+#endif
+		if (PowerOnAtOpen) {
+			i2c_usb_del_bus(&usbvision->i2c_adap);
+			usbvision_power_off(usbvision);
+			usbvision->initialized = 0;
+		}
+	}
+	up(&usbvision->lock);
+	return errCode;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static void usbvision_vbi_close(struct video_device *dev)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *)dev->priv;
+#else
+static int usbvision_vbi_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+	int errCode = 0;
+#endif
+
+	PDEBUG(DBG_RIO, "");
+
+	down(&usbvision->lock);
+
+	usbvision_audio_off(usbvision);
+	usbvision->vbi=0;
+	usbvision->user--;
+
+	if (PowerOnAtOpen) {
+		mod_timer(&usbvision->powerOffTimer, jiffies + USBVISION_POWEROFF_TIME);
+		usbvision->initialized = 0;
+	}
+
+	up(&usbvision->lock);
+
+	if (usbvision->remove_pending) {
+		info("%s: Final disconnect", __FUNCTION__);
+		usbvision_release(usbvision);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+
+	PDEBUG(DBG_RIO, "success");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,19)
+	return errCode;
+#endif
+}
+
+static int usbvision_do_vbi_ioctl(struct inode *inode, struct file *file,
+				 unsigned int cmd, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) video_get_drvdata(dev);
+
+	if (!USBVISION_IS_OPERATIONAL(usbvision))
+		return -EIO;
+
+	switch (cmd) {
+		case VIDIOCGCAP:
+		{
+			struct video_capability *vc = arg;
+
+			memset(vc, 0, sizeof(struct video_capability));
+			strcpy(vc->name,usbvision->vcap.name);
+			vc->type = VID_TYPE_TUNER;
+			vc->channels = 1;
+			vc->audios = 1;
+			PDEBUG(DBG_RIO, "%s: VIDIOCGCAP", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCGTUNER:
+		{
+			struct video_tuner *vt = arg;
+
+			if((vt->tuner) || (usbvision->channel)) {	/* Only tuner 0 */
+				return -EINVAL;
+			}
+			strcpy(vt->name, "vbi");
+			// japan:          76.0 MHz -  89.9 MHz
+			// western europe: 87.5 MHz - 108.0 MHz
+			// russia:         65.0 MHz - 108.0 MHz
+			vt->rangelow=(int)(65*16);
+			vt->rangehigh=(int)(108*16);
+			vt->flags= 0;
+			vt->mode = 0;
+			call_i2c_clients(usbvision,cmd,vt);
+			PDEBUG(DBG_RIO, "%s: VIDIOCGTUNER signal=%d", __FUNCTION__, vt->signal);
+			return 0;
+		}
+		case VIDIOCSTUNER:
+		{
+			struct video_tuner *vt = arg;
+
+			// Only channel 0 has a tuner
+			if((vt->tuner) || (usbvision->channel)) {
+				return -EINVAL;
+			}
+			PDEBUG(DBG_RIO, "%s: VIDIOCSTUNER", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCGAUDIO:
+		{
+			struct video_audio *va = arg;
+			memset(va,0, sizeof(struct video_audio));
+			call_i2c_clients(usbvision, cmd, va);
+			va->flags|=VIDEO_AUDIO_MUTABLE;
+			va->volume=1;
+			va->step=1;
+			strcpy(va->name, "vbi");
+			PDEBUG(DBG_RIO, "%s: VIDIOCGAUDIO", __FUNCTION__);
+			return 0;
+		}
+		case VIDIOCSAUDIO:
+		{
+			struct video_audio *va = arg;
+			if(va->audio) {
+				return -EINVAL;
+			}
+
+			if(va->flags & VIDEO_AUDIO_MUTE) {
+				if (usbvision_audio_mute(usbvision)) {
+					return -EFAULT;
+				}
+			}
+			else {
+				if (usbvision_audio_on(usbvision)) {
+					return -EFAULT;
+				}
+			}
+			PDEBUG(DBG_RIO, "%s: VIDIOCSAUDIO flags=0x%x)", __FUNCTION__, va->flags);
+			return 0;
+		}
+		case VIDIOCGFREQ:
+		{
+			unsigned long *freq = arg;
+
+			*freq = usbvision->freq;
+			PDEBUG(DBG_RIO, "%s: VIDIOCGFREQ freq = %ld00 kHz", __FUNCTION__, (*freq * 10)>>4);
+			return 0;
+		}
+		case VIDIOCSFREQ:
+		{
+			unsigned long *freq = arg;
+
+			usbvision->freq = *freq;
+			call_i2c_clients(usbvision, cmd, freq);
+			PDEBUG(DBG_RIO, "%s: VIDIOCSFREQ freq = %ld00 kHz", __FUNCTION__, (*freq * 10)>>4);
+			return 0;
+		}
+		default:
+		{
+			PDEBUG(DBG_RIO, "%s: Unknown command %d", __FUNCTION__, cmd);
+			return -ENOIOCTLCMD;
+		}
+	}
+	return 0;
+}
+
+static int usbvision_vbi_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, usbvision_do_vbi_ioctl);
+}
+
+
+
+static void usbvision_configure_video(struct usb_usbvision *usbvision)
+{
+	int model;
+
+	if (usbvision == NULL)
+		return;
+		
+	model = usbvision->DevModel;
+
+	RESTRICT_TO_RANGE(init_brightness, 0, 255);
+	RESTRICT_TO_RANGE(init_contrast, 0, 255);
+	RESTRICT_TO_RANGE(init_color, 0, 255);
+	RESTRICT_TO_RANGE(init_hue, 0, 255);
+	
+	memset(&usbvision->vpic, 0, sizeof(usbvision->vpic));
+
+	usbvision->vpic.colour = init_color << 8;
+	usbvision->vpic.hue = init_hue << 8;
+	usbvision->vpic.brightness = init_brightness << 8;
+	usbvision->vpic.contrast = init_contrast << 8;
+	usbvision->vpic.whiteness = 128 << 8;	/* This one isn't used */
+	usbvision->vpic.depth = 24;
+	usbvision->vpic.palette = VIDEO_PALETTE_RGB24;
+
+	if (usbvision_device_data[usbvision->DevModel].Vin_Reg2 >= 0) {
+		usbvision->Vin_Reg2_Preset = usbvision_device_data[usbvision->DevModel].Vin_Reg2 & 0xff;
+	} else {
+		usbvision->Vin_Reg2_Preset = 0;
+	}
+
+	memset(&usbvision->vcap, 0, sizeof(usbvision->vcap));
+	strcpy(usbvision->vcap.name, "USBVision USB Video");
+	usbvision->vcap.type = VID_TYPE_CAPTURE |
+		(dga ? (VID_TYPE_CLIPPING | VID_TYPE_OVERLAY) : 0) |
+		(usbvision->have_tuner ? VID_TYPE_TUNER : 0);
+
+	usbvision->vcap.channels = usbvision_device_data[model].VideoChannels;
+	usbvision->vcap.audios = usbvision_device_data[model].AudioChannels;
+	usbvision->vcap.maxwidth = max_imgwidth;
+	usbvision->vcap.maxheight = max_imgheight;
+	usbvision->vcap.minwidth = min_imgwidth;
+	usbvision->vcap.minheight = min_imgheight;
+
+	memset(&usbvision->vchan, 0, sizeof(usbvision->vchan));
+	usbvision->vchan.flags = VIDEO_VC_AUDIO;
+	usbvision->vchan.tuners = 0;
+	usbvision->vchan.channel = 0;
+	usbvision->vchan.type = VIDEO_TYPE_CAMERA;
+	usbvision->vchan.norm = usbvision_device_data[model].VideoNorm;
+
+	usbvision->video_inputs = usbvision->vcap.channels;
+
+	/* This should be here to make i2c clients to be able to register */
+	usbvision_audio_off(usbvision);	//first switch off audio
+	if (!PowerOnAtOpen) {
+		usbvision_power_on(usbvision);	//and then power up the noisy tuner
+		usbvision_init_i2c(usbvision);
+	}
+}
+
+//
+// Video registration stuff
+//
+
+// Video template
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static struct video_device usbvision_video_template = {
+	.type		= VID_TYPE_TUNER | VID_TYPE_CAPTURE,
+	.hardware	= VID_HARDWARE_USBVISION,
+	.open		= usbvision_v4l_open,
+	.close		= usbvision_v4l_close,
+	.read		= usbvision_v4l_read,
+	.mmap		= usbvision_v4l_mmap,
+	.ioctl		= usbvision_v4l_ioctl,
+	.minor		= -1,
+};
+#else
+static struct file_operations usbvision_fops = {
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.open		= usbvision_v4l_open,
+	.release	= usbvision_v4l_close,
+	.read		= usbvision_v4l_read,
+	.mmap		= usbvision_v4l_mmap,
+	.ioctl		= usbvision_v4l_ioctl,
+	.llseek		= no_llseek,
+};
+static struct video_device usbvision_video_template = {
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.type		= VID_TYPE_TUNER | VID_TYPE_CAPTURE,
+	.hardware	= VID_HARDWARE_USBVISION,
+	.fops		= &usbvision_fops,
+  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	.release	= video_device_release,
+  #endif
+	.minor		= -1,
+};
+#endif
+
+
+// Radio template
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static struct video_device usbvision_radio_template=
+{
+	type:		VID_TYPE_TUNER,
+	hardware:	VID_HARDWARE_USBVISION,
+	open:		usbvision_radio_open,
+	close:		usbvision_radio_close,
+	read:		usbvision_radio_read,	// just returns -EINVAL
+	write:		usbvision_radio_write,	// just returns -EINVAL
+	ioctl:		usbvision_radio_ioctl,
+	minor:		-1,
+};
+#else
+static struct file_operations usbvision_radio_fops = {
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.open		= usbvision_radio_open,
+	.release	= usbvision_radio_close,
+	.ioctl		= usbvision_radio_ioctl,
+	.llseek		= no_llseek,
+};
+
+static struct video_device usbvision_radio_template=
+{
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.type		= VID_TYPE_TUNER,
+	.hardware	= VID_HARDWARE_USBVISION,
+	.fops		= &usbvision_radio_fops,
+  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	.release	= video_device_release,
+  #endif
+	.minor		= -1,
+};
+#endif
+
+
+// vbi template
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+static struct video_device usbvision_vbi_template=
+{
+	type:		VID_TYPE_TELETEXT,
+	hardware:	VID_HARDWARE_USBVISION,
+	open:		usbvision_vbi_open,
+	close:		usbvision_vbi_close,
+	read:		usbvision_vbi_read,	// just returns -EINVAL
+	write:		usbvision_vbi_write,	// just returns -EINVAL
+	ioctl:		usbvision_vbi_ioctl,
+	minor:		-1,
+};
+#else
+static struct file_operations usbvision_vbi_fops = {
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.open		= usbvision_vbi_open,
+	.release	= usbvision_vbi_close,
+	.ioctl		= usbvision_vbi_ioctl,
+	.llseek		= no_llseek,
+};
+
+static struct video_device usbvision_vbi_template=
+{
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,30)
+	.owner             = THIS_MODULE,
+  #endif
+	.type		= VID_TYPE_TUNER,
+	.hardware	= VID_HARDWARE_USBVISION,
+	.fops		= &usbvision_vbi_fops,
+  #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	.release	= video_device_release,
+  #endif
+	.minor		= -1,
+};
+#endif
+
+
+static struct video_device *usbvision_vdev_init(struct usb_usbvision *usbvision,
+					struct video_device *vdev_template,
+					char *name)
+{
+	struct usb_device *usb_dev = usbvision->dev;
+	struct video_device *vdev;
+
+	if (usb_dev == NULL) {
+		err("%s: usbvision->dev is not set", __FUNCTION__);
+		return NULL;
+	}
+
+	vdev = video_device_alloc();
+	if (NULL == vdev) {
+		return NULL;
+	}
+	*vdev = *vdev_template;
+//	vdev->minor   = -1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	vdev->dev     = &usb_dev->dev;
+#endif
+	snprintf(vdev->name, sizeof(vdev->name), "%s", name);
+	video_set_drvdata(vdev, usbvision);
+	return vdev;
+}
+
+// unregister video4linux devices
+static void usbvision_unregister_video(struct usb_usbvision *usbvision)
+{
+	// vbi Device:
+	if (usbvision->vbi) {
+		PDEBUG(DBG_PROBE, "unregister /dev/vbi%d [v4l]", usbvision->vbi->minor & 0x1f);
+		if (usbvision->vbi->minor != -1) {
+			video_unregister_device(usbvision->vbi);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			video_device_release(usbvision->vbi);
+#endif
+		}
+		else {
+			video_device_release(usbvision->vbi);
+		}
+		usbvision->vbi = NULL;
+	}
+	
+	// Radio Device:
+	if (usbvision->rdev) {
+		PDEBUG(DBG_PROBE, "unregister /dev/radio%d [v4l]", usbvision->rdev->minor & 0x1f);
+		if (usbvision->rdev->minor != -1) {
+			video_unregister_device(usbvision->rdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			video_device_release(usbvision->rdev);
+#endif
+		}
+		else {
+			video_device_release(usbvision->rdev);
+		}
+		usbvision->rdev = NULL;
+	}
+
+	// Video Device:
+	if (usbvision->vdev) {
+		PDEBUG(DBG_PROBE, "unregister /dev/video%d [v4l]", usbvision->vdev->minor & 0x1f);
+		if (usbvision->vdev->minor != -1) {
+			video_unregister_device(usbvision->vdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			video_device_release(usbvision->vdev);
+#endif
+		}
+		else {
+			video_device_release(usbvision->vdev);
+		}
+		usbvision->vdev = NULL;
+	}
+}
+
+// register video4linux devices
+static int __devinit usbvision_register_video(struct usb_usbvision *usbvision)
+{
+	// Video Device:
+	usbvision->vdev = usbvision_vdev_init(usbvision, &usbvision_video_template, "USBVision Video");
+	if (usbvision->vdev == NULL) {
+		goto err_exit;
+	}
+	if (video_register_device(usbvision->vdev, VFL_TYPE_GRABBER, video_nr)<0) {
+		goto err_exit;
+	}
+	info("USBVision[%d]: registered USBVision Video device /dev/video%d [v4l]", usbvision->nr,usbvision->vdev->minor & 0x1f);
+
+	// Radio Device:
+	if (usbvision_device_data[usbvision->DevModel].Radio) {
+		// usbvision has radio
+		usbvision->rdev = usbvision_vdev_init(usbvision, &usbvision_radio_template, "USBVision Radio");
+		if (usbvision->rdev == NULL) {
+			goto err_exit;
+		}
+		if (video_register_device(usbvision->rdev, VFL_TYPE_RADIO, radio_nr)<0) {
+			goto err_exit;
+		}
+		info("USBVision[%d]: registered USBVision Radio device /dev/radio%d [v4l]", usbvision->nr, usbvision->rdev->minor & 0x1f);
+	}
+	// vbi Device: 
+	if (usbvision_device_data[usbvision->DevModel].vbi) {
+		usbvision->vbi = usbvision_vdev_init(usbvision, &usbvision_vbi_template, "USBVision VBI");
+		if (usbvision->vdev == NULL) {
+			goto err_exit;
+		}
+		if (video_register_device(usbvision->vbi, VFL_TYPE_VBI, vbi_nr)<0) {
+			goto err_exit;
+		}
+		info("USBVision[%d]: registered USBVision VBI device /dev/vbi%d [v4l] (Not Working Yet!)", usbvision->nr,usbvision->vbi->minor & 0x1f);
+	}
+	// all done
+	return 0;
+
+ err_exit:
+	err("USBVision[%d]: video_register_device() failed", usbvision->nr);
+	usbvision_unregister_video(usbvision);
+	return -1;
+}
+
+/*
+ * usbvision_alloc()
+ *
+ * This code allocates the struct usb_usbvision. It is filled with default values.
+ *
+ * Returns NULL on error, a pointer to usb_usbvision else.
+ *
+ */
+static struct usb_usbvision *usbvision_alloc(struct usb_device *dev)
+{
+	struct usb_usbvision *usbvision;
+	int FrameIdx;
+
+	if ((usbvision = kmalloc(sizeof(struct usb_usbvision), GFP_KERNEL)) == NULL) {
+		goto err_exit;
+	}
+
+	memset(usbvision, 0, sizeof(struct usb_usbvision));
+
+	usbvision->dev = dev;
+
+	for (FrameIdx = 0; FrameIdx < USBVISION_NUMFRAMES; FrameIdx++) {
+		init_waitqueue_head(&usbvision->frame[FrameIdx].wq);
+	}
+	init_waitqueue_head(&usbvision->overlay_frame.wq);
+	init_MUTEX(&usbvision->lock);	/* to 1 == available */
+
+	// prepare control urb for control messages during interrupts
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	usbvision->ctrlUrb = usb_alloc_urb(USBVISION_URB_FRAMES);
+#else
+	usbvision->ctrlUrb = usb_alloc_urb(USBVISION_URB_FRAMES, GFP_KERNEL);
+#endif
+	if (usbvision->ctrlUrb == NULL) {
+		goto err_exit;
+	}
+	init_waitqueue_head(&usbvision->ctrlUrb_wq);
+	init_MUTEX(&usbvision->ctrlUrbLock);
+
+	init_timer(&usbvision->powerOffTimer);
+	usbvision->powerOffTimer.data = (long) usbvision;
+	usbvision->powerOffTimer.function = usbvision_powerOffTimer;
+
+	return usbvision;
+
+err_exit:
+	if (usbvision && usbvision->ctrlUrb) {
+		usb_free_urb(usbvision->ctrlUrb);
+	}
+	if (usbvision) {
+		kfree(usbvision);
+	}
+	return NULL;
+}
+
+/*
+ * usbvision_release()
+ *
+ * This code does final release of struct usb_usbvision. This happens
+ * after the device is disconnected -and- all clients closed their files.
+ *
+ */
+static void usbvision_release(struct usb_usbvision *usbvision)
+{
+	PDEBUG(DBG_PROBE, "");
+
+	down(&usbvision->lock);
+
+	if (timer_pending(&usbvision->powerOffTimer)) {
+		del_timer(&usbvision->powerOffTimer);
+	}
+
+	usbvision->usbvision_used = 0;
+	usbvision->initialized = 0;
+
+	up(&usbvision->lock);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	usbvision_remove_sysfs(usbvision->vdev);
+#else
+	usbvision_proc_dev_destroy(usbvision);
+#endif
+	usbvision_unregister_video(usbvision);
+	if(dga) {
+		if (usbvision->overlay_base) {
+			iounmap(usbvision->overlay_base);
+		}
+	}
+
+	if (usbvision->ctrlUrb) {
+		usb_free_urb(usbvision->ctrlUrb);
+	}
+
+	kfree(usbvision);
+
+	PDEBUG(DBG_PROBE, "success");
+}
+
+
+/*
+ * usbvision_probe()
+ *
+ * This procedure queries device descriptor and accepts the interface
+ * if it looks like USBVISION video device
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void *usbvision_probe(struct usb_device *dev, unsigned int ifnum,
+				const struct usb_device_id *id)
+{
+	const struct usb_interface_descriptor *interface;
+#else
+static int __devinit usbvision_probe(struct usb_interface *intf, const struct usb_device_id *devid)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	__u8 ifnum = intf->altsetting->desc.bInterfaceNumber;
+	const struct usb_host_interface *interface;
+#endif
+	struct usb_usbvision *usbvision = NULL;
+	const struct usb_endpoint_descriptor *endpoint;
+	int model;
+
+	PDEBUG(DBG_PROBE, "VID=%#04x, PID=%#04x, ifnum=%u",
+					dev->descriptor.idVendor, dev->descriptor.idProduct, ifnum);
+
+	/* Is it an USBVISION video dev? */
+	model = 0;
+	for(model = 0; usbvision_device_data[model].idVendor; model++) {
+		if (dev->descriptor.idVendor  != usbvision_device_data[model].idVendor) {
+			continue;
+		}
+		if (dev->descriptor.idProduct != usbvision_device_data[model].idProduct) {
+			continue;
+		}
+
+		info("%s: %s found", __FUNCTION__, usbvision_device_data[model].ModelString);
+		break;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (usbvision_device_data[model].idVendor == 0) {
+		return NULL; //no matching device
+	}
+	if (usbvision_device_data[model].Interface >= 0) {
+		interface = &dev->actconfig->interface[usbvision_device_data[model].Interface].altsetting[0];
+	}
+	else {
+		interface = &dev->actconfig->interface[ifnum].altsetting[0];
+	}
+	endpoint = &interface->endpoint[1];
+
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_ISOC) {
+		err("%s: USBVision interface %d. has non-ISO endpoint!", __FUNCTION__, ifnum);
+		err("%s: USBVision Endpoint attribures %d", __FUNCTION__, endpoint->bmAttributes);
+		return NULL;
+	}
+	if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		err("%s: USBVision interface %d. has ISO OUT endpoint!", __FUNCTION__, ifnum);
+		return NULL;
+	}
+
+	MOD_INC_USE_COUNT;
+
+	if ((usbvision = usbvision_alloc(dev)) == NULL) {
+		err("%s: couldn't allocate USBVision struct", __FUNCTION__);
+		MOD_DEC_USE_COUNT;
+		return NULL;
+	}
+#else
+	if (usbvision_device_data[model].idVendor == 0) {
+		return -ENODEV; //no matching device
+	}
+	if (usbvision_device_data[model].Interface >= 0) {
+		interface = &dev->actconfig->interface[usbvision_device_data[model].Interface]->altsetting[0];
+	}
+	else {
+		interface = &dev->actconfig->interface[ifnum]->altsetting[0];
+	}
+	endpoint = &interface->endpoint[1].desc;
+	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_ISOC) {
+		err("%s: interface %d. has non-ISO endpoint!", __FUNCTION__, ifnum);
+		err("%s: Endpoint attribures %d", __FUNCTION__, endpoint->bmAttributes);
+		return -ENODEV;
+	}
+	if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) {
+		err("%s: interface %d. has ISO OUT endpoint!", __FUNCTION__, ifnum);
+		return -ENODEV;
+	}
+
+	usb_get_dev(dev);
+	
+	if ((usbvision = usbvision_alloc(dev)) == NULL) {
+		err("%s: couldn't allocate USBVision struct", __FUNCTION__);
+		return -ENOMEM;
+	}
+#endif
+	if (dev->descriptor.bNumConfigurations > 1) {
+		usbvision->bridgeType = BRIDGE_NT1004;
+	}
+	else {
+		usbvision->bridgeType = BRIDGE_NT1003;
+	}
+	PDEBUG(DBG_PROBE, "bridgeType %s", (usbvision->bridgeType == BRIDGE_NT1004) ? "NT1004" : "NT1003");
+
+	down(&usbvision->lock);
+
+	usbvision->nr = usbvision_nr++;
+
+	usbvision->have_tuner = usbvision_device_data[model].Tuner;
+	if (usbvision->have_tuner) {
+		usbvision->tuner_type = usbvision_device_data[model].TunerType;
+	}
+
+	usbvision->DevModel = model;
+	usbvision->remove_pending = 0;
+	usbvision->last_error = 0;
+	usbvision->iface = ifnum;
+	usbvision->ifaceAltInactive = 0;
+	usbvision->ifaceAltActive = 1;
+	usbvision->video_endp = endpoint->bEndpointAddress;
+	usbvision->isocPacketSize = 0;
+	usbvision->usb_bandwidth = 0;
+	usbvision->user = 0;
+
+	usbvision_register_video(usbvision);
+	usbvision_configure_video(usbvision);
+	up(&usbvision->lock);
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	usb_set_intfdata (intf, usbvision);
+	usbvision_create_sysfs(usbvision->vdev);	
+#else
+	usbvision_proc_dev_create(usbvision);
+#endif
+
+	PDEBUG(DBG_PROBE, "success");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+	return usbvision;
+#else
+	return 0;
+#endif
+}
+
+
+/*
+ * usbvision_disconnect()
+ *
+ * This procedure stops all driver activity, deallocates interface-private
+ * structure (pointed by 'ptr') and after that driver should be removable
+ * with no ill consequences.
+ *
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbvision_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct usb_usbvision *usbvision = (struct usb_usbvision *) ptr;
+#else
+static void __devexit usbvision_disconnect(struct usb_interface *intf)
+{
+	struct usb_usbvision *usbvision = usb_get_intfdata(intf);
+#endif
+
+	PDEBUG(DBG_PROBE, "");
+
+	if (usbvision == NULL) {
+		err("%s: usb_get_intfdata() failed", __FUNCTION__);
+		return;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#else
+	usb_set_intfdata (intf, NULL);
+#endif
+
+	down(&usbvision->lock);
+
+	// At this time we ask to cancel outstanding URBs
+	usbvision_stop_isoc(usbvision);
+
+	if (usbvision->power) {
+		i2c_usb_del_bus(&usbvision->i2c_adap);
+		usbvision_power_off(usbvision);
+	}
+	usbvision->remove_pending = 1;	// Now all ISO data will be ignored
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	usb_put_dev(usbvision->dev);
+#endif
+	usbvision->dev = NULL;	// USB device is no more
+
+	up(&usbvision->lock);
+
+	if (usbvision->user) {
+		info("%s: In use, disconnect pending", __FUNCTION__);
+	}
+	else {
+		usbvision_release(usbvision);
+	}
+
+	PDEBUG(DBG_PROBE, "success");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+}
+
+MODULE_DEVICE_TABLE (usb, usbvision_table);
+
+static struct usb_driver usbvision_driver = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,30)
+	.owner		= THIS_MODULE,
+#endif
+	.name		= "usbvision",
+	.id_table	= usbvision_table,
+	.probe		= usbvision_probe,
+	.disconnect	= usbvision_disconnect
+};
+
+/*
+ * customdevice_process()
+ *
+ * This procedure preprocesses CustomDevice parameter if any
+ *
+ */
+void customdevice_process(void)
+{
+	usbvision_device_data[0]=usbvision_device_data[1];
+	usbvision_table[0]=usbvision_table[1];
+
+	if(CustomDevice)
+	{
+		char *parse=CustomDevice;
+	
+		PDEBUG(DBG_PROBE, "CustomDevide=%s", CustomDevice);
+
+		/*format is CustomDevice="0x0573 0x4D31 0 7113 3 PAL 1 1 1 5 -1 -1 -1 -1 -1"
+		usbvision_device_data[0].idVendor;
+		usbvision_device_data[0].idProduct;
+		usbvision_device_data[0].Interface;
+		usbvision_device_data[0].Codec;
+		usbvision_device_data[0].VideoChannels;
+		usbvision_device_data[0].VideoNorm;
+		usbvision_device_data[0].AudioChannels;
+		usbvision_device_data[0].Radio;
+		usbvision_device_data[0].Tuner;
+		usbvision_device_data[0].TunerType;
+		usbvision_device_data[0].Vin_Reg1;
+		usbvision_device_data[0].Vin_Reg2;
+		usbvision_device_data[0].X_Offset;
+		usbvision_device_data[0].Y_Offset;
+		usbvision_device_data[0].Dvi_yuv;
+	 	usbvision_device_data[0].ModelString;
+		*/
+		
+		rmspace(parse);
+		usbvision_device_data[0].ModelString="USBVISION Custom Device";
+
+		parse+=2;
+		sscanf(parse,"%x",&usbvision_device_data[0].idVendor);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "idVendor=0x%.4X", usbvision_device_data[0].idVendor);
+		parse+=2;
+		sscanf(parse,"%x",&usbvision_device_data[0].idProduct);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "idProduct=0x%.4X", usbvision_device_data[0].idProduct);
+		sscanf(parse,"%d",&usbvision_device_data[0].Interface);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Interface=%d", usbvision_device_data[0].Interface);
+		sscanf(parse,"%d",&usbvision_device_data[0].Codec);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Codec=%d", usbvision_device_data[0].Codec);
+		sscanf(parse,"%d",&usbvision_device_data[0].VideoChannels);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "VideoChannels=%d", usbvision_device_data[0].VideoChannels);
+
+		switch(*parse)
+		{
+			case 'P':
+				PDEBUG(DBG_PROBE, "VideoNorm=PAL");
+				usbvision_device_data[0].VideoNorm=VIDEO_MODE_PAL;
+				break;
+
+			case 'S':
+				PDEBUG(DBG_PROBE, "VideoNorm=SECAM");
+				usbvision_device_data[0].VideoNorm=VIDEO_MODE_SECAM;
+				break;
+
+			case 'N':
+				PDEBUG(DBG_PROBE, "VideoNorm=NTSC");
+				usbvision_device_data[0].VideoNorm=VIDEO_MODE_NTSC;
+				break;
+
+			default:
+				PDEBUG(DBG_PROBE, "VideoNorm=PAL (by default)");
+				usbvision_device_data[0].VideoNorm=VIDEO_MODE_PAL;
+				break;
+		}
+		goto2next(parse);
+
+		sscanf(parse,"%d",&usbvision_device_data[0].AudioChannels);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "AudioChannels=%d", usbvision_device_data[0].AudioChannels);
+		sscanf(parse,"%d",&usbvision_device_data[0].Radio);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Radio=%d", usbvision_device_data[0].Radio);
+		sscanf(parse,"%d",&usbvision_device_data[0].Tuner);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Tuner=%d", usbvision_device_data[0].Tuner);
+		sscanf(parse,"%d",&usbvision_device_data[0].TunerType);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "TunerType=%d", usbvision_device_data[0].TunerType);
+		sscanf(parse,"%d",&usbvision_device_data[0].Vin_Reg1);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Vin_Reg1=%d", usbvision_device_data[0].Vin_Reg1);
+		sscanf(parse,"%d",&usbvision_device_data[0].Vin_Reg2);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Vin_Reg2=%d", usbvision_device_data[0].Vin_Reg2);
+		sscanf(parse,"%d",&usbvision_device_data[0].X_Offset);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "X_Offset=%d", usbvision_device_data[0].X_Offset);
+		sscanf(parse,"%d",&usbvision_device_data[0].Y_Offset);
+		goto2next(parse);
+		PDEBUG(DBG_PROBE, "Y_Offset=%d", usbvision_device_data[0].Y_Offset);
+		sscanf(parse,"%d",&usbvision_device_data[0].Dvi_yuv);
+		PDEBUG(DBG_PROBE, "Dvi_yuv=%d", usbvision_device_data[0].Dvi_yuv);
+
+		//add to usbvision_table also
+		usbvision_table[0].match_flags=USB_DEVICE_ID_MATCH_DEVICE;
+		usbvision_table[0].idVendor=usbvision_device_data[0].idVendor;
+		usbvision_table[0].idProduct=usbvision_device_data[0].idProduct;
+
+	}
+}
+
+
+
+/*
+ * usbvision_init()
+ *
+ * This code is run to initialize the driver.
+ *
+ */
+static int __init usbvision_init(void)
+{
+	int errCode;
+
+	PDEBUG(DBG_PROBE, "");
+
+ PDEBUG(DBG_PROCFS, "PROCFS  debugging is enabled");
+ PDEBUG(DBG_IOCTL, "IOCTL   debugging is enabled");
+ PDEBUG(DBG_IO,  "IO      debugging is enabled");
+ PDEBUG(DBG_RIO,  "RIO     debugging is enabled");
+ PDEBUG(DBG_HEADER, "HEADER  debugging is enabled");
+ PDEBUG(DBG_PROBE, "PROBE   debugging is enabled");
+ PDEBUG(DBG_IRQ,  "IRQ     debugging is enabled");
+ PDEBUG(DBG_ISOC, "ISOC    debugging is enabled");
+ PDEBUG(DBG_PARSE, "PARSE   debugging is enabled");
+ PDEBUG(DBG_SCRATCH, "SCRATCH debugging is enabled");
+ PDEBUG(DBG_FUNC, "FUNC    debugging is enabled");
+ PDEBUG(DBG_I2C,  "I2C     debugging is enabled");
+
+/* disable planar mode support unless compression enabled */ 
+ if (isocMode != ISOC_MODE_COMPRESS ) { 
+ 	usbvision_v4l_format[VIDEO_PALETTE_YUV420P].supported = 0; 
+	usbvision_v4l_format[VIDEO_PALETTE_YUV422P].supported = 0; 
+ } 
+
+ usbvision_proc_create();
+ 
+ customdevice_process();
+
+ errCode = usb_register(&usbvision_driver);
+
+ if (errCode == 0) {
+  info(DRIVER_DESC " : " DRIVER_VERSION);
+  PDEBUG(DBG_PROBE, "success");
+ }
+ return errCode;
+}
+
+static void __exit usbvision_exit(void)
+{
+ PDEBUG(DBG_PROBE, "");
+
+ usb_deregister(&usbvision_driver);
+ usbvision_proc_destroy();
+ PDEBUG(DBG_PROBE, "success");
+}
+
+module_init(usbvision_init);
+module_exit(usbvision_exit);
diff -Naurp linux-2.6.12.orig/drivers/usb/media/usbvision.h linux-2.6.12-grml/drivers/usb/media/usbvision.h
--- linux-2.6.12.orig/drivers/usb/media/usbvision.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/usbvision.h	2005-06-27 17:10:28.506247546 +0200
@@ -0,0 +1,594 @@
+#ifndef __LINUX_USBVISION_H
+#define __LINUX_USBVISION_H
+
+#include <linux/list.h>
+
+#ifndef VID_HARDWARE_USBVISION
+	#define VID_HARDWARE_USBVISION 34  /* USBVision Video Grabber */
+#endif
+
+#define USBVISION_PWR_REG		0x00
+	#define USBVISION_SSPND_EN		(1 << 1)
+	#define USBVISION_RES2			(1 << 2)
+	#define USBVISION_PWR_VID		(1 << 5)
+        #define USBVISION_E2_EN			(1 << 7)
+#define USBVISION_CONFIG_REG		0x01
+#define USBVISION_ADRS_REG		0x02
+#define USBVISION_ALTER_REG		0x03
+#define USBVISION_FORCE_ALTER_REG	0x04
+#define USBVISION_STATUS_REG		0x05
+#define USBVISION_IOPIN_REG		0x06
+	#define USBVISION_IO_1			(1 << 0)
+	#define USBVISION_IO_2			(1 << 1)
+	#define USBVISION_AUDIO_IN		0
+	#define USBVISION_AUDIO_TV		1
+	#define USBVISION_AUDIO_RADIO		2
+	#define USBVISION_AUDIO_MUTE		3
+#define USBVISION_SER_MODE		0x07
+#define USBVISION_SER_ADRS		0x08
+#define USBVISION_SER_CONT		0x09
+#define USBVISION_SER_DAT1		0x0A
+#define USBVISION_SER_DAT2		0x0B
+#define USBVISION_SER_DAT3		0x0C
+#define USBVISION_SER_DAT4		0x0D
+#define USBVISION_EE_DATA		0x0E
+#define USBVISION_EE_LSBAD		0x0F
+#define USBVISION_EE_CONT		0x10
+#define USBVISION_DRM_CONT			0x12
+	#define USBVISION_REF			(1 << 0)
+	#define USBVISION_RES_UR		(1 << 2)
+	#define USBVISION_RES_FDL		(1 << 3)
+	#define USBVISION_RES_VDW		(1 << 4)
+#define USBVISION_DRM_PRM1		0x13
+#define USBVISION_DRM_PRM2		0x14
+#define USBVISION_DRM_PRM3		0x15
+#define USBVISION_DRM_PRM4		0x16
+#define USBVISION_DRM_PRM5		0x17
+#define USBVISION_DRM_PRM6		0x18
+#define USBVISION_DRM_PRM7		0x19
+#define USBVISION_DRM_PRM8		0x1A
+#define USBVISION_VIN_REG1		0x1B
+	#define USBVISION_8_422_SYNC		0x01
+	#define USBVISION_16_422_SYNC		0x02
+	#define USBVISION_VSNC_POL		(1 << 3)
+	#define USBVISION_HSNC_POL		(1 << 4)
+	#define USBVISION_FID_POL		(1 << 5)
+	#define USBVISION_HVALID_PO		(1 << 6)
+	#define USBVISION_VCLK_POL		(1 << 7)
+#define USBVISION_VIN_REG2		0x1C
+	#define USBVISION_AUTO_FID		(1 << 0)
+	#define USBVISION_NONE_INTER		(1 << 1)
+	#define USBVISION_NOHVALID		(1 << 2)
+	#define USBVISION_UV_ID			(1 << 3)
+	#define USBVISION_FIX_2C		(1 << 4)
+	#define USBVISION_SEND_FID		(1 << 5)
+	#define USBVISION_KEEP_BLANK		(1 << 7)
+#define USBVISION_LXSIZE_I		0x1D
+#define USBVISION_MXSIZE_I		0x1E
+#define USBVISION_LYSIZE_I		0x1F
+#define USBVISION_MYSIZE_I		0x20
+#define USBVISION_LX_OFFST		0x21
+#define USBVISION_MX_OFFST		0x22
+#define USBVISION_LY_OFFST		0x23
+#define USBVISION_MY_OFFST		0x24
+#define USBVISION_FRM_RATE		0x25
+#define USBVISION_LXSIZE_O		0x26
+#define USBVISION_MXSIZE_O		0x27
+#define USBVISION_LYSIZE_O		0x28
+#define USBVISION_MYSIZE_O		0x29
+#define USBVISION_FILT_CONT		0x2A
+#define USBVISION_VO_MODE		0x2B
+#define USBVISION_INTRA_CYC		0x2C
+#define USBVISION_STRIP_SZ		0x2D
+#define USBVISION_FORCE_INTRA		0x2E
+#define USBVISION_FORCE_UP		0x2F
+#define USBVISION_BUF_THR		0x30
+#define USBVISION_DVI_YUV		0x31
+#define USBVISION_AUDIO_CONT		0x32
+#define USBVISION_AUD_PK_LEN		0x33
+#define USBVISION_BLK_PK_LEN		0x34
+#define USBVISION_PCM_THR1		0x38
+#define USBVISION_PCM_THR2		0x39
+#define USBVISION_DIST_THR_L		0x3A
+#define USBVISION_DIST_THR_H		0x3B
+#define USBVISION_MAX_DIST_L		0x3C
+#define USBVISION_MAX_DIST_H		0x3D
+#define USBVISION_OP_CODE		0x33
+
+#define MAX_BYTES_PER_PIXEL		4
+
+#define MIN_FRAME_WIDTH			64
+#define MAX_USB_WIDTH			320  //384
+#define MAX_FRAME_WIDTH			320  //384			/*streching sometimes causes crashes*/
+
+#define MIN_FRAME_HEIGHT		48
+#define MAX_USB_HEIGHT			240  //288
+#define MAX_FRAME_HEIGHT		240  //288			/*Streching sometimes causes crashes*/
+
+#define MAX_FRAME_SIZE     		(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT * MAX_BYTES_PER_PIXEL)
+#define USBVISION_CLIPMASK_SIZE		(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT / 8) //bytesize of clipmask
+
+#define USBVISION_URB_FRAMES		32
+#define USBVISION_MAX_ISOC_PACKET_SIZE 	959			// NT1003 Specs Document says 1023
+
+#define USBVISION_NUM_HEADERMARKER	20
+#define USBVISION_NUMFRAMES		2
+#define USBVISION_NUMSBUF		2
+
+#define USBVISION_POWEROFF_TIME		3 * (HZ)		// 3 seconds
+
+/* This macro restricts an int variable to an inclusive range */
+#define RESTRICT_TO_RANGE(v,mi,ma) { if ((v) < (mi)) (v) = (mi); else if ((v) > (ma)) (v) = (ma); }
+
+/*
+ * We use macros to do YUV -> RGB conversion because this is
+ * very important for speed and totally unimportant for size.
+ *
+ * YUV -> RGB Conversion
+ * ---------------------
+ *
+ * B = 1.164*(Y-16)		    + 2.018*(V-128)
+ * G = 1.164*(Y-16) - 0.813*(U-128) - 0.391*(V-128)
+ * R = 1.164*(Y-16) + 1.596*(U-128)
+ *
+ * If you fancy integer arithmetics (as you should), hear this:
+ *
+ * 65536*B = 76284*(Y-16)		  + 132252*(V-128)
+ * 65536*G = 76284*(Y-16) -  53281*(U-128) -  25625*(V-128)
+ * 65536*R = 76284*(Y-16) + 104595*(U-128)
+ *
+ * Make sure the output values are within [0..255] range.
+ */
+#define LIMIT_RGB(x) (((x) < 0) ? 0 : (((x) > 255) ? 255 : (x)))
+#define YUV_TO_RGB_BY_THE_BOOK(my,mu,mv,mr,mg,mb) { \
+    int mm_y, mm_yc, mm_u, mm_v, mm_r, mm_g, mm_b; \
+    mm_y = (my) - 16;  \
+    mm_u = (mu) - 128; \
+    mm_v = (mv) - 128; \
+    mm_yc= mm_y * 76284; \
+    mm_b = (mm_yc		+ 132252*mm_v	) >> 16; \
+    mm_g = (mm_yc -  53281*mm_u -  25625*mm_v	) >> 16; \
+    mm_r = (mm_yc + 104595*mm_u			) >> 16; \
+    mb = LIMIT_RGB(mm_b); \
+    mg = LIMIT_RGB(mm_g); \
+    mr = LIMIT_RGB(mm_r); \
+}
+
+#if 0
+/*
+ * This macro performs bounds checking - use it when working with
+ * new formats, or else you may get oopses all over the place.
+ * If pixel falls out of bounds then it gets shoved back (as close
+ * to place of offence as possible) and is painted bright red.
+ */
+#define USBVISION_PUTPIXEL(fr, ix, iy, vr, vg, vb) { \
+	register unsigned char *pf; \
+	int limiter = 0, mx, my; \
+	mx = ix; \
+	my = iy; \
+	if (mx < 0) { \
+		mx=0; \
+		limiter++; \
+	} else if (mx >= 352) { \
+		mx=351; \
+		limiter++; \
+	} \
+	if (my < 0) { \
+		my = 0; \
+		limiter++; \
+	} else if (my >= V4L_FRAME_HEIGHT) { \
+		my = V4L_FRAME_HEIGHT - 1; \
+		limiter++; \
+	} \
+	pf = (fr)->data + V4L_BYTES_PER_PIXEL*((iy)*352 + (ix)); \
+	if (limiter) { \
+		*pf++ = 0; \
+		*pf++ = 0; \
+		*pf++ = 0xFF; \
+	} else { \
+		*pf++ = (vb); \
+		*pf++ = (vg); \
+		*pf++ = (vr); \
+	} \
+}
+#endif
+
+
+/* Debugging aid */
+#define USBVISION_SAY_AND_WAIT(what) { \
+	wait_queue_head_t wq; \
+	init_waitqueue_head(&wq); \
+	printk(KERN_INFO "Say: %s\n", what); \
+	interruptible_sleep_on_timeout (&wq, HZ*3); \
+}
+
+/*
+ * This macro checks if usbvision is still operational. The 'usbvision'
+ * pointer must be valid, usbvision->dev must be valid, we are not
+ * removing the device and the device has not erred on us.
+ */
+#define USBVISION_IS_OPERATIONAL(udevice) (\
+	(udevice != NULL) && \
+	((udevice)->dev != NULL) && \
+	((udevice)->last_error == 0) && \
+	(!(udevice)->remove_pending))
+
+
+enum ScanState {
+	ScanState_Scanning,	/* Scanning for header */
+	ScanState_Lines		/* Parsing lines */
+};
+
+/* Completion states of the data parser */
+enum ParseState {
+	ParseState_Continue,	/* Just parse next item */
+	ParseState_NextFrame,	/* Frame done, send it to V4L */
+	ParseState_Out,		/* Not enough data for frame */
+	ParseState_EndParse	/* End parsing */
+};
+
+enum FrameState {
+	FrameState_Unused,	/* Unused (no MCAPTURE) */
+	FrameState_Ready,	/* Ready to start grabbing */
+	FrameState_Grabbing,	/* In the process of being grabbed into */
+	FrameState_Done,	/* Finished grabbing, but not been synced yet */
+	FrameState_DoneHold,	/* Are syncing or reading */
+	FrameState_Error,	/* Something bad happened while processing */
+};
+
+enum IsocState {
+	IsocState_InFrame,	/* Isoc packet is member of frame */
+	IsocState_NoFrame,	/* Isoc packet is not member of any frame */
+};
+
+struct usb_device;
+
+struct usbvision_sbuf {
+	char *data;
+	struct urb *urb;
+};
+
+#define USBVISION_MAGIC_1      			0x55
+#define USBVISION_MAGIC_2      			0xAA
+#define USBVISION_HEADER_LENGTH			0x0c
+#define USBVISION_SAA7111_ADDR			0x48
+#define USBVISION_SAA7113_ADDR			0x4a
+#define USBVISION_BT819_ADDR			0x89
+#define USBVISION_IIC_LRACK			0x20
+#define USBVISION_IIC_LRNACK			0x30
+#define USBVISION_FRAME_FORMAT_PARAM_INTRA	(1<<7)
+
+struct usbvision_frame_header {
+	unsigned char magic_1;				/* 0 magic */
+	unsigned char magic_2;				/* 1  magic */
+	unsigned char headerLength;			/* 2 */
+	unsigned char frameNum;				/* 3 */
+	unsigned char framePhase;			/* 4 */
+	unsigned char frameLatency;			/* 5 */
+	unsigned char dataFormat;			/* 6 */
+	unsigned char formatParam;			/* 7 */
+	unsigned char frameWidthLo;			/* 8 */
+	unsigned char frameWidthHi;			/* 9 */
+	unsigned char frameHeightLo;			/* 10 */
+	unsigned char frameHeightHi;			/* 11 */
+	__u16 frameWidth;				/* 8 - 9 after endian correction*/
+	__u16 frameHeight;				/* 10 - 11 after endian correction*/
+};
+
+struct usbvision_frame {
+	char *data;					/* Frame buffer */
+	struct usbvision_frame_header isocHeader;	/* Header from stream */
+
+	int width;					/* Width application is expecting */
+	int height;					/* Height */
+
+	int frmwidth;					/* Width the frame actually is */
+	int frmheight;					/* Height */
+
+	volatile int grabstate;				/* State of grabbing */
+	int scanstate;					/* State of scanning */
+
+	int curline;					/* Line of frame we're working on */
+
+	long scanlength;				/* uncompressed, raw data length of frame */
+	long bytes_read;				/* amount of scanlength that has been read from data */
+	int v4l_format;					/* format the user needs*/
+	int v4l_linesize;				/* bytes for one videoline*/
+
+	wait_queue_head_t wq;				/* Processes waiting */
+};
+
+#define CODEC_SAA7113	7113
+#define CODEC_SAA7111	7111
+#define CODEC_BT819	819
+#define BRIDGE_NT1003	1003
+#define BRIDGE_NT1004	1004
+
+/* Supported Devices: A table for usbvision.c*/
+
+static struct usbvision_device_data_st {
+	int idVendor;
+	int idProduct;
+	int Interface;					/* to handle special interface number like BELKIN and Hauppauge WinTV-USB II */
+	int Codec;
+	int VideoChannels;
+	int VideoNorm;
+	int AudioChannels;
+	int Radio;
+	int vbi;
+	int Tuner;
+	int TunerType;
+	int Vin_Reg1;
+	int Vin_Reg2;
+	int X_Offset;
+	int Y_Offset;
+	int Dvi_yuv;
+	char *ModelString;
+} usbvision_device_data[] = {
+	{}, /* CUSTOM USBVISION DEVICE do not move, must be first */
+	{0x0A6F, 0x0400, -1, CODEC_SAA7113, 4, VIDEO_MODE_NTSC,  1, 0, 1, 0, 0,                        -1, -1, -1, -1, -1, "Xanboo"}, 
+	{0x050D, 0x0208,  0, CODEC_SAA7113, 2, VIDEO_MODE_PAL,   1, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Belkin USBView II"},
+	{0x0573, 0x0003, -1, CODEC_SAA7111, 2, VIDEO_MODE_NTSC,  1, 0, 1, 0, 0,                        -1, -1, -1, -1, -1, "USBGear USBG-V1 resp. HAMA USB"},
+	{0x0573, 0x0400, -1, CODEC_SAA7113, 4, VIDEO_MODE_NTSC,  0, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "D-Link V100"},
+	{0x0573, 0x2000, -1, CODEC_SAA7111, 2, VIDEO_MODE_NTSC,  1, 0, 1, 0, 0,                        -1, -1, -1, -1, -1, "X10 USB Camera"},
+	{0x0573, 0x2d01, -1, CODEC_SAA7113, 2, VIDEO_MODE_NTSC,	 0, 0, 1, 0, 0,			       -1, -1,  0,  3,  7, "Hauppauge USB-Live Model 600"},
+	{0x0573, 0x2101, -1, CODEC_SAA7113, 2, VIDEO_MODE_PAL, 	 2, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Zoran Co. PMD (Nogatech) AV-grabber Manhattan"},
+	{0x0573, 0x4100, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, 20, -1, "Nogatech USB-TV (NTSC) FM"},
+	{0x0573, 0x4450,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "PixelView PlayTv-USB PRO (PAL) FM"},
+	{0x0573, 0x4550,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "ZTV ZT-721 2.4GHz USB A/V Receiver"},
+	{0x0573, 0x4d00, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, 20, -1, "Hauppauge WinTv-USB USA"},
+	{0x0573, 0x4d01, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Hauppauge WinTv-USB"},
+	{0x0573, 0x4d02, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 0, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (NTSC)"},
+	{0x0573, 0x4d03, -1, CODEC_SAA7111, 3, VIDEO_MODE_SECAM, 1, 0, 1, 1, TUNER_PHILIPS_SECAM,      -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (SECAM) "},
+	{0x0573, 0x4d10, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (NTSC) FM"},
+	{0x0573, 0x4d11, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (PAL) FM"},
+	{0x0573, 0x4d12, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Hauppauge WinTv-USB (PAL) FM"},
+	{0x0573, 0x4d2a,  0, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_MICROTUNE_4049FM5,  -1, -1,  0,  3,  7, "Hauppague WinTv USB (NTSC) FM Model 602 40201 Rev B285"}, 
+	{0x0573, 0x4d2b,  0, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_MICROTUNE_4049FM5,  -1, -1,  0,  3,  7, "Hauppague WinTv USB (NTSC) FM Model 602 40201 Rev B282"},
+	{0x0573, 0x4d20,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "Hauppauge WinTv-USB II (PAL) FM Model 40201 Rev B226"},
+	{0x0573, 0x4d21,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 0, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "Hauppauge WinTv-USB II (PAL)"},
+	{0x0573, 0x4d22,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 0, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "Hauppauge WinTv-USB II (PAL) MODEL 566"},
+	{0x0573, 0x4d23, -1, CODEC_SAA7113, 3, VIDEO_MODE_SECAM, 1, 0, 1, 1, TUNER_PHILIPS_SECAM,      -1, -1,  0,  3,  7, "Hauppauge WinTv-USB (SECAM) 4D23"},
+	{0x0573, 0x4d26, -1, CODEC_SAA7113, 3, VIDEO_MODE_SECAM, 1, 0, 1, 1, TUNER_PHILIPS_SECAM,      -1, -1,  0,  3,  7, "Hauppauge WinTv-USB (SECAM) Model 40209 Rev B243"},
+	{0x0573, 0x4d28, -1, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 0, 1, 1, TUNER_ALPS_TSBE1_PAL,     -1, -1,  0,  3,  7, "Hauppauge WinTv-USB (PAL) Model 40204 Rev B283"}, 
+	{0x0573, 0x4d30, -1, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1,  0,  3,  7, "Hauppauge WinTv-USB (NTSC) FM Model 40211 Rev B123"},
+	{0x0573, 0x4d31,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "Hauppauge WinTv-USB III (PAL) FM Model 568"},
+        {0x0573, 0x4d32,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1,  0,  3,  7, "Hauppauge WinTv-USB III (PAL) FM Model 573"},
+	{0x0573, 0x4d35,  0, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_MICROTUNE_4049FM5,  -1, -1,  0,  3,  7, "Hauppauge WinTv-USB III (PAL) FM Model 40219 Rev B252"},
+	{0x0768, 0x0006, -1, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1,  5,  5, -1, "Camtel Technology USB TV Genie Pro FM Model TVB330"},
+	{0x07d0, 0x0001, -1, CODEC_SAA7113, 2, VIDEO_MODE_PAL,   0, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Digital Video Creator I"},
+	{0x07d0, 0x0002, -1, CODEC_SAA7111, 2, VIDEO_MODE_NTSC,  0, 0, 1, 0, 0,   		       -1, -1, 82, 20,  7, "Global Village GV-007 (NTSC)"},
+	{0x07d0, 0x0003, -1, CODEC_SAA7113, 2, VIDEO_MODE_NTSC,  0, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Dazzle DVC-50 (NTSC)"},
+	{0x07d0, 0x0004, -1, CODEC_SAA7113, 2, VIDEO_MODE_PAL,   0, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Dazzle DVC-80 (PAL)"},
+	{0x07d0, 0x0005, -1, CODEC_SAA7113, 2, VIDEO_MODE_SECAM, 0, 0, 1, 0, 0,	   		       -1, -1,  0,  3,  7, "Dazzle FUSION (SECAM)"}, 
+	{0x2304, 0x0109, -1, CODEC_SAA7111, 3, VIDEO_MODE_SECAM, 1, 0, 1, 1, TUNER_PHILIPS_SECAM,      -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (SECAM)"},
+	{0x2304, 0x0110, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (PAL) FM"},
+	{0x2304, 0x0111, -1, CODEC_SAA7111, 3, VIDEO_MODE_PAL,   1, 0, 1, 1, TUNER_PHILIPS_PAL,        -1, -1, -1, -1, -1, "Miro PCTV USB"},
+	{0x2304, 0x0112, -1, CODEC_SAA7111, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_PHILIPS_NTSC_M,     -1, -1, -1, -1, -1, "Pinnacle Studio PCTV USB (NTSC) FM"},
+	{0x2304, 0x0210, -1, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_TEMIC_4009FR5_PAL,  -1, -1,  0,  3,  7, "Pinnacle Studio PCTV USB (PAL) FM"},
+	{0x2304, 0x0212, -1, CODEC_SAA7113, 3, VIDEO_MODE_NTSC,  1, 1, 1, 1, TUNER_TEMIC_4039FR5_NTSC, -1, -1,  0,  3,  7, "Pinnacle Studio PCTV USB (NTSC) FM"},
+	{0x2304, 0x0214, -1, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_TEMIC_4009FR5_PAL,  -1, -1,  0,  3,  7, "Pinnacle Studio PCTV USB (PAL) FM"},
+	{0x2304, 0x0300, -1, CODEC_SAA7113, 2, VIDEO_MODE_NTSC,  1, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Pinnacle Studio Linx Video input cable (NTSC)"},
+	{0x2304, 0x0301, -1, CODEC_SAA7113, 2, VIDEO_MODE_PAL,   1, 0, 1, 0, 0,                        -1, -1,  0,  3,  7, "Pinnacle Studio Linx Video input cable (PAL)"}, 
+	{0x2304, 0x0419, -1, CODEC_SAA7113, 3, VIDEO_MODE_PAL,   1, 1, 1, 1, TUNER_TEMIC_4009FR5_PAL,  -1, -1,  0,  3,  7, "Pinnacle PCTV Bungee USB (PAL) FM"},
+	{}  /* Terminating entry */
+};
+
+
+/* Supported Devices: A table for the usb.c*/
+
+static struct usb_device_id usbvision_table [] = {
+	{ },  /* CUSTOM USBVISION DEVICE do not move, must be first */
+	{ USB_DEVICE(0x0A6F, 0x0400) },  /* Xanboo */ 
+	{ USB_DEVICE(0x050d, 0x0208) },  /* Belkin USBView II */
+	{ USB_DEVICE(0x0573, 0x0003) },  /* USBGear USBG-V1 */
+	{ USB_DEVICE(0x0573, 0x0400) },  /* D-Link V100 */
+	{ USB_DEVICE(0x0573, 0x2000) },  /* X10 USB Camera */
+	{ USB_DEVICE(0x0573, 0x2d01) },  /* Hauppauge USB-Live Model 600 */
+	{ USB_DEVICE(0x0573, 0x2101) },  /* Zoran Co. PMD (Nogatech) AV-grabber Manhattan */
+	{ USB_DEVICE(0x0573, 0x4100) },  /* Nogatech USB-TV FM (NTSC) */
+	{ USB_DEVICE(0x0573, 0x4450) },  /* PixelView PlayTv-USB PRO (PAL) FM */
+	{ USB_DEVICE(0x0573, 0x4550) },  /* ZTV ZT-721 2.4GHz USB A/V Receiver */
+	{ USB_DEVICE(0x0573, 0x4d00) },  /* Hauppauge WinTv-USB USA */
+	{ USB_DEVICE(0x0573, 0x4d01) },  /* Hauppauge WinTv-USB */
+	{ USB_DEVICE(0x0573, 0x4d02) },  /* Hauppauge WinTv-USB UK */
+	{ USB_DEVICE(0x0573, 0x4d03) },  /* Hauppauge WinTv-USB France */
+	{ USB_DEVICE(0x0573, 0x4d10) },  /* Hauppauge WinTv-USB with FM USA radio */
+	{ USB_DEVICE(0x0573, 0x4d11) },  /* Hauppauge WinTv-USB (PAL) with FM radio */
+	{ USB_DEVICE(0x0573, 0x4d12) },  /* Hauppauge WinTv-USB UK with FM Radio */
+	{ USB_DEVICE(0x0573, 0x4d2b) },  /* Hauppague WinTv USB Model 602 40201 Rev B282 */
+	{ USB_DEVICE(0x0573, 0x4d2a) },  /* Hauppague WinTv USB Model 602 40201 Rev B285 */ 
+	{ USB_DEVICE(0x0573, 0x4d20) },  /* Hauppauge WinTv-USB II (PAL) FM Model 40201 Rev B226 */
+	{ USB_DEVICE(0x0573, 0x4d21) },  /* Hauppauge WinTv-USB II (PAL) with FM radio*/
+	{ USB_DEVICE(0x0573, 0x4d22) },  /* Hauppauge WinTv-USB II (PAL) Model 566 */
+	{ USB_DEVICE(0x0573, 0x4d23) },  /* Hauppauge WinTv-USB France 4D23*/
+	{ USB_DEVICE(0x0573, 0x4d26) },  /* Hauppauge WinTv-USB Model 40209 rev B243 */
+	{ USB_DEVICE(0x0573, 0x4d28) },  /* Hauppauge WinTv-USB Model 40204 rev B283 */
+	{ USB_DEVICE(0x0573, 0x4d30) },  /* Hauppauge WinTv-USB FM Model 40211 rev B123 */
+	{ USB_DEVICE(0x0573, 0x4d31) },  /* Hauppauge WinTv-USB III (PAL) with FM radio Model 568 */
+	{ USB_DEVICE(0x0573, 0x4d32) },  /* Hauppauge WinTv-USB III (PAL) FM Model 573 */
+	{ USB_DEVICE(0x0573, 0x4d35) },  /* Hauppauge WinTv-USB III (PAL) FM Model 40219 Rev B252 */
+	{ USB_DEVICE(0x0768, 0x0006) },  /* Camtel Technology USB TV Genie Pro FM Model TVB330 */
+	{ USB_DEVICE(0x07d0, 0x0001) },  /* Digital Video Creator I */
+	{ USB_DEVICE(0x07d0, 0x0002) },  /* Global Village GV-007 (NTSC) */
+	{ USB_DEVICE(0x07d0, 0x0003) },  /* Dazzle DVC-50 (NTSC) */
+	{ USB_DEVICE(0x07d0, 0x0004) },  /* Dazzle DVC-80 (PAL) */
+	{ USB_DEVICE(0x07d0, 0x0005) },  /* Dazzle Fusion (SECAM) */ 
+	{ USB_DEVICE(0x2304, 0x0109) },  /* Pinnacle Studio PCTV USB (SECAM) */
+	{ USB_DEVICE(0x2304, 0x0110) },  /* Pinnacle Studio PCTV USB (PAL) */
+	{ USB_DEVICE(0x2304, 0x0111) },  /* Miro PCTV USB */
+	{ USB_DEVICE(0x2304, 0x0112) },  /* Pinnacle Studio PCTV USB (NTSC) with FM radio */
+	{ USB_DEVICE(0x2304, 0x0210) },  /* Pinnacle Studio PCTV USB (PAL) with FM radio */
+	{ USB_DEVICE(0x2304, 0x0212) },  /* Pinnacle Studio PCTV USB (NTSC) with FM radio */
+	{ USB_DEVICE(0x2304, 0x0214) },  /* Pinnacle Studio PCTV USB (PAL) with FM radio */
+	{ USB_DEVICE(0x2304, 0x0300) },  /* Pinnacle Studio Linx Video input cable (NTSC) */
+	{ USB_DEVICE(0x2304, 0x0301) },  /* Pinnacle Studio Linx Video input cable (PAL) */ 
+	{ USB_DEVICE(0x2304, 0x0419) },  /* Pinnacle PCTV Bungee USB (PAL) FM */
+	{ }  /* Terminating entry */
+};
+
+
+#define USBVISION_I2C_CLIENTS_MAX		8
+
+struct usb_usbvision {
+	struct video_device *vdev;         				/* Video Device */
+	struct video_device *rdev;               			/* Radio Device */
+	struct video_device *vbi; 					/* VBI Device   */
+	struct video_audio audio_dev;	        			/* Current audio params */
+
+	/* i2c Declaration Section*/
+	struct i2c_adapter i2c_adap;
+	struct i2c_algo_usb_data i2c_algo;
+	struct i2c_client i2c_client;
+	int i2c_state, i2c_ok;
+	struct i2c_client *i2c_clients[USBVISION_I2C_CLIENTS_MAX];
+
+	struct urb *ctrlUrb;
+	unsigned char ctrlUrbBuffer[8];
+	int ctrlUrbBusy;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20)
+	devrequest ctrlUrbSetup;
+#else
+	struct usb_ctrlrequest ctrlUrbSetup;
+#endif	
+	wait_queue_head_t ctrlUrb_wq;					// Processes waiting
+	struct semaphore ctrlUrbLock;
+
+	int have_tuner;
+	int tuner_type;
+	int bridgeType;							// NT1003 or NT1004
+	int channel;
+	int radio;
+	int video_inputs;						// # of inputs
+	unsigned long freq;
+	int AudioMute;
+	int AudioChannel;
+	int isocMode;							// format of video data for the usb isoc-transfer
+	unsigned int nr;						// Number of the device < MAX_USBVISION
+
+	/* Device structure */
+	struct usb_device *dev;
+	unsigned char iface;						/* Video interface number */
+	unsigned char ifaceAltActive, ifaceAltInactive;			/* Alt settings */
+	unsigned char Vin_Reg2_Preset;
+	struct semaphore lock;
+	struct timer_list powerOffTimer;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct tq_struct powerOffTask;
+#else
+	struct work_struct powerOffWork;
+#endif
+	int power;							/* is the device powered on? */
+	int user;							/* user count for exclusive use */
+	int usbvision_used;						/* Is this structure in use? */
+	int initialized;						/* Had we already sent init sequence? */
+	int DevModel;							/* What type of USBVISION device we got? */
+	int streaming;							/* Are we streaming Isochronous? */
+	int last_error;							/* What calamity struck us? */
+	int curwidth;							/* width of the frame the device is currently set to*/
+	int curheight;      						/* height of the frame the device is currently set to*/
+	int stretch_width;						/* stretch-factor for frame width (from usb to screen)*/
+	int stretch_height;						/* stretch-factor for frame height (from usb to screen)*/
+	char *fbuf;							/* Videodev buffer area for mmap*/
+	int max_frame_size;						/* Bytes in one video frame */
+	int fbuf_size;							/* Videodev buffer size */
+	int curFrameNum;						// number of current frame in frame buffer mode
+	struct usbvision_frame *curFrame;				// pointer to current frame, set by usbvision_find_header
+	struct usbvision_frame frame[USBVISION_NUMFRAMES];		// frame buffer
+	int curSbufNum;							// number of current receiving sbuf
+	struct usbvision_sbuf sbuf[USBVISION_NUMSBUF];			// S buffering
+	volatile int remove_pending;					/* If set then about to exit */
+
+	/* Scratch space from the Isochronous Pipe.*/
+	unsigned char *scratch;
+	int scratch_read_ptr;
+	int scratch_write_ptr;
+	int scratch_headermarker[USBVISION_NUM_HEADERMARKER];
+	int scratch_headermarker_read_ptr;
+	int scratch_headermarker_write_ptr;
+	int isocstate;
+	struct video_picture vpic;					/* Picture settings */
+	struct video_capability vcap;					/* Video capabilities */
+	struct video_channel vchan;					/* May be used for tuner support */
+	unsigned char video_endp;					/* 0x82 for USBVISION devices based */
+
+	// Overlay stuff:
+	struct video_buffer vid_buf;
+	struct video_window vid_win;
+	int vid_buf_valid;						// Status: video buffer is valid (set)
+	int vid_win_valid;						// Status: video window is valid (set)
+	int	overlay;						/*Status: Are we overlaying? */
+	unsigned int 	clipmask[USBVISION_CLIPMASK_SIZE / 4];
+	unsigned char   *overlay_base;					/* Virtual base address of video buffer */
+	unsigned char   *overlay_win;					/* virt start address of overlay window */
+	struct usbvision_frame overlay_frame;
+
+	// Decompression stuff:
+	unsigned char *IntraFrameBuffer;				/* Buffer for reference frame */
+	int BlockPos; 							//for test only
+	int requestIntra;						// 0 = normal; 1 = intra frame is requested;
+	int lastIsocFrameNum;						// check for lost isoc frames
+	int isocPacketSize;						// need to calculate usedBandwidth
+	int usedBandwidth;						// used bandwidth 0-100%, need to set comprLevel
+	int comprLevel;							// How strong (100) or weak (0) is compression
+	int lastComprLevel;						// How strong (100) or weak (0) was compression
+	int usb_bandwidth;						/* Mbit/s */
+
+	/* /proc entries, relative to /proc/video/usbvision/ */
+	struct proc_dir_entry *proc_devdir;		/* Per-device proc directory */
+	struct proc_dir_entry *proc_info;		/* <minor#>/info entry */
+	struct proc_dir_entry *proc_register;		/* <minor#>/register entry */
+	struct proc_dir_entry *proc_frame;		/* <minor#>/frame entry */
+	struct proc_dir_entry *proc_button;		/* <minor#>/button entry */
+	struct proc_dir_entry *proc_control;		/* <minor#>/control entry */
+
+	/* Statistics that can be overlayed on the screen */
+	unsigned long isocUrbCount;			// How many URBs we received so far
+	unsigned long urb_length;			/* Length of last URB */
+	unsigned long isocDataCount;			/* How many bytes we received */
+	unsigned long header_count;			/* How many frame headers we found */
+	unsigned long scratch_ovf_count;		/* How many times we overflowed scratch */
+	unsigned long isocSkipCount;			/* How many empty ISO packets received */
+	unsigned long isocErrCount;			/* How many bad ISO packets received */
+	unsigned long isocPacketCount;			// How many packets we totally got
+	unsigned long timeInIrq;			// How long do we need for interrupt
+	int isocMeasureBandwidthCount;
+	int frame_num;					// How many video frames we send to user
+	int maxStripLen;				// How big is the biggest strip
+	int comprBlockPos;
+	int stripLenErrors;				// How many times was BlockPos greater than StripLen
+	int stripMagicErrors;
+	int stripLineNumberErrors;
+	int ComprBlockTypes[4];
+};
+
+static struct usbvision_v4l_format_st {
+	int		supported;
+	int		bytes_per_pixel;
+	int		depth;
+	int		format;
+	char	*desc;
+} usbvision_v4l_format[] = {
+    { 0 },
+    { 1, 1,  8, VIDEO_PALETTE_GREY   , "GREY" },
+    { 0, 0,  0, VIDEO_PALETTE_HI240  , "HI240" },
+    { 1, 2, 16, VIDEO_PALETTE_RGB565 , "RGB565" },
+    { 1, 3, 24, VIDEO_PALETTE_RGB24  , "RGB24" },
+    { 1, 4, 32, VIDEO_PALETTE_RGB32  , "RGB32" },
+    { 1, 2, 16, VIDEO_PALETTE_RGB555 , "RGB555" },
+    { 1, 2, 16, VIDEO_PALETTE_YUV422 , "YUV422" },
+    { 0, 0,  0, VIDEO_PALETTE_YUYV   , "YUYV" },
+    { 0, 0,  0, VIDEO_PALETTE_UYVY   , "UYVY" },
+    { 0, 0,  0, VIDEO_PALETTE_YUV420 , "YUV420" },
+    { 0, 0,  0, VIDEO_PALETTE_YUV411 , "YUV411" },
+    { 0, 0,  0, VIDEO_PALETTE_RAW    , "RAW" },
+    { 1, 2, 16, VIDEO_PALETTE_YUV422P, "YUV422P" },
+    { 0, 0,  0, VIDEO_PALETTE_YUV411P, "YUV411P" },
+    { 1, 2, 12, VIDEO_PALETTE_YUV420P, "YUV420P" }, // 1.5 !
+    { 0, 0,  0, VIDEO_PALETTE_YUV410P, "YUV410P" },
+    { 0 /* END OF LIST */ },
+};
+#define USBVISION_SUPPORTED_PALETTES 16
+
+#endif									/* __LINUX_USBVISION_H */
+
diff -Naurp linux-2.6.12.orig/drivers/usb/media/usbvision_ioctl.h linux-2.6.12-grml/drivers/usb/media/usbvision_ioctl.h
--- linux-2.6.12.orig/drivers/usb/media/usbvision_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-grml/drivers/usb/media/usbvision_ioctl.h	2005-06-27 17:10:28.506247546 +0200
@@ -0,0 +1,9 @@
+struct usbvision_reg {
+	unsigned char addr;
+	unsigned char value;
+};
+
+#define UVIOCGREG		_IOWR('u',240,struct usbvision_reg)		// get register
+#define UVIOCSREG		_IOW('u',241,struct usbvision_reg)		// set register
+#define UVIOCSVINM		_IOW('u',242,int)						// set usbvision vin_mode
+
