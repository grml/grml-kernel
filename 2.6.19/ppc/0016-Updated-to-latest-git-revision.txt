From db05d649eb1f7bd2f2a2c3d68a347d9d05c68cc9 Mon Sep 17 00:00:00 2001
From: Nicolas DET <nd@bplan-gmbh.de>
Date: Mon, 27 Nov 2006 17:32:14 +0100
Subject: [PATCH] Updated to latest git revision

Signed-off-by: Nicolas DET <nd@bplan-gmbh.de>
---
 drivers/serial/mpc52xx_uart.c |  381 ++++++++++++++++++++++++++++++++++-------
 1 files changed, 316 insertions(+), 65 deletions(-)

diff --git a/drivers/serial/mpc52xx_uart.c b/drivers/serial/mpc52xx_uart.c
index debcd7b..adadf7f 100644
--- a/drivers/serial/mpc52xx_uart.c
+++ b/drivers/serial/mpc52xx_uart.c
@@ -1,4 +1,6 @@
 /*
+ * drivers/serial/mpc52xx_uart.c
+ *
  * Driver for the PSC of the Freescale MPC52xx PSCs configured as UARTs.
  *
  * FIXME According to the usermanual the status bits in the status register
@@ -11,12 +13,12 @@
  * Update: Actually, they seem updated ... At least the bits we use.
  *
  *
- * Maintainer : Sylvain Munaut <tnt@246tNt.com>
- *
  * Some of the code has been inspired/copied from the 2.4 code written
  * by Dale Farnsworth <dfarnsworth@mvista.com>.
  *
- * Copyright (C) 2004-2005 Sylvain Munaut <tnt@246tNt.com>
+ * Copyright (C) 2006 Secret Lab Technologies Ltd.
+ *                    Grant Likely <grant.likely@secretlab.ca>
+ * Copyright (C) 2004-2006 Sylvain Munaut <tnt@246tNt.com>
  * Copyright (C) 2003 MontaVista, Software, Inc.
  *
  * This file is licensed under the terms of the GNU General Public License
@@ -42,8 +44,24 @@
  * will be mapped to.
  */
 
+/* OF Platform device Usage :
+ *
+ * This driver is only used for PSCs configured in uart mode.  The device
+ * tree will have a node for each PSC in uart mode w/ device_type = "serial"
+ * and "mpc52xx-psc-uart" in the compatible string
+ *
+ * By default, PSC devices are enumerated in the order they are found.  However
+ * a particular PSC number can be forces by adding 'device_no = <port#>'
+ * to the device node.
+ *
+ * The driver init all necessary registers to place the PSC in uart mode without
+ * DCD. However, the pin multiplexing aren't changed and should be set either
+ * by the bootloader or in the platform init code.
+ */
+
 #define DEBUG
 
+#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/tty.h>
 #include <linux/serial.h>
@@ -52,8 +70,12 @@ #include <linux/console.h>
 
 #include <asm/delay.h>
 #include <asm/io.h>
-#include <asm/of_device.h>
+
+#if defined(CONFIG_PPC_MERGE)
 #include <asm/of_platform.h>
+#else
+#include <linux/platform_device.h>
+#endif
 
 #include <asm/mpc52xx.h>
 #include <asm/mpc52xx_psc.h>
@@ -81,6 +103,12 @@ static struct uart_port mpc52xx_uart_por
 	 *        it's cleared, then a memset(...,0,...) should be added to
 	 *        the console_init
 	 */
+#if defined(CONFIG_PPC_MERGE)
+/* lookup table for matching device nodes to index numbers */
+static struct device_node *mpc52xx_uart_nodes[MPC52xx_PSC_MAXNUM];
+
+static void mpc52xx_uart_of_enumerate(void);
+#endif
 
 #define PSC(port) ((struct mpc52xx_psc __iomem *)((port)->membase))
 
@@ -97,17 +125,14 @@ #else
 #define uart_console(port)	(0)
 #endif
 
-static struct of_device_id mpc52xx_uart_match[] = {
-	{
-		.type = "serial",
-		.compatible = "mpc52xx-psc-uart",
-	},
-	{
-		.type = "serial",
-		.compatible = "mpc5200-psc",
-	},	
+#if defined(CONFIG_PPC_MERGE)
+static struct of_device_id mpc52xx_uart_of_match[] = {
+	{ .type = "serial", .compatible = "mpc52xx-psc-uart", },
+	{ .type = "serial", .compatible = "mpc5200-psc", }, /* Efika only! */
 	{},
 };
+#endif
+
 
 /* ======================================================================== */
 /* UART operations                                                          */
@@ -386,7 +411,7 @@ mpc52xx_uart_verify_port(struct uart_por
 
 	if ( (ser->irq != port->irq) ||
 	     (ser->io_type != SERIAL_IO_MEM) ||
-	     (ser->baud_base != port->uartclk) ||
+	     (ser->baud_base != port->uartclk)  ||
 	     (ser->iomem_base != (void*)port->mapbase) ||
 	     (ser->hub6 != 0 ) )
 		return -EINVAL;
@@ -577,12 +602,17 @@ mpc52xx_console_get_options(struct uart_
 	unsigned char mr1;
 
 	pr_debug("mpc52xx_console_get_options(port=%p)\n", port);
+
 	/* Read the mode registers */
 	out_8(&psc->command,MPC52xx_PSC_SEL_MODE_REG_1);
 	mr1 = in_8(&psc->mode);
 
 	/* CT{U,L}R are write-only ! */
 	*baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;
+#if !defined(CONFIG_PPC_MERGE)
+	if (__res.bi_baudrate)
+		*baud = __res.bi_baudrate;
+#endif
 
 	/* Parse them */
 	switch (mr1 & MPC52xx_PSC_MODE_BITS_MASK) {
@@ -619,10 +649,10 @@ mpc52xx_console_write(struct console *co
 	for (i = 0; i < count; i++, s++) {
 		/* Line return handling */
 		if (*s == '\n')
-			out_8(&psc->buffer.buffer_8, '\r');
+			out_8(&psc->mpc52xx_psc_buffer_8, '\r');
 
 		/* Send the char */
-		out_8(&psc->buffer.buffer_8, *s);
+		out_8(&psc->mpc52xx_psc_buffer_8, *s);
 
 		/* Wait the TX buffer to be empty */
 		j = 20000;	/* Maximum wait */
@@ -635,16 +665,50 @@ mpc52xx_console_write(struct console *co
 	out_be16(&psc->mpc52xx_psc_imr, port->read_status_mask);
 }
 
+#if !defined(CONFIG_PPC_MERGE)
 static int __init
 mpc52xx_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port = &mpc52xx_uart_ports[co->index];
-	struct device_node *np = NULL;
-	const struct of_device_id *dev_id = NULL;
-	struct device_node *np_idx;
-	const void *pp = NULL;
+
+	int baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index < 0 || co->index >= MPC52xx_PSC_MAXNUM)
+		return -EINVAL;
+
+	/* Basic port init. Needed since we use some uart_??? func before
+	 * real init for early access */
+	spin_lock_init(&port->lock);
+	port->uartclk	= __res.bi_ipbfreq / 2; /* Look at CTLR doc */
+	port->ops	= &mpc52xx_uart_ops;
+	port->mapbase	= MPC52xx_PA(MPC52xx_PSCx_OFFSET(co->index+1));
+
+	/* We ioremap ourself */
+	port->membase = ioremap(port->mapbase, MPC52xx_PSC_SIZE);
+	if (port->membase == NULL)
+		return -EINVAL;
+
+	/* Setup the port parameters accoding to options */
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		mpc52xx_console_get_options(port, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+#else
+
+static int __init
+mpc52xx_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = &mpc52xx_uart_ports[co->index];
+	struct device_node *np = mpc52xx_uart_nodes[co->index];
+	unsigned int ipb_freq;
 	struct resource res;
-	int index = 0;
 	int ret;
 
 	int baud = CONFIG_SERIAL_MPC52xx_CONSOLE_BAUD;
@@ -652,44 +716,38 @@ mpc52xx_console_setup(struct console *co
 	int parity = 'n';
 	int flow = 'n';
 
-	pr_debug("mpc52xx_console_setup co=%p, options=%s, index=%i\n",
-		 co, options, co->index);
+	pr_debug("mpc52xx_console_setup co=%p, co->index=%i, options=%s\n",
+		 co, co->index, options);
 
-	for_each_node_by_type(np, "serial")
-	{
-		dev_id = of_match_node(mpc52xx_uart_match, np);
-		if (dev_id)
-			if (index++ == co->index)
-				break;
+	if ((co->index < 0) || (co->index > MPC52xx_PSC_MAXNUM)) {
+		pr_debug("PSC%x out of range\n", co->index);
+		return -EINVAL;
 	}
- 
+
 	if (!np) {
 		pr_debug("PSC%x not found in device tree\n", co->index);
 		return -EINVAL;
 	}
 
+	pr_debug("Console on ttyPSC%x is %s\n",
+	         co->index, mpc52xx_uart_nodes[co->index]->full_name);
+
 	/* Fetch register locations */
 	if ((ret = of_address_to_resource(np, 0, &res)) != 0) {
-		pr_debug("Could not get resources for PSC%x\n", index);
+		pr_debug("Could not get resources for PSC%x\n", co->index);
 		return ret;
 	}
 
 	/* Search for bus-frequency property in this node or a parent */
-	np_idx = np;
-	while (np_idx) {
-		if ((pp = get_property(np_idx, "bus-frequency", NULL)) != NULL)
-			break;
-		np_idx = of_get_parent(np_idx);
-	}
-	if (!pp) {
-		pr_debug("Could not find bus-frequency property!\n");
+	if ((ipb_freq = mpc52xx_find_ipb_freq(np)) == 0) {
+		pr_debug("Could not find IPB bus frequency!\n");
 		return -EINVAL;
 	}
 
 	/* Basic port init. Needed since we use some uart_??? func before
 	 * real init for early access */
 	spin_lock_init(&port->lock);
-	port->uartclk	= *(const u32*)pp / 2;
+	port->uartclk	= ipb_freq / 2;
 	port->ops	= &mpc52xx_uart_ops;
 	port->mapbase = res.start;
 	port->membase = ioremap(res.start, sizeof(struct mpc52xx_psc));
@@ -698,7 +756,7 @@ mpc52xx_console_setup(struct console *co
 	if (port->membase == NULL)
 		return -EINVAL;
 
-	pr_debug("mpc52xx_psc at %lx mapped to %p; irq=%x freq=%i\n",
+	pr_debug("mpc52xx-psc uart at %lx, mapped to %p, irq=%x, freq=%i\n",
 	         port->mapbase, port->membase, port->irq, port->uartclk);
 
 	/* Setup the port parameters accoding to options */
@@ -712,6 +770,7 @@ mpc52xx_console_setup(struct console *co
 
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
+#endif /* defined(CONFIG_PPC_MERGE) */
 
 
 static struct uart_driver mpc52xx_uart_driver;
@@ -730,6 +789,7 @@ static struct console mpc52xx_console =
 static int __init
 mpc52xx_console_init(void)
 {
+	mpc52xx_uart_of_enumerate();
 	register_console(&mpc52xx_console);
 	return 0;
 }
@@ -757,14 +817,120 @@ static struct uart_driver mpc52xx_uart_d
 };
 
 
+#if !defined(CONFIG_PPC_MERGE)
 /* ======================================================================== */
 /* Platform Driver                                                          */
 /* ======================================================================== */
 
 static int __devinit
-mpc52xx_uart_probe(struct of_device *op, const struct of_device_id *match)
+mpc52xx_uart_probe(struct platform_device *dev)
 {
-	static int idx = 0;
+	struct resource *res = dev->resource;
+
+	struct uart_port *port = NULL;
+	int i, idx, ret;
+
+	/* Check validity & presence */
+	idx = dev->id;
+	if (idx < 0 || idx >= MPC52xx_PSC_MAXNUM)
+		return -EINVAL;
+
+	if (!mpc52xx_match_psc_function(idx,"uart"))
+		return -ENODEV;
+
+	/* Init the port structure */
+	port = &mpc52xx_uart_ports[idx];
+
+	spin_lock_init(&port->lock);
+	port->uartclk	= __res.bi_ipbfreq / 2; /* Look at CTLR doc */
+	port->fifosize	= 512;
+	port->iotype	= UPIO_MEM;
+	port->flags	= UPF_BOOT_AUTOCONF |
+			  ( uart_console(port) ? 0 : UPF_IOREMAP );
+	port->line	= idx;
+	port->ops	= &mpc52xx_uart_ops;
+	port->dev	= &dev->dev;
+
+	/* Search for IRQ and mapbase */
+	for (i=0 ; i<dev->num_resources ; i++, res++) {
+		if (res->flags & IORESOURCE_MEM)
+			port->mapbase = res->start;
+		else if (res->flags & IORESOURCE_IRQ)
+			port->irq = res->start;
+	}
+	if (!port->irq || !port->mapbase)
+		return -EINVAL;
+
+	/* Add the port to the uart sub-system */
+	ret = uart_add_one_port(&mpc52xx_uart_driver, port);
+	if (!ret)
+		platform_set_drvdata(dev, (void*)port);
+
+	return ret;
+}
+
+static int
+mpc52xx_uart_remove(struct platform_device *dev)
+{
+	struct uart_port *port = (struct uart_port *) platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	if (port)
+		uart_remove_one_port(&mpc52xx_uart_driver, port);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int
+mpc52xx_uart_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uart_port *port = (struct uart_port *) platform_get_drvdata(dev);
+
+	if (port)
+		uart_suspend_port(&mpc52xx_uart_driver, port);
+
+	return 0;
+}
+
+static int
+mpc52xx_uart_resume(struct platform_device *dev)
+{
+	struct uart_port *port = (struct uart_port *) platform_get_drvdata(dev);
+
+	if (port)
+		uart_resume_port(&mpc52xx_uart_driver, port);
+
+	return 0;
+}
+#endif
+
+
+static struct platform_driver mpc52xx_uart_platform_driver = {
+	.probe		= mpc52xx_uart_probe,
+	.remove		= mpc52xx_uart_remove,
+#ifdef CONFIG_PM
+	.suspend	= mpc52xx_uart_suspend,
+	.resume		= mpc52xx_uart_resume,
+#endif
+	.driver		= {
+		.name	= "mpc52xx-psc",
+	},
+};
+#endif /* !defined(CONFIG_PPC_MERGE) */
+
+
+#if defined(CONFIG_PPC_MERGE)
+/* ======================================================================== */
+/* OF Platform Driver                                                       */
+/* ======================================================================== */
+
+static int __devinit
+mpc52xx_uart_of_probe(struct of_device *op, const struct of_device_id *match)
+{
+	int idx = -1;
+	unsigned int ipb_freq;
 	struct uart_port *port = NULL;
 	struct resource res;
 	int ret;
@@ -772,33 +938,44 @@ mpc52xx_uart_probe(struct of_device *op,
 	dev_dbg(&op->dev, "mpc52xx_uart_probe(op=%p, match=%p)\n", op, match);
 
 	/* Check validity & presence */
+	for (idx = 0; idx < MPC52xx_PSC_MAXNUM; idx++)
+		if (mpc52xx_uart_nodes[idx] == op->node)
+			break;
 	if (idx >= MPC52xx_PSC_MAXNUM)
 		return -EINVAL;
+	pr_debug("Found %s assigned to ttyPSC%x\n",
+	         mpc52xx_uart_nodes[idx]->full_name, idx);
+
+	/* Search for bus-frequency property in this node or a parent */
+	if ((ipb_freq = mpc52xx_find_ipb_freq(op->node)) == 0) {
+		dev_dbg(&op->dev, "Could not find IPB bus frequency!\n");
+		return -EINVAL;
+	}
 
 	/* Init the port structure */
 	port = &mpc52xx_uart_ports[idx];
 
 	spin_lock_init(&port->lock);
+	port->uartclk	= ipb_freq / 2;
 	port->fifosize	= 512;
 	port->iotype	= UPIO_MEM;
 	port->flags	= UPF_BOOT_AUTOCONF |
 			  ( uart_console(port) ? 0 : UPF_IOREMAP );
 	port->line	= idx;
 	port->ops	= &mpc52xx_uart_ops;
+	port->dev	= &op->dev;
 
 	/* Search for IRQ and mapbase */
 	if ((ret = of_address_to_resource(op->node, 0, &res)) != 0)
 		return ret;
 
 	port->mapbase = res.start;
-	port->membase = ioremap(res.start, sizeof(struct mpc52xx_psc));
 	port->irq = irq_of_parse_and_map(op->node, 0);
 
-	dev_dbg(&op->dev, "mpc52xx-psc UART at %lx. mapped to %p, irq %x\n",
-	         port->mapbase, port->membase, port->irq);
+	dev_dbg(&op->dev, "mpc52xx-psc uart at %lx, irq=%x, freq=%i\n",
+	        port->mapbase, port->irq, port->uartclk);
 
-	//if (!port->irq || !port->mapbase) {
-	if (!port->mapbase) {
+	if ((port->irq==NO_IRQ) || !port->mapbase) {
 		printk(KERN_ERR "Could not allocate resources for PSC\n");
 		return -EINVAL;
 	}
@@ -808,12 +985,11 @@ mpc52xx_uart_probe(struct of_device *op,
 	if (!ret)
 		dev_set_drvdata(&op->dev, (void*)port);
 
-	idx++;
 	return ret;
 }
 
 static int
-mpc52xx_uart_remove(struct of_device *op)
+mpc52xx_uart_of_remove(struct of_device *op)
 {
 	struct uart_port *port = dev_get_drvdata(&op->dev);
 	dev_set_drvdata(&op->dev, NULL);
@@ -826,7 +1002,7 @@ mpc52xx_uart_remove(struct of_device *op
 
 #ifdef CONFIG_PM
 static int
-mpc52xx_uart_suspend(struct of_device *op, pm_message_t state)
+mpc52xx_uart_of_suspend(struct of_device *op, pm_message_t state)
 {
 	struct uart_port *port = (struct uart_port *) dev_get_drvdata(&op->dev);
 
@@ -837,7 +1013,7 @@ mpc52xx_uart_suspend(struct of_device *o
 }
 
 static int
-mpc52xx_uart_resume(struct of_device *op)
+mpc52xx_uart_of_resume(struct of_device *op)
 {
 	struct uart_port *port = (struct uart_port *) dev_get_drvdata(&op->dev);
 
@@ -848,46 +1024,116 @@ mpc52xx_uart_resume(struct of_device *op
 }
 #endif
 
+static void
+mpc52xx_uart_of_assign(struct device_node *np, int idx)
+{
+	int free_idx = -1;
+	int i;
+
+	/* Find the first free node */
+	for (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {
+		if (mpc52xx_uart_nodes[i] == NULL) {
+			free_idx = i;
+			break;
+		}
+	}
+
+	if ((idx < 0) || (idx >= MPC52xx_PSC_MAXNUM))
+		idx = free_idx;
+
+	if (idx < 0)
+		return; /* No free slot; abort */
+
+	/* If the slot is already occupied, then swap slots */
+	if (mpc52xx_uart_nodes[idx] && (free_idx != -1))
+		mpc52xx_uart_nodes[free_idx] = mpc52xx_uart_nodes[idx];
+	mpc52xx_uart_nodes[i] = np;
+}
+
+static void
+mpc52xx_uart_of_enumerate(void)
+{
+	static int enum_done = 0;
+	struct device_node *np;
+	const unsigned int *devno;
+	int i;
+
+	if (enum_done)
+		return;
+
+	for_each_node_by_type(np, "serial") {
+		if (!of_match_node(mpc52xx_uart_of_match, np))
+			continue;
+
+		/* Is a particular device number requested? */
+		devno = get_property(np, "device_no", NULL);
+		mpc52xx_uart_of_assign(of_node_get(np), devno ? *devno : -1);
+	}
 
-MODULE_DEVICE_TABLE(of, mpc52xx_uart_match);
+	enum_done = 1;
+
+	for (i = 0; i < MPC52xx_PSC_MAXNUM; i++) {
+		if (mpc52xx_uart_nodes[i])
+			pr_debug("%s assigned to ttyPSC%x\n",
+			         mpc52xx_uart_nodes[i]->full_name, i);
+	}
+}
+
+MODULE_DEVICE_TABLE(of, mpc52xx_uart_of_match);
 
 static struct of_platform_driver mpc52xx_uart_of_driver = {
 	.owner		= THIS_MODULE,
-	.name		= "mpc52xx-uart",
-	.match_table	= mpc52xx_uart_match,
-	.probe		= mpc52xx_uart_probe,
-	.remove		= mpc52xx_uart_remove,
+	.name		= "mpc52xx-psc-uart",
+	.match_table	= mpc52xx_uart_of_match,
+	.probe		= mpc52xx_uart_of_probe,
+	.remove		= mpc52xx_uart_of_remove,
 #ifdef CONFIG_PM
-	.suspend	= mpc52xx_uart_suspend,
-	.resume		= mpc52xx_uart_resume,
+	.suspend	= mpc52xx_uart_of_suspend,
+	.resume		= mpc52xx_uart_of_resume,
 #endif
 	.driver		= {
-		.name	= "mpc52xx-psc",
+		.name	= "mpc52xx-psc-uart",
 	},
 };
+#endif /* defined(CONFIG_PPC_MERGE) */
 
 
 /* ======================================================================== */
 /* Module                                                                   */
- /* ======================================================================== */
+/* ======================================================================== */
 
 static int __init
 mpc52xx_uart_init(void)
 {
 	int ret;
 
-	printk(KERN_INFO "Serial: MPC52xx PSC driver\n");
+	printk(KERN_INFO "Serial: MPC52xx PSC UART driver\n");
 
 	if ((ret = uart_register_driver(&mpc52xx_uart_driver)) != 0) {
-		printk(KERN_ERR "Could not register mpc52xx uart driver\n");
+		printk(KERN_ERR "%s: uart_register_driver failed (%i)\n",
+		       __FILE__, ret);
 		return ret;
 	}
 
-	if ((ret = of_register_platform_driver(&mpc52xx_uart_of_driver)) != 0) {
-		printk(KERN_ERR "Could not register mpc52xx of driver\n");
+#if defined(CONFIG_PPC_MERGE)
+	mpc52xx_uart_of_enumerate();
+
+	ret = of_register_platform_driver(&mpc52xx_uart_of_driver);
+	if (ret) {
+		printk(KERN_ERR "%s: of_register_platform_driver failed (%i)\n",
+		       __FILE__, ret);
 		uart_unregister_driver(&mpc52xx_uart_driver);
 		return ret;
 	}
+#else
+	ret = platform_driver_register(&mpc52xx_uart_platform_driver);
+	if (ret) {
+		printk(KERN_ERR "%s: platform_driver_register failed (%i)\n",
+		       __FILE__, ret);
+		uart_unregister_driver(&mpc52xx_uart_driver);
+		return ret;
+	}
+#endif
 
 	return 0;
 }
@@ -895,7 +1141,11 @@ mpc52xx_uart_init(void)
 static void __exit
 mpc52xx_uart_exit(void)
 {
+#if defined(CONFIG_PPC_MERGE)
 	of_unregister_platform_driver(&mpc52xx_uart_of_driver);
+#else
+	platform_driver_unregister(&mpc52xx_uart_platform_driver);
+#endif
 	uart_unregister_driver(&mpc52xx_uart_driver);
 }
 
@@ -906,3 +1156,4 @@ module_exit(mpc52xx_uart_exit);
 MODULE_AUTHOR("Sylvain Munaut <tnt@246tNt.com>");
 MODULE_DESCRIPTION("Freescale MPC52xx PSC UART");
 MODULE_LICENSE("GPL");
+
-- 
1.4.3.2

