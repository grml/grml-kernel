GIT 1e56c106f0879872f6f2426b533ca5bfb712bb5b git+ssh://master.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6.git

commit 1e56c106f0879872f6f2426b533ca5bfb712bb5b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 20 21:58:30 2007 +0200

    firewire: fw-ohci: log posted write errors
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 95ea4f3877086febb49111950c88c0346debf21d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 20 21:41:22 2007 +0200

    firewire: fw-ohci: reorder includes
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 48b797fa451d57b34270a0a8b839ad6fc1e42840
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 20 21:40:30 2007 +0200

    firewire: fw-ohci: fix includes
    
    Add used includes, remove unused includes.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ff8a2c410630d25bbc53ae82f76001993a6af023
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 25 14:08:19 2007 +0200

    firewire: fw-ohci: enforce read order for selfID generation
    
    It seems unlikely, but access to self_id_cpu[0] could at least in theory
    be deferred until after the loop over self_id_cpu[1..n] or even after
    the subsequent reg_read.  Enforce the desired order by a read barrier.
    
    Also prevent the reg_read from being reordered relative to the for loop.
    This isn't necessary if the loop's conditional printk counts as an
    implicit barrier, but better make it explicit.
    
    (self_id_cpu[] is a coherent DMA buffer.)
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 6c314f0edf49fece250382e2220e65960b5bbe21
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Aug 12 12:51:18 2007 +0200

    firewire: fw-sbp2: use an own workqueue (fix system responsiveness)
    
    Firewire-sbp2 did very uncooperative things in the kernel's shared
    workqueue:  Sleeping until reception of management status from the
    target for up to 2 seconds, and performing SCSI inquiry and all of the
    setup of SCSI command set drivers via scsi_add_device.  If there were
    transient or permanent error conditions, this caused long blockage of
    the kernel's events process, noticeable e.g. by blocked keyboard input.
    
    We now allocate a workqueue process exclusive to fw-sbp2.  As a side
    effect, this also increases parallelism of fw-sbp2's login and reconnect
    work versus fw-core's device discovery and device update work which is
    performed in the shared workqueue.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Kristian Høgsberg <krh@redhat.com>

commit 3f9d5a5152a1561c2fb80445227374c07dbce842
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Aug 13 17:48:25 2007 +0200

    firewire: fw-sbp2: expose module parameter for workarounds
    
    On rare occasions, the ability to set one of the workaround flags at
    runtime may save the day.
    
    People who experience I/O errors with firewire-sbp2 while the old sbp2
    driver worked for them should try workarounds=1 and report to the devel
    mailinglist whether that improves things.  Firewire-sbp2 defaults to the
    SCSI stack's maximum transfer size per command, while sbp2 limits them
    to 128 kBytes.  Flag 1 accomplishes just that.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 07fcbcaf01d69a8ce20e6b9722a72f0943bca9d3
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 25 14:05:28 2007 +0200

    firewire: fw-sbp2: add support for multiple logical units per target
    
    Fixes "New firewire stack only recognizing half of a chain of drives",
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=242254
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ec8d5dc0e1967445964298c07612215c9b1ddd6e
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 25 10:40:42 2007 +0200

    firewire: fw-sbp2: always enable IRQs before calling command ORB callback
    
    On IOMMU-less noncoherent architectures, orb->callback will memcpy the
    whole SCSI command buffer for READ-like SCSI commands.  It is therefore
    friendlier to enable IRQs before the call, like before patch "Add
    ref-counting for sbp2 orbs".
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ba57dc0ea32c276cd07c83993b99546be862c699
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Aug 3 20:56:31 2007 +0200

    firewire: fw-core: local variable shadows a global one
    
    Sparse warned about it although it was apparently harmless:
    
    drivers/firewire/fw-cdev.c:624:23: warning: symbol 'interrupt' shadows an earlier one
    include/asm/hw_irq.h:29:13: originally declared here
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit c5cf4a73611a91c91f0761596d19a37d772d2182
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jul 17 02:10:16 2007 +0200

    firewire: optimize fw_core_add_address_handler
    
    Potentially avoids unnecessary loop runs.
    Guarantee quadlet-aligned starts of address regions.
    Document the return values.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 3743cc44c82342e744aa564f27c3e1fdd74ba3d0
Author: Kristian Høgsberg <krh@redhat.com>
Date:   Tue Jun 5 19:27:05 2007 -0400

    firewire: Fix pci resume to not pass in a __be32 config rom.
    
    The ohci_enable() function shared between pci_probe and pci_resume
    takes a host endian config rom, but ohci->config_rom is __be32.  This
    sets up the config rom in the wrong endian on little endian machine,
    specifically, BusOptions will be initialized to a 0 max receive size.
    
    This patch changes the way we reuse the config rom so that we avoid
    this problem.
    
    Signed-off-by: Kristian Hoegsberg <krh@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 6dc2aad465cc074bbe68e2e84b89a22428dc80c3
Author: Satyam Sharma <satyam@infradead.org>
Date:   Wed Aug 15 20:05:38 2007 +0530

    ieee1394: Fix kthread stopping in nodemgr_host_thread
    
    The nodemgr host thread can exit on its own even when kthread_should_stop
    is not true, on receiving a signal (might never happen in practice, as
    it ignores signals). But considering kthread_stop() must not be mixed with
    kthreads that can exit on their own, I think changing the code like this
    is clearer. This change means the thread can cut its sleep short when
    receive a signal but looking at the code around, that sounds okay (and
    again, it might never actually recieve a signal in practice).
    
    Signed-off-by: Satyam Sharma <satyam@infradead.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 20b5cd8637514b6f5b4961a4360013ad519432eb
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 11 11:52:08 2007 +0200

    ieee1394: sbp2: fix unsafe iteration over list of devices
    
    sbp2_host_reset and sbp2_handle_status_write are not serialized against
    sbp2_alloc_device and sbp2_remove_device.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit bca76d2f599125f169375e4a7300e8c22532f75a
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 00:01:35 2007 +0200

    ieee1394: pcilynx: superfluous local variables
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit b8ebfcfe1499644b7bd0144ddb4c3ef5362f617c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 28 23:45:03 2007 +0200

    ieee1394: eth1394: fix lock imbalance
    
    bad_proto can be reached from points which did not take priv->lock.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 2f2bda15d415132132517e242442367b33ca0890
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 28 23:44:25 2007 +0200

    ieee1394: eth1394: superfluous local variable
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 5ac0464c61124914166e260404f1b9b98f5decb7
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 25 17:27:14 2007 +0200

    roll back to origin

commit 6ed8a4627fbbc94d8176d31470054a566b43c4d0
Author: Satyam Sharma <satyam@infradead.org>
Date:   Wed Aug 15 20:05:38 2007 +0530

    ieee1394: Fix kthread stopping in nodemgr_host_thread
    
    The nodemgr host thread can exit on its own even when kthread_should_stop
    is not true, on receiving a signal (might never happen in practice, as
    it ignores signals). But considering kthread_stop() must not be mixed with
    kthreads that can exit on their own, I think changing the code like this
    is clearer. This change means the thread can cut its sleep short when
    receive a signal but looking at the code around, that sounds okay (and
    again, it might never actually recieve a signal in practice).
    
    Signed-off-by: Satyam Sharma <satyam@infradead.org>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 585e9c455ac48003d932c2ed8f0c06106b8ee123
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Aug 15 21:44:51 2007 +0200

    firewire: fw-sbp2: expose module parameter for workarounds, amendment
    
    Reduce nesting depth.  Will be rolled into
    549b7b036d091a114ccfbc5e90b39970df54b5a3 when pushed upstream.

commit 98e0b80c3369bf3e415a503d0705edc5eadd4742
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Aug 12 12:51:18 2007 +0200

    firewire: fw-sbp2: use an own workqueue (fix system responsiveness)
    
    Firewire-sbp2 did very uncooperative things in the kernel's shared
    workqueue:  Sleeping until reception of management status from the
    target for up to 2 seconds, and performing SCSI inquiry and all of the
    setup of SCSI command set drivers via scsi_add_device.  If there were
    transient or permanent error conditions, this caused long blockage of
    the kernel's events process, noticeable e.g. by blocked keyboard input.
    
    We now allocate a workqueue process exclusive to fw-sbp2.  As a side
    effect, this also increases parallelism of fw-sbp2's login and reconnect
    work versus fw-core's device discovery and device update work which is
    performed in the shared workqueue.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 549b7b036d091a114ccfbc5e90b39970df54b5a3
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Aug 12 12:51:18 2007 +0200

    firewire: fw-sbp2: expose module parameter for workarounds
    
    On rare occasions, the ability to set one of the workaround flags at
    runtime may save the day.
    
    People who experience I/O errors with firewire-sbp2 while the old sbp2
    driver worked for them should try workarounds=1 and report to the devel
    mailinglist whether that improves things.  Firewire-sbp2 defaults to the
    SCSI stack's maximum transfer size per command, while sbp2 limits them
    to 128 kBytes.  Flag 1 accomplishes just that.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit b911abe15da18ba4fe4a40239dadd2dcf9dcf705
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 11 11:52:08 2007 +0200

    ieee1394: sbp2: fix unsafe iteration over list of devices
    
    sbp2_host_reset and sbp2_handle_status_write are not serialized against
    sbp2_alloc_device and sbp2_remove_device.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 3cdafc2494f6d07a974c6566d7a0c34fdb6027a8
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 11 11:51:16 2007 +0200

    ieee1394: sbp2: fix sbp2_remove_device for error cases
    
    Bug found by Olaf Hering <olh@suse.de>:
    sbp2util_remove_command_orb_pool requires a valid lu->hi pointer.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ce72b81c6049f0969832ff3f604f12ddd9d68cd4
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Aug 12 13:20:25 2007 +0200

    firewire: fw-sbp2: add support for multiple logical units per target, amendment
    
    Keep printing firmware_revision in dmesg, rather than
    firmware_revision & 0xffffff00.
    
    Will be rolled into the previous commit when pushed upstream.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 9166079a38d292f45ba59fe293c1ffaf11d0d56f
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 4 15:54:58 2007 +0200

    firewire: fw-sbp2: add support for multiple logical units per target
    
    Fixes "New firewire stack only recognizing half of a chain of drives",
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=242254
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 24f667e69f9493bfc09398d9149d998cf329afe9
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jul 17 02:10:16 2007 +0200

    firewire: optimize fw_core_add_address_handler
    
    Potentially avoids unnecessary loop runs.
    Guarantee quadlet-aligned starts of address regions.
    Document the return values.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 12a2f56154610b63d06fe902db0783ceb44bcc4e
Author: Kristian Høgsberg <krh@redhat.com>
Date:   Tue Jun 5 19:27:05 2007 -0400

    firewire: Fix pci resume to not pass in a __be32 config rom.
    
    The ohci_enable() function shared between pci_probe and pci_resume
    takes a host endian config rom, but ohci->config_rom is __be32.  This
    sets up the config rom in the wrong endian on little endian machine,
    specifically, BusOptions will be initialized to a 0 max receive size.
    
    This patch changes the way we reuse the config rom so that we avoid
    this problem.
    
    Signed-off-by: Kristian Hoegsberg <krh@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit bad1bfb50d0f13d1f07f9973517a898a5e192e3d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Aug 3 20:56:31 2007 +0200

    firewire: fw-core: local variable shadows a global one
    
    Sparse warned about it although it was apparently harmless:
    
    drivers/firewire/fw-cdev.c:624:23: warning: symbol 'interrupt' shadows an earlier one
    include/asm/hw_irq.h:29:13: originally declared here
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit da9f857d30b890ff9d22bab72baf653d4875236f
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 4 19:07:42 2007 +0200

    roll back last firewire commits

commit 619111d849ac2ef32123f71eb9af71b39a465c9a
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Aug 2 20:13:13 2007 +0200

    Revert "firewire: fw-core: shrink the init function"
    
    This reverts commit a2354f71f88568c2fb295664c6a80d89b93324bb.

commit 6ad42edd81e948e2f3278d0d3e5f4a36f83eca3c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Aug 1 20:30:36 2007 +0200

    ieee1394: revert "sbp2: enforce 32bit DMA mapping"
    
    Revert commit 0555659d63c285ceb7ead3115532e1b71b0f27a7 from 2.6.22-rc1.
    The dma_set_mask call somehow failed on a PowerMac G5, PPC64:
    http://lkml.org/lkml/2007/8/1/344
    
    Should there ever occur a DMA mapping beyond the physical DMA range, a
    proper SBP-2 firmware will report transport errors.  So let's leave it
    at that.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Olaf Hering <olh@suse.de>

commit a3d08165feaefb8bd5b294d5f464e30b904566a0
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 00:01:35 2007 +0200

    ieee1394: pcilynx: superfluous local variables
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 05495f9042c5aeed5d17f29531bc637e75c399f0
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 28 23:45:03 2007 +0200

    ieee1394: eth1394: fix lock imbalance
    
    bad_proto can be reached from points which did not take priv->lock.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 9fc5fd1a634bf3ddb2bfc077b341d044e2b666de
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 28 23:44:25 2007 +0200

    ieee1394: eth1394: superfluous local variable
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit a2354f71f88568c2fb295664c6a80d89b93324bb
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 20:40:04 2007 +0200

    firewire: fw-core: shrink the init function
    
    by 208 bytes on x86-64, 112 bytes on i586.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 52c32d15ad031b8a3d8e5e119792609a6721d47d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 20:40:04 2007 +0200

    firewire: fw-core: make two variables static
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ab0f04efa6fa31b485424e28a3661ce764194367
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 26 01:43:40 2007 +0200

    firewire: fw-sbp2: remove some log messages
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ed6a36016077d831b92f8a775f340a96aa4960f5
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 19:40:07 2007 +0200

    firewire: fw-sbp2: add support for multiple logical units per target
    
    This makes multiple logical units on a single target accessible to
    fw-sbp2.  Successfully tested with the IOI FWB-IDE01AB dual LU bridge.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit a8b974f5e01aba031a767a28616d439bb5be94cd
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 03:04:15 2007 +0200

    firewire: fw-sbp2: split logical unit data from target data
    
    struct sbp2_device is replaced by struct sbp2_target and struct
    sbp2_logical_unit.  This prepares support of multiple logical units per
    target.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit a2fb3f0b42e9d0012fe0036b8f8d4371ba4b858b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 03:03:07 2007 +0200

    firewire: fw-sbp2: use one Scsi_Host for all targets
    
    This rework prepares support of multiple logical units per target.
    Instead of one instance of struct Scsi_Host per target, only one
    Scsi_Host global to fw-sbp2 is now used.  We could also use one
    Scsi_Host per FireWire host, but that would add more overhead for no
    real benefit.
    
    The following user-visible changes result:
    
      - The generic device of the Scsi_Host is registered as a platform
        device.  Hence it and the target devices and logical unit devices
        will be sitting below /sys/devices/platform/host*/ rather than
        within the PCI devices tree.
    
      - In the SCSI stack's H:C:T:L tuple, the H is now constant for all
        fw-sbp2 devices but the T is unique.  We currently allocate T as
        stupidly as the H was allocated before:  It is simply increased
        whenever a target is added.
    
    Neither of these changes should affect userspace, because none of the
    mentioned device properties have been of any interest to userspace
    before.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 1fbbb13a05fdc8cf8e778aa834d2e31e68193ee4
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 26 01:38:39 2007 +0200

    firewire: remove unused macros
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit d9b6313c4d390dc6f4388c07d40ce0d606258458
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 29 01:50:37 2007 +0200

    firewire: fw-sbp2: sanitize list handling
    
      - The ORB list iteration unsafely removed list items under itself.
    
      - The "ORB found" logic relied on implementation details of
        list_for_each_entry and was unreadable.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 644f24f97935b8de286eb6f6e6a2e67251958ce0
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Jul 25 19:18:08 2007 +0200

    firewire: fw-ohci: dma_free_coherent needs IRQs enabled
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 5b402b97b6f98823f5950ca61d850f552ff042c9
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 21 22:43:05 2007 +0200

    firewire: fw-sbp2: set correct maximum payload (fixes CardBus adapters)
    
    As far as I know, all CardBus FireWire 400 adapters have a maximum
    payload of 1024 bytes which is less than the speed-dependent limit of
    2048 bytes.  Fw-sbp2 has to take the host adapter's limit into account.
    
    This apparently fixes Juju's incompatibility with my CardBus cards, a
    NEC based card and a VIA based card.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 4e7210a2d7eac65134bcb340bd3814e5adba2c1d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jul 21 17:51:22 2007 +0200

    ieee1394: sbp2: more correct Kconfig dependencies
    
    Make the option SBP2_PHYS_DMA available on all architectures where it
    compiles.  This includes x86-64 where I runtime-tested it successfully.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit 62d8f1e2e8efadb6d8f7d9c802adebef98c0081e
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jul 17 02:10:16 2007 +0200

    firewire: optimize fw_core_add_address_handler
    
    Potentially avoids unnecessary loop runs.
    Guarantee quadlet-aligned starts of address regions.
    Document the return values.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

commit ccfab837384b2f125a2d1c179caf70032cbaecc8
Author: Kristian Høgsberg <krh@redhat.com>
Date:   Tue Jun 5 19:27:05 2007 -0400

    firewire: Fix pci resume to not pass in a __be32 config rom.
    
    The ohci_enable() function shared between pci_probe and pci_resume
    takes a host endian config rom, but ohci->config_rom is __be32.  This
    sets up the config rom in the wrong endian on little endian machine,
    specifically, BusOptions will be initialized to a 0 max receive size.
    
    This patch changes the way we reuse the config rom so that we avoid
    this problem.
    
    Signed-off-by: Kristian Hoegsberg <krh@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---

 drivers/firewire/fw-cdev.c        |   21 
 drivers/firewire/fw-device.h      |    5 
 drivers/firewire/fw-ohci.c        |   66 +-
 drivers/firewire/fw-sbp2.c        |  655 ++++++++++++++++------------
 drivers/firewire/fw-transaction.c |   12 
 drivers/ieee1394/eth1394.c        |   16 
 drivers/ieee1394/nodemgr.c        |    3 
 drivers/ieee1394/pcilynx.c        |    3 
 drivers/ieee1394/sbp2.c           |   15 
 9 files changed, 474 insertions(+), 322 deletions(-)

diff -puN drivers/firewire/fw-cdev.c~git-ieee1394 drivers/firewire/fw-cdev.c
--- a/drivers/firewire/fw-cdev.c~git-ieee1394
+++ a/drivers/firewire/fw-cdev.c
@@ -621,20 +621,19 @@ iso_callback(struct fw_iso_context *cont
 	     size_t header_length, void *header, void *data)
 {
 	struct client *client = data;
-	struct iso_interrupt *interrupt;
+	struct iso_interrupt *irq;
 
-	interrupt = kzalloc(sizeof(*interrupt) + header_length, GFP_ATOMIC);
-	if (interrupt == NULL)
+	irq = kzalloc(sizeof(*irq) + header_length, GFP_ATOMIC);
+	if (irq == NULL)
 		return;
 
-	interrupt->interrupt.type      = FW_CDEV_EVENT_ISO_INTERRUPT;
-	interrupt->interrupt.closure   = client->iso_closure;
-	interrupt->interrupt.cycle     = cycle;
-	interrupt->interrupt.header_length = header_length;
-	memcpy(interrupt->interrupt.header, header, header_length);
-	queue_event(client, &interrupt->event,
-		    &interrupt->interrupt,
-		    sizeof(interrupt->interrupt) + header_length, NULL, 0);
+	irq->interrupt.type      = FW_CDEV_EVENT_ISO_INTERRUPT;
+	irq->interrupt.closure   = client->iso_closure;
+	irq->interrupt.cycle     = cycle;
+	irq->interrupt.header_length = header_length;
+	memcpy(irq->interrupt.header, header, header_length);
+	queue_event(client, &irq->event, &irq->interrupt,
+		    sizeof(irq->interrupt) + header_length, NULL, 0);
 }
 
 static int ioctl_create_iso_context(struct client *client, void *buffer)
diff -puN drivers/firewire/fw-device.h~git-ieee1394 drivers/firewire/fw-device.h
--- a/drivers/firewire/fw-device.h~git-ieee1394
+++ a/drivers/firewire/fw-device.h
@@ -102,11 +102,6 @@ fw_unit(struct device *dev)
 #define CSR_INSTANCE		0x18
 #define CSR_DIRECTORY_ID	0x20
 
-#define SBP2_COMMAND_SET_SPECIFIER	0x38
-#define SBP2_COMMAND_SET		0x39
-#define SBP2_COMMAND_SET_REVISION	0x3b
-#define SBP2_FIRMWARE_REVISION		0x3c
-
 struct fw_csr_iterator {
 	u32 *p;
 	u32 *end;
diff -puN drivers/firewire/fw-ohci.c~git-ieee1394 drivers/firewire/fw-ohci.c
--- a/drivers/firewire/fw-ohci.c~git-ieee1394
+++ a/drivers/firewire/fw-ohci.c
@@ -18,21 +18,23 @@
  * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
+#include <linux/compiler.h>
 #include <linux/delay.h>
-#include <linux/poll.h>
 #include <linux/dma-mapping.h>
+#include <linux/gfp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
 
-#include <asm/uaccess.h>
-#include <asm/semaphore.h>
+#include <asm/page.h>
+#include <asm/system.h>
 
-#include "fw-transaction.h"
 #include "fw-ohci.h"
+#include "fw-transaction.h"
 
 #define DESCRIPTOR_OUTPUT_MORE		0
 #define DESCRIPTOR_OUTPUT_LAST		(1 << 12)
@@ -926,12 +928,14 @@ static void bus_reset_tasklet(unsigned l
 
 	self_id_count = (reg_read(ohci, OHCI1394_SelfIDCount) >> 3) & 0x3ff;
 	generation = (le32_to_cpu(ohci->self_id_cpu[0]) >> 16) & 0xff;
+	rmb();
 
 	for (i = 1, j = 0; j < self_id_count; i += 2, j++) {
 		if (ohci->self_id_cpu[i] != ~ohci->self_id_cpu[i + 1])
 			fw_error("inconsistent self IDs\n");
 		ohci->self_id_buffer[j] = le32_to_cpu(ohci->self_id_cpu[i]);
 	}
+	rmb();
 
 	/*
 	 * Check the consistency of the self IDs we just read.  The
@@ -972,8 +976,10 @@ static void bus_reset_tasklet(unsigned l
 	 */
 
 	if (ohci->next_config_rom != NULL) {
-		free_rom     = ohci->config_rom;
-		free_rom_bus = ohci->config_rom_bus;
+		if (ohci->next_config_rom != ohci->config_rom) {
+			free_rom      = ohci->config_rom;
+			free_rom_bus  = ohci->config_rom_bus;
+		}
 		ohci->config_rom      = ohci->next_config_rom;
 		ohci->config_rom_bus  = ohci->next_config_rom_bus;
 		ohci->next_config_rom = NULL;
@@ -1046,6 +1052,9 @@ static irqreturn_t irq_handler(int irq, 
 		iso_event &= ~(1 << i);
 	}
 
+	if (unlikely(event & OHCI1394_postedWriteErr))
+		fw_error("PCI posted write error\n");
+
 	if (event & OHCI1394_cycle64Seconds) {
 		cycle_time = reg_read(ohci, OHCI1394_IsochronousCycleTimer);
 		if ((cycle_time & 0x80000000) == 0)
@@ -1119,8 +1128,8 @@ static int ohci_enable(struct fw_card *c
 		  OHCI1394_RQPkt | OHCI1394_RSPkt |
 		  OHCI1394_reqTxComplete | OHCI1394_respTxComplete |
 		  OHCI1394_isochRx | OHCI1394_isochTx |
-		  OHCI1394_masterIntEnable |
-		  OHCI1394_cycle64Seconds);
+		  OHCI1394_postedWriteErr | OHCI1394_cycle64Seconds |
+		  OHCI1394_masterIntEnable);
 
 	/* Activate link_on bit and contender bit in our self ID packets.*/
 	if (ohci_update_phy_reg(card, 4, 0,
@@ -1146,19 +1155,30 @@ static int ohci_enable(struct fw_card *c
 	 * the right values in the bus reset tasklet.
 	 */
 
-	ohci->next_config_rom =
-		dma_alloc_coherent(ohci->card.device, CONFIG_ROM_SIZE,
-				   &ohci->next_config_rom_bus, GFP_KERNEL);
-	if (ohci->next_config_rom == NULL)
-		return -ENOMEM;
+	if (config_rom) {
+		ohci->next_config_rom =
+			dma_alloc_coherent(ohci->card.device, CONFIG_ROM_SIZE,
+					   &ohci->next_config_rom_bus,
+					   GFP_KERNEL);
+		if (ohci->next_config_rom == NULL)
+			return -ENOMEM;
 
-	memset(ohci->next_config_rom, 0, CONFIG_ROM_SIZE);
-	fw_memcpy_to_be32(ohci->next_config_rom, config_rom, length * 4);
+		memset(ohci->next_config_rom, 0, CONFIG_ROM_SIZE);
+		fw_memcpy_to_be32(ohci->next_config_rom, config_rom, length * 4);
+	} else {
+		/*
+		 * In the suspend case, config_rom is NULL, which
+		 * means that we just reuse the old config rom.
+		 */
+		ohci->next_config_rom = ohci->config_rom;
+		ohci->next_config_rom_bus = ohci->config_rom_bus;
+	}
 
-	ohci->next_header = config_rom[0];
+	ohci->next_header = be32_to_cpu(ohci->next_config_rom[0]);
 	ohci->next_config_rom[0] = 0;
 	reg_write(ohci, OHCI1394_ConfigROMhdr, 0);
-	reg_write(ohci, OHCI1394_BusOptions, config_rom[2]);
+	reg_write(ohci, OHCI1394_BusOptions,
+		  be32_to_cpu(ohci->next_config_rom[2]));
 	reg_write(ohci, OHCI1394_ConfigROMmap, ohci->next_config_rom_bus);
 
 	reg_write(ohci, OHCI1394_AsReqFilterHiSet, 0x80000000);
@@ -1966,7 +1986,7 @@ static int pci_resume(struct pci_dev *pd
 		return err;
 	}
 
-	return ohci_enable(&ohci->card, ohci->config_rom, CONFIG_ROM_SIZE);
+	return ohci_enable(&ohci->card, NULL, 0);
 }
 #endif
 
diff -puN drivers/firewire/fw-sbp2.c~git-ieee1394 drivers/firewire/fw-sbp2.c
--- a/drivers/firewire/fw-sbp2.c~git-ieee1394
+++ a/drivers/firewire/fw-sbp2.c
@@ -37,11 +37,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/blkdev.h>
 #include <linux/string.h>
+#include <linux/stringify.h>
 #include <linux/timer.h>
+#include <linux/workqueue.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_dbg.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 
@@ -61,36 +62,94 @@ module_param_named(exclusive_login, sbp2
 MODULE_PARM_DESC(exclusive_login, "Exclusive login to sbp2 device "
 		 "(default = Y, use N for concurrent initiators)");
 
+/*
+ * Flags for firmware oddities
+ *
+ * - 128kB max transfer
+ *   Limit transfer size. Necessary for some old bridges.
+ *
+ * - 36 byte inquiry
+ *   When scsi_mod probes the device, let the inquiry command look like that
+ *   from MS Windows.
+ *
+ * - skip mode page 8
+ *   Suppress sending of mode_sense for mode page 8 if the device pretends to
+ *   support the SCSI Primary Block commands instead of Reduced Block Commands.
+ *
+ * - fix capacity
+ *   Tell sd_mod to correct the last sector number reported by read_capacity.
+ *   Avoids access beyond actual disk limits on devices with an off-by-one bug.
+ *   Don't use this with devices which don't have this bug.
+ *
+ * - override internal blacklist
+ *   Instead of adding to the built-in blacklist, use only the workarounds
+ *   specified in the module load parameter.
+ *   Useful if a blacklist entry interfered with a non-broken device.
+ */
+#define SBP2_WORKAROUND_128K_MAX_TRANS	0x1
+#define SBP2_WORKAROUND_INQUIRY_36	0x2
+#define SBP2_WORKAROUND_MODE_SENSE_8	0x4
+#define SBP2_WORKAROUND_FIX_CAPACITY	0x8
+#define SBP2_WORKAROUND_OVERRIDE	0x100
+
+static int sbp2_param_workarounds;
+module_param_named(workarounds, sbp2_param_workarounds, int, 0644);
+MODULE_PARM_DESC(workarounds, "Work around device bugs (default = 0"
+	", 128kB max transfer = " __stringify(SBP2_WORKAROUND_128K_MAX_TRANS)
+	", 36 byte inquiry = "    __stringify(SBP2_WORKAROUND_INQUIRY_36)
+	", skip mode page 8 = "   __stringify(SBP2_WORKAROUND_MODE_SENSE_8)
+	", fix capacity = "       __stringify(SBP2_WORKAROUND_FIX_CAPACITY)
+	", override internal blacklist = " __stringify(SBP2_WORKAROUND_OVERRIDE)
+	", or a combination)");
+
 /* I don't know why the SCSI stack doesn't define something like this... */
 typedef void (*scsi_done_fn_t)(struct scsi_cmnd *);
 
 static const char sbp2_driver_name[] = "sbp2";
 
-struct sbp2_device {
-	struct kref kref;
-	struct fw_unit *unit;
+/*
+ * We create one struct sbp2_logical_unit per SBP-2 Logical Unit Number Entry
+ * and one struct scsi_device per sbp2_logical_unit.
+ */
+struct sbp2_logical_unit {
+	struct sbp2_target *tgt;
+	struct list_head link;
+	struct scsi_device *sdev;
 	struct fw_address_handler address_handler;
 	struct list_head orb_list;
-	u64 management_agent_address;
+
 	u64 command_block_agent_address;
-	u32 workarounds;
+	u16 lun;
 	int login_id;
 
 	/*
-	 * We cache these addresses and only update them once we've
-	 * logged in or reconnected to the sbp2 device.  That way, any
-	 * IO to the device will automatically fail and get retried if
-	 * it happens in a window where the device is not ready to
-	 * handle it (e.g. after a bus reset but before we reconnect).
+	 * The generation is updated once we've logged in or reconnected
+	 * to the logical unit.  Thus, I/O to the device will automatically
+	 * fail and get retried if it happens in a window where the device
+	 * is not ready, e.g. after a bus reset but before we reconnect.
 	 */
-	int node_id;
-	int address_high;
 	int generation;
-
 	int retries;
 	struct delayed_work work;
 };
 
+/*
+ * We create one struct sbp2_target per IEEE 1212 Unit Directory
+ * and one struct Scsi_Host per sbp2_target.
+ */
+struct sbp2_target {
+	struct kref kref;
+	struct fw_unit *unit;
+
+	u64 management_agent_address;
+	int directory_id;
+	int node_id;
+	int address_high;
+
+	unsigned workarounds;
+	struct list_head lu_list;
+};
+
 #define SBP2_MAX_SG_ELEMENT_LENGTH	0xf000
 #define SBP2_MAX_SECTORS		255	/* Max sectors supported */
 #define SBP2_ORB_TIMEOUT		2000	/* Timeout in ms */
@@ -101,17 +160,9 @@ struct sbp2_device {
 #define SBP2_DIRECTION_FROM_MEDIA	0x1
 
 /* Unit directory keys */
-#define SBP2_COMMAND_SET_SPECIFIER	0x38
-#define SBP2_COMMAND_SET		0x39
-#define SBP2_COMMAND_SET_REVISION	0x3b
-#define SBP2_FIRMWARE_REVISION		0x3c
-
-/* Flags for detected oddities and brokeness */
-#define SBP2_WORKAROUND_128K_MAX_TRANS	0x1
-#define SBP2_WORKAROUND_INQUIRY_36	0x2
-#define SBP2_WORKAROUND_MODE_SENSE_8	0x4
-#define SBP2_WORKAROUND_FIX_CAPACITY	0x8
-#define SBP2_WORKAROUND_OVERRIDE	0x100
+#define SBP2_CSR_FIRMWARE_REVISION	0x3c
+#define SBP2_CSR_LOGICAL_UNIT_NUMBER	0x14
+#define SBP2_CSR_LOGICAL_UNIT_DIRECTORY	0xd4
 
 /* Management orb opcodes */
 #define SBP2_LOGIN_REQUEST		0x0
@@ -219,7 +270,7 @@ struct sbp2_command_orb {
 	} request;
 	struct scsi_cmnd *cmd;
 	scsi_done_fn_t done;
-	struct fw_unit *unit;
+	struct sbp2_logical_unit *lu;
 
 	struct sbp2_pointer page_table[SG_ALL] __attribute__((aligned(8)));
 	dma_addr_t page_table_bus;
@@ -295,7 +346,7 @@ sbp2_status_write(struct fw_card *card, 
 		  unsigned long long offset,
 		  void *payload, size_t length, void *callback_data)
 {
-	struct sbp2_device *sd = callback_data;
+	struct sbp2_logical_unit *lu = callback_data;
 	struct sbp2_orb *orb;
 	struct sbp2_status status;
 	size_t header_size;
@@ -319,7 +370,7 @@ sbp2_status_write(struct fw_card *card, 
 
 	/* Lookup the orb corresponding to this status write. */
 	spin_lock_irqsave(&card->lock, flags);
-	list_for_each_entry(orb, &sd->orb_list, link) {
+	list_for_each_entry(orb, &lu->orb_list, link) {
 		if (STATUS_GET_ORB_HIGH(status) == 0 &&
 		    STATUS_GET_ORB_LOW(status) == orb->request_bus) {
 			orb->rcode = RCODE_COMPLETE;
@@ -329,7 +380,7 @@ sbp2_status_write(struct fw_card *card, 
 	}
 	spin_unlock_irqrestore(&card->lock, flags);
 
-	if (&orb->link != &sd->orb_list)
+	if (&orb->link != &lu->orb_list)
 		orb->callback(orb, &status);
 	else
 		fw_error("status write for unknown orb\n");
@@ -361,20 +412,20 @@ complete_transaction(struct fw_card *car
 		orb->rcode = rcode;
 	if (orb->rcode != RCODE_COMPLETE) {
 		list_del(&orb->link);
+		spin_unlock_irqrestore(&card->lock, flags);
 		orb->callback(orb, NULL);
+	} else {
+		spin_unlock_irqrestore(&card->lock, flags);
 	}
 
-	spin_unlock_irqrestore(&card->lock, flags);
-
 	kref_put(&orb->kref, free_orb);
 }
 
 static void
-sbp2_send_orb(struct sbp2_orb *orb, struct fw_unit *unit,
+sbp2_send_orb(struct sbp2_orb *orb, struct sbp2_logical_unit *lu,
 	      int node_id, int generation, u64 offset)
 {
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd = unit->device.driver_data;
+	struct fw_device *device = fw_device(lu->tgt->unit->device.parent);
 	unsigned long flags;
 
 	orb->pointer.high = 0;
@@ -382,7 +433,7 @@ sbp2_send_orb(struct sbp2_orb *orb, stru
 	fw_memcpy_to_be32(&orb->pointer, &orb->pointer, sizeof(orb->pointer));
 
 	spin_lock_irqsave(&device->card->lock, flags);
-	list_add_tail(&orb->link, &sd->orb_list);
+	list_add_tail(&orb->link, &lu->orb_list);
 	spin_unlock_irqrestore(&device->card->lock, flags);
 
 	/* Take a ref for the orb list and for the transaction callback. */
@@ -395,10 +446,9 @@ sbp2_send_orb(struct sbp2_orb *orb, stru
 			complete_transaction, orb);
 }
 
-static int sbp2_cancel_orbs(struct fw_unit *unit)
+static int sbp2_cancel_orbs(struct sbp2_logical_unit *lu)
 {
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd = unit->device.driver_data;
+	struct fw_device *device = fw_device(lu->tgt->unit->device.parent);
 	struct sbp2_orb *orb, *next;
 	struct list_head list;
 	unsigned long flags;
@@ -406,7 +456,7 @@ static int sbp2_cancel_orbs(struct fw_un
 
 	INIT_LIST_HEAD(&list);
 	spin_lock_irqsave(&device->card->lock, flags);
-	list_splice_init(&sd->orb_list, &list);
+	list_splice_init(&lu->orb_list, &list);
 	spin_unlock_irqrestore(&device->card->lock, flags);
 
 	list_for_each_entry_safe(orb, next, &list, link) {
@@ -433,11 +483,11 @@ complete_management_orb(struct sbp2_orb 
 }
 
 static int
-sbp2_send_management_orb(struct fw_unit *unit, int node_id, int generation,
-			 int function, int lun, void *response)
+sbp2_send_management_orb(struct sbp2_logical_unit *lu, int node_id,
+			 int generation, int function, int lun_or_login_id,
+			 void *response)
 {
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd = unit->device.driver_data;
+	struct fw_device *device = fw_device(lu->tgt->unit->device.parent);
 	struct sbp2_management_orb *orb;
 	int retval = -ENOMEM;
 
@@ -458,12 +508,12 @@ sbp2_send_management_orb(struct fw_unit 
 	orb->request.misc =
 		MANAGEMENT_ORB_NOTIFY |
 		MANAGEMENT_ORB_FUNCTION(function) |
-		MANAGEMENT_ORB_LUN(lun);
+		MANAGEMENT_ORB_LUN(lun_or_login_id);
 	orb->request.length =
 		MANAGEMENT_ORB_RESPONSE_LENGTH(sizeof(orb->response));
 
-	orb->request.status_fifo.high = sd->address_handler.offset >> 32;
-	orb->request.status_fifo.low  = sd->address_handler.offset;
+	orb->request.status_fifo.high = lu->address_handler.offset >> 32;
+	orb->request.status_fifo.low  = lu->address_handler.offset;
 
 	if (function == SBP2_LOGIN_REQUEST) {
 		orb->request.misc |=
@@ -482,14 +532,14 @@ sbp2_send_management_orb(struct fw_unit 
 	if (dma_mapping_error(orb->base.request_bus))
 		goto fail_mapping_request;
 
-	sbp2_send_orb(&orb->base, unit,
-		      node_id, generation, sd->management_agent_address);
+	sbp2_send_orb(&orb->base, lu, node_id, generation,
+		      lu->tgt->management_agent_address);
 
 	wait_for_completion_timeout(&orb->done,
 				    msecs_to_jiffies(SBP2_ORB_TIMEOUT));
 
 	retval = -EIO;
-	if (sbp2_cancel_orbs(unit) == 0) {
+	if (sbp2_cancel_orbs(lu) == 0) {
 		fw_error("orb reply timed out, rcode=0x%02x\n",
 			 orb->base.rcode);
 		goto out;
@@ -534,10 +584,9 @@ complete_agent_reset_write(struct fw_car
 	kfree(t);
 }
 
-static int sbp2_agent_reset(struct fw_unit *unit)
+static int sbp2_agent_reset(struct sbp2_logical_unit *lu)
 {
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd = unit->device.driver_data;
+	struct fw_device *device = fw_device(lu->tgt->unit->device.parent);
 	struct fw_transaction *t;
 	static u32 zero;
 
@@ -546,181 +595,272 @@ static int sbp2_agent_reset(struct fw_un
 		return -ENOMEM;
 
 	fw_send_request(device->card, t, TCODE_WRITE_QUADLET_REQUEST,
-			sd->node_id, sd->generation, device->max_speed,
-			sd->command_block_agent_address + SBP2_AGENT_RESET,
+			lu->tgt->node_id, lu->generation, device->max_speed,
+			lu->command_block_agent_address + SBP2_AGENT_RESET,
 			&zero, sizeof(zero), complete_agent_reset_write, t);
 
 	return 0;
 }
 
-static void sbp2_reconnect(struct work_struct *work);
-static struct scsi_host_template scsi_driver_template;
-
-static void release_sbp2_device(struct kref *kref)
+static void sbp2_release_target(struct kref *kref)
 {
-	struct sbp2_device *sd = container_of(kref, struct sbp2_device, kref);
-	struct Scsi_Host *host =
-		container_of((void *)sd, struct Scsi_Host, hostdata[0]);
-
-	scsi_remove_host(host);
-	sbp2_send_management_orb(sd->unit, sd->node_id, sd->generation,
-				 SBP2_LOGOUT_REQUEST, sd->login_id, NULL);
-	fw_core_remove_address_handler(&sd->address_handler);
-	fw_notify("removed sbp2 unit %s\n", sd->unit->device.bus_id);
-	put_device(&sd->unit->device);
-	scsi_host_put(host);
+	struct sbp2_target *tgt = container_of(kref, struct sbp2_target, kref);
+	struct sbp2_logical_unit *lu, *next;
+	struct Scsi_Host *shost =
+		container_of((void *)tgt, struct Scsi_Host, hostdata[0]);
+
+	list_for_each_entry_safe(lu, next, &tgt->lu_list, link) {
+		if (lu->sdev)
+			scsi_remove_device(lu->sdev);
+
+		sbp2_send_management_orb(lu, tgt->node_id, lu->generation,
+				SBP2_LOGOUT_REQUEST, lu->login_id, NULL);
+		fw_core_remove_address_handler(&lu->address_handler);
+		list_del(&lu->link);
+		kfree(lu);
+	}
+	scsi_remove_host(shost);
+	fw_notify("released %s\n", tgt->unit->device.bus_id);
+
+	put_device(&tgt->unit->device);
+	scsi_host_put(shost);
 }
 
+static struct workqueue_struct *sbp2_wq;
+
+static void sbp2_reconnect(struct work_struct *work);
+
 static void sbp2_login(struct work_struct *work)
 {
-	struct sbp2_device *sd =
-		container_of(work, struct sbp2_device, work.work);
-	struct Scsi_Host *host =
-		container_of((void *)sd, struct Scsi_Host, hostdata[0]);
-	struct fw_unit *unit = sd->unit;
+	struct sbp2_logical_unit *lu =
+		container_of(work, struct sbp2_logical_unit, work.work);
+	struct Scsi_Host *shost =
+		container_of((void *)lu->tgt, struct Scsi_Host, hostdata[0]);
+	struct scsi_device *sdev;
+	struct scsi_lun eight_bytes_lun;
+	struct fw_unit *unit = lu->tgt->unit;
 	struct fw_device *device = fw_device(unit->device.parent);
 	struct sbp2_login_response response;
-	int generation, node_id, local_node_id, lun, retval;
-
-	/* FIXME: Make this work for multi-lun devices. */
-	lun = 0;
+	int generation, node_id, local_node_id;
 
 	generation    = device->card->generation;
 	node_id       = device->node->node_id;
 	local_node_id = device->card->local_node->node_id;
 
-	if (sbp2_send_management_orb(unit, node_id, generation,
-				     SBP2_LOGIN_REQUEST, lun, &response) < 0) {
-		if (sd->retries++ < 5) {
-			schedule_delayed_work(&sd->work, DIV_ROUND_UP(HZ, 5));
+	if (sbp2_send_management_orb(lu, node_id, generation,
+				SBP2_LOGIN_REQUEST, lu->lun, &response) < 0) {
+		if (lu->retries++ < 5) {
+			queue_delayed_work(sbp2_wq, &lu->work,
+					   DIV_ROUND_UP(HZ, 5));
 		} else {
-			fw_error("failed to login to %s\n",
-				 unit->device.bus_id);
-			kref_put(&sd->kref, release_sbp2_device);
+			fw_error("failed to login to %s LUN %04x\n",
+				 unit->device.bus_id, lu->lun);
+			kref_put(&lu->tgt->kref, sbp2_release_target);
 		}
 		return;
 	}
 
-	sd->generation   = generation;
-	sd->node_id      = node_id;
-	sd->address_high = local_node_id << 16;
+	lu->generation        = generation;
+	lu->tgt->node_id      = node_id;
+	lu->tgt->address_high = local_node_id << 16;
 
 	/* Get command block agent offset and login id. */
-	sd->command_block_agent_address =
+	lu->command_block_agent_address =
 		((u64) (response.command_block_agent.high & 0xffff) << 32) |
 		response.command_block_agent.low;
-	sd->login_id = LOGIN_RESPONSE_GET_LOGIN_ID(response);
+	lu->login_id = LOGIN_RESPONSE_GET_LOGIN_ID(response);
 
-	fw_notify("logged in to sbp2 unit %s (%d retries)\n",
-		  unit->device.bus_id, sd->retries);
-	fw_notify(" - management_agent_address:    0x%012llx\n",
-		  (unsigned long long) sd->management_agent_address);
-	fw_notify(" - command_block_agent_address: 0x%012llx\n",
-		  (unsigned long long) sd->command_block_agent_address);
-	fw_notify(" - status write address:        0x%012llx\n",
-		  (unsigned long long) sd->address_handler.offset);
+	fw_notify("logged in to %s LUN %04x (%d retries)\n",
+		  unit->device.bus_id, lu->lun, lu->retries);
 
 #if 0
 	/* FIXME: The linux1394 sbp2 does this last step. */
 	sbp2_set_busy_timeout(scsi_id);
 #endif
 
-	PREPARE_DELAYED_WORK(&sd->work, sbp2_reconnect);
-	sbp2_agent_reset(unit);
+	PREPARE_DELAYED_WORK(&lu->work, sbp2_reconnect);
+	sbp2_agent_reset(lu);
 
-	/* FIXME: Loop over luns here. */
-	lun = 0;
-	retval = scsi_add_device(host, 0, 0, lun);
-	if (retval < 0) {
-		sbp2_send_management_orb(unit, sd->node_id, sd->generation,
-					 SBP2_LOGOUT_REQUEST, sd->login_id,
-					 NULL);
+	memset(&eight_bytes_lun, 0, sizeof(eight_bytes_lun));
+	eight_bytes_lun.scsi_lun[0] = (lu->lun >> 8) & 0xff;
+	eight_bytes_lun.scsi_lun[1] = lu->lun & 0xff;
+
+	sdev = __scsi_add_device(shost, 0, 0,
+				 scsilun_to_int(&eight_bytes_lun), lu);
+	if (IS_ERR(sdev)) {
+		sbp2_send_management_orb(lu, node_id, generation,
+				SBP2_LOGOUT_REQUEST, lu->login_id, NULL);
 		/*
 		 * Set this back to sbp2_login so we fall back and
 		 * retry login on bus reset.
 		 */
-		PREPARE_DELAYED_WORK(&sd->work, sbp2_login);
+		PREPARE_DELAYED_WORK(&lu->work, sbp2_login);
+	} else {
+		lu->sdev = sdev;
+		scsi_device_put(sdev);
 	}
-	kref_put(&sd->kref, release_sbp2_device);
+	kref_put(&lu->tgt->kref, sbp2_release_target);
 }
 
-static int sbp2_probe(struct device *dev)
+static int sbp2_add_logical_unit(struct sbp2_target *tgt, int lun_entry)
+{
+	struct sbp2_logical_unit *lu;
+
+	lu = kmalloc(sizeof(*lu), GFP_KERNEL);
+	if (!lu)
+		return -ENOMEM;
+
+	lu->address_handler.length           = 0x100;
+	lu->address_handler.address_callback = sbp2_status_write;
+	lu->address_handler.callback_data    = lu;
+
+	if (fw_core_add_address_handler(&lu->address_handler,
+					&fw_high_memory_region) < 0) {
+		kfree(lu);
+		return -ENOMEM;
+	}
+
+	lu->tgt  = tgt;
+	lu->sdev = NULL;
+	lu->lun  = lun_entry & 0xffff;
+	lu->retries = 0;
+	INIT_LIST_HEAD(&lu->orb_list);
+	INIT_DELAYED_WORK(&lu->work, sbp2_login);
+
+	list_add_tail(&lu->link, &tgt->lu_list);
+	return 0;
+}
+
+static int sbp2_scan_logical_unit_dir(struct sbp2_target *tgt, u32 *directory)
 {
-	struct fw_unit *unit = fw_unit(dev);
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd;
 	struct fw_csr_iterator ci;
-	struct Scsi_Host *host;
-	int i, key, value, err;
-	u32 model, firmware_revision;
+	int key, value;
 
-	err = -ENOMEM;
-	host = scsi_host_alloc(&scsi_driver_template, sizeof(*sd));
-	if (host == NULL)
-		goto fail;
+	fw_csr_iterator_init(&ci, directory);
+	while (fw_csr_iterator_next(&ci, &key, &value))
+		if (key == SBP2_CSR_LOGICAL_UNIT_NUMBER &&
+		    sbp2_add_logical_unit(tgt, value) < 0)
+			return -ENOMEM;
+	return 0;
+}
 
-	sd = (struct sbp2_device *) host->hostdata;
-	unit->device.driver_data = sd;
-	sd->unit = unit;
-	INIT_LIST_HEAD(&sd->orb_list);
-	kref_init(&sd->kref);
-
-	sd->address_handler.length = 0x100;
-	sd->address_handler.address_callback = sbp2_status_write;
-	sd->address_handler.callback_data = sd;
-
-	err = fw_core_add_address_handler(&sd->address_handler,
-					  &fw_high_memory_region);
-	if (err < 0)
-		goto fail_host;
-
-	err = fw_device_enable_phys_dma(device);
-	if (err < 0)
-		goto fail_address_handler;
-
-	err = scsi_add_host(host, &unit->device);
-	if (err < 0)
-		goto fail_address_handler;
+static int sbp2_scan_unit_dir(struct sbp2_target *tgt, u32 *directory,
+			      u32 *model, u32 *firmware_revision)
+{
+	struct fw_csr_iterator ci;
+	int key, value;
 
-	/*
-	 * Scan unit directory to get management agent address,
-	 * firmware revison and model.  Initialize firmware_revision
-	 * and model to values that wont match anything in our table.
-	 */
-	firmware_revision = 0xff000000;
-	model = 0xff000000;
-	fw_csr_iterator_init(&ci, unit->directory);
+	fw_csr_iterator_init(&ci, directory);
 	while (fw_csr_iterator_next(&ci, &key, &value)) {
 		switch (key) {
+
 		case CSR_DEPENDENT_INFO | CSR_OFFSET:
-			sd->management_agent_address =
-				0xfffff0000000ULL + 4 * value;
+			tgt->management_agent_address =
+					CSR_REGISTER_BASE + 4 * value;
 			break;
-		case SBP2_FIRMWARE_REVISION:
-			firmware_revision = value;
+
+		case CSR_DIRECTORY_ID:
+			tgt->directory_id = value;
 			break;
+
 		case CSR_MODEL:
-			model = value;
+			*model = value;
+			break;
+
+		case SBP2_CSR_FIRMWARE_REVISION:
+			*firmware_revision = value;
+			break;
+
+		case SBP2_CSR_LOGICAL_UNIT_NUMBER:
+			if (sbp2_add_logical_unit(tgt, value) < 0)
+				return -ENOMEM;
+			break;
+
+		case SBP2_CSR_LOGICAL_UNIT_DIRECTORY:
+			if (sbp2_scan_logical_unit_dir(tgt, ci.p + value) < 0)
+				return -ENOMEM;
 			break;
 		}
 	}
+	return 0;
+}
+
+static void sbp2_init_workarounds(struct sbp2_target *tgt, u32 model,
+				  u32 firmware_revision)
+{
+	int i;
+	unsigned w = sbp2_param_workarounds;
+
+	if (w)
+		fw_notify("Please notify linux1394-devel@lists.sourceforge.net "
+			  "if you need the workarounds parameter for %s\n",
+			  tgt->unit->device.bus_id);
+
+	if (w & SBP2_WORKAROUND_OVERRIDE)
+		goto out;
 
 	for (i = 0; i < ARRAY_SIZE(sbp2_workarounds_table); i++) {
+
 		if (sbp2_workarounds_table[i].firmware_revision !=
 		    (firmware_revision & 0xffffff00))
 			continue;
+
 		if (sbp2_workarounds_table[i].model != model &&
 		    sbp2_workarounds_table[i].model != ~0)
 			continue;
-		sd->workarounds |= sbp2_workarounds_table[i].workarounds;
+
+		w |= sbp2_workarounds_table[i].workarounds;
 		break;
 	}
-
-	if (sd->workarounds)
-		fw_notify("Workarounds for node %s: 0x%x "
+ out:
+	if (w)
+		fw_notify("Workarounds for %s: 0x%x "
 			  "(firmware_revision 0x%06x, model_id 0x%06x)\n",
-			  unit->device.bus_id,
-			  sd->workarounds, firmware_revision, model);
+			  tgt->unit->device.bus_id,
+			  w, firmware_revision, model);
+	tgt->workarounds = w;
+}
+
+static struct scsi_host_template scsi_driver_template;
+
+static int sbp2_probe(struct device *dev)
+{
+	struct fw_unit *unit = fw_unit(dev);
+	struct fw_device *device = fw_device(unit->device.parent);
+	struct sbp2_target *tgt;
+	struct sbp2_logical_unit *lu;
+	struct Scsi_Host *shost;
+	u32 model, firmware_revision;
+
+	shost = scsi_host_alloc(&scsi_driver_template, sizeof(*tgt));
+	if (shost == NULL)
+		return -ENOMEM;
+
+	tgt = (struct sbp2_target *)shost->hostdata;
+	unit->device.driver_data = tgt;
+	tgt->unit = unit;
+	kref_init(&tgt->kref);
+	INIT_LIST_HEAD(&tgt->lu_list);
+
+	if (fw_device_enable_phys_dma(device) < 0)
+		goto fail_shost_put;
+
+	if (scsi_add_host(shost, &unit->device) < 0)
+		goto fail_shost_put;
+
+	/* Initialize to values that won't match anything in our table. */
+	firmware_revision = 0xff000000;
+	model = 0xff000000;
+
+	/* implicit directory ID */
+	tgt->directory_id = ((unit->directory - device->config_rom) * 4
+			     + CSR_CONFIG_ROM) & 0xffffff;
+
+	if (sbp2_scan_unit_dir(tgt, unit->directory, &model,
+			       &firmware_revision) < 0)
+		goto fail_tgt_put;
+
+	sbp2_init_workarounds(tgt, model, firmware_revision);
 
 	get_device(&unit->device);
 
@@ -729,35 +869,34 @@ static int sbp2_probe(struct device *dev
 	 * reschedule retries. Always get the ref before scheduling
 	 * work.
 	 */
-	INIT_DELAYED_WORK(&sd->work, sbp2_login);
-	if (schedule_delayed_work(&sd->work, 0))
-		kref_get(&sd->kref);
-
+	list_for_each_entry(lu, &tgt->lu_list, link)
+		if (queue_delayed_work(sbp2_wq, &lu->work, 0))
+			kref_get(&tgt->kref);
 	return 0;
 
- fail_address_handler:
-	fw_core_remove_address_handler(&sd->address_handler);
- fail_host:
-	scsi_host_put(host);
- fail:
-	return err;
+ fail_tgt_put:
+	kref_put(&tgt->kref, sbp2_release_target);
+	return -ENOMEM;
+
+ fail_shost_put:
+	scsi_host_put(shost);
+	return -ENOMEM;
 }
 
 static int sbp2_remove(struct device *dev)
 {
 	struct fw_unit *unit = fw_unit(dev);
-	struct sbp2_device *sd = unit->device.driver_data;
-
-	kref_put(&sd->kref, release_sbp2_device);
+	struct sbp2_target *tgt = unit->device.driver_data;
 
+	kref_put(&tgt->kref, sbp2_release_target);
 	return 0;
 }
 
 static void sbp2_reconnect(struct work_struct *work)
 {
-	struct sbp2_device *sd =
-		container_of(work, struct sbp2_device, work.work);
-	struct fw_unit *unit = sd->unit;
+	struct sbp2_logical_unit *lu =
+		container_of(work, struct sbp2_logical_unit, work.work);
+	struct fw_unit *unit = lu->tgt->unit;
 	struct fw_device *device = fw_device(unit->device.parent);
 	int generation, node_id, local_node_id;
 
@@ -765,40 +904,49 @@ static void sbp2_reconnect(struct work_s
 	node_id       = device->node->node_id;
 	local_node_id = device->card->local_node->node_id;
 
-	if (sbp2_send_management_orb(unit, node_id, generation,
+	if (sbp2_send_management_orb(lu, node_id, generation,
 				     SBP2_RECONNECT_REQUEST,
-				     sd->login_id, NULL) < 0) {
-		if (sd->retries++ >= 5) {
+				     lu->login_id, NULL) < 0) {
+		if (lu->retries++ >= 5) {
 			fw_error("failed to reconnect to %s\n",
 				 unit->device.bus_id);
 			/* Fall back and try to log in again. */
-			sd->retries = 0;
-			PREPARE_DELAYED_WORK(&sd->work, sbp2_login);
+			lu->retries = 0;
+			PREPARE_DELAYED_WORK(&lu->work, sbp2_login);
 		}
-		schedule_delayed_work(&sd->work, DIV_ROUND_UP(HZ, 5));
+		queue_delayed_work(sbp2_wq, &lu->work, DIV_ROUND_UP(HZ, 5));
 		return;
 	}
 
-	sd->generation   = generation;
-	sd->node_id      = node_id;
-	sd->address_high = local_node_id << 16;
-
-	fw_notify("reconnected to unit %s (%d retries)\n",
-		  unit->device.bus_id, sd->retries);
-	sbp2_agent_reset(unit);
-	sbp2_cancel_orbs(unit);
-	kref_put(&sd->kref, release_sbp2_device);
+	lu->generation        = generation;
+	lu->tgt->node_id      = node_id;
+	lu->tgt->address_high = local_node_id << 16;
+
+	fw_notify("reconnected to %s LUN %04x (%d retries)\n",
+		  unit->device.bus_id, lu->lun, lu->retries);
+
+	sbp2_agent_reset(lu);
+	sbp2_cancel_orbs(lu);
+
+	kref_put(&lu->tgt->kref, sbp2_release_target);
 }
 
 static void sbp2_update(struct fw_unit *unit)
 {
-	struct fw_device *device = fw_device(unit->device.parent);
-	struct sbp2_device *sd = unit->device.driver_data;
+	struct sbp2_target *tgt = unit->device.driver_data;
+	struct sbp2_logical_unit *lu;
 
-	sd->retries = 0;
-	fw_device_enable_phys_dma(device);
-	if (schedule_delayed_work(&sd->work, 0))
-		kref_get(&sd->kref);
+	fw_device_enable_phys_dma(fw_device(unit->device.parent));
+
+	/*
+	 * Fw-core serializes sbp2_update() against sbp2_remove().
+	 * Iteration over tgt->lu_list is therefore safe here.
+	 */
+	list_for_each_entry(lu, &tgt->lu_list, link) {
+		lu->retries = 0;
+		if (queue_delayed_work(sbp2_wq, &lu->work, 0))
+			kref_get(&tgt->kref);
+	}
 }
 
 #define SBP2_UNIT_SPEC_ID_ENTRY	0x0000609e
@@ -868,13 +1016,12 @@ complete_command_orb(struct sbp2_orb *ba
 {
 	struct sbp2_command_orb *orb =
 		container_of(base_orb, struct sbp2_command_orb, base);
-	struct fw_unit *unit = orb->unit;
-	struct fw_device *device = fw_device(unit->device.parent);
+	struct fw_device *device = fw_device(orb->lu->tgt->unit->device.parent);
 	int result;
 
 	if (status != NULL) {
 		if (STATUS_GET_DEAD(*status))
-			sbp2_agent_reset(unit);
+			sbp2_agent_reset(orb->lu);
 
 		switch (STATUS_GET_RESPONSE(*status)) {
 		case SBP2_STATUS_REQUEST_COMPLETE:
@@ -918,12 +1065,10 @@ complete_command_orb(struct sbp2_orb *ba
 	orb->done(orb->cmd);
 }
 
-static int sbp2_command_orb_map_scatterlist(struct sbp2_command_orb *orb)
+static int
+sbp2_map_scatterlist(struct sbp2_command_orb *orb, struct fw_device *device,
+		     struct sbp2_logical_unit *lu)
 {
-	struct sbp2_device *sd =
-		(struct sbp2_device *)orb->cmd->device->host->hostdata;
-	struct fw_unit *unit = sd->unit;
-	struct fw_device *device = fw_device(unit->device.parent);
 	struct scatterlist *sg;
 	int sg_len, l, i, j, count;
 	dma_addr_t sg_addr;
@@ -942,10 +1087,9 @@ static int sbp2_command_orb_map_scatterl
 	 * tables.
 	 */
 	if (count == 1 && sg_dma_len(sg) < SBP2_MAX_SG_ELEMENT_LENGTH) {
-		orb->request.data_descriptor.high = sd->address_high;
+		orb->request.data_descriptor.high = lu->tgt->address_high;
 		orb->request.data_descriptor.low  = sg_dma_address(sg);
-		orb->request.misc |=
-			COMMAND_ORB_DATA_SIZE(sg_dma_len(sg));
+		orb->request.misc |= COMMAND_ORB_DATA_SIZE(sg_dma_len(sg));
 		return 0;
 	}
 
@@ -989,7 +1133,7 @@ static int sbp2_command_orb_map_scatterl
 	 * initiator (i.e. us), but data_descriptor can refer to data
 	 * on other nodes so we need to put our ID in descriptor.high.
 	 */
-	orb->request.data_descriptor.high = sd->address_high;
+	orb->request.data_descriptor.high = lu->tgt->address_high;
 	orb->request.data_descriptor.low  = orb->page_table_bus;
 	orb->request.misc |=
 		COMMAND_ORB_PAGE_TABLE_PRESENT |
@@ -1008,12 +1152,11 @@ static int sbp2_command_orb_map_scatterl
 
 static int sbp2_scsi_queuecommand(struct scsi_cmnd *cmd, scsi_done_fn_t done)
 {
-	struct sbp2_device *sd =
-		(struct sbp2_device *)cmd->device->host->hostdata;
-	struct fw_unit *unit = sd->unit;
-	struct fw_device *device = fw_device(unit->device.parent);
+	struct sbp2_logical_unit *lu = cmd->device->hostdata;
+	struct fw_device *device = fw_device(lu->tgt->unit->device.parent);
 	struct sbp2_command_orb *orb;
 	unsigned max_payload;
+	int retval = SCSI_MLQUEUE_HOST_BUSY;
 
 	/*
 	 * Bidirectional commands are not yet implemented, and unknown
@@ -1029,14 +1172,14 @@ static int sbp2_scsi_queuecommand(struct
 	orb = kzalloc(sizeof(*orb), GFP_ATOMIC);
 	if (orb == NULL) {
 		fw_notify("failed to alloc orb\n");
-		goto fail_alloc;
+		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
 	/* Initialize rcode to something not RCODE_COMPLETE. */
 	orb->base.rcode = -1;
 	kref_init(&orb->base.kref);
 
-	orb->unit = unit;
+	orb->lu   = lu;
 	orb->done = done;
 	orb->cmd  = cmd;
 
@@ -1062,8 +1205,8 @@ static int sbp2_scsi_queuecommand(struct
 		orb->request.misc |=
 			COMMAND_ORB_DIRECTION(SBP2_DIRECTION_TO_MEDIA);
 
-	if (scsi_sg_count(cmd) && sbp2_command_orb_map_scatterlist(orb) < 0)
-		goto fail_mapping;
+	if (scsi_sg_count(cmd) && sbp2_map_scatterlist(orb, device, lu) < 0)
+		goto out;
 
 	fw_memcpy_to_be32(&orb->request, &orb->request, sizeof(orb->request));
 
@@ -1076,49 +1219,47 @@ static int sbp2_scsi_queuecommand(struct
 		dma_map_single(device->card->device, &orb->request,
 			       sizeof(orb->request), DMA_TO_DEVICE);
 	if (dma_mapping_error(orb->base.request_bus))
-		goto fail_mapping;
-
-	sbp2_send_orb(&orb->base, unit, sd->node_id, sd->generation,
-		      sd->command_block_agent_address + SBP2_ORB_POINTER);
-
-	kref_put(&orb->base.kref, free_orb);
-	return 0;
+		goto out;
 
- fail_mapping:
+	sbp2_send_orb(&orb->base, lu, lu->tgt->node_id, lu->generation,
+		      lu->command_block_agent_address + SBP2_ORB_POINTER);
+	retval = 0;
+ out:
 	kref_put(&orb->base.kref, free_orb);
- fail_alloc:
-	return SCSI_MLQUEUE_HOST_BUSY;
+	return retval;
 }
 
 static int sbp2_scsi_slave_alloc(struct scsi_device *sdev)
 {
-	struct sbp2_device *sd = (struct sbp2_device *)sdev->host->hostdata;
+	struct sbp2_logical_unit *lu = sdev->hostdata;
 
 	sdev->allow_restart = 1;
 
-	if (sd->workarounds & SBP2_WORKAROUND_INQUIRY_36)
+	if (lu->tgt->workarounds & SBP2_WORKAROUND_INQUIRY_36)
 		sdev->inquiry_len = 36;
+
 	return 0;
 }
 
 static int sbp2_scsi_slave_configure(struct scsi_device *sdev)
 {
-	struct sbp2_device *sd = (struct sbp2_device *)sdev->host->hostdata;
-	struct fw_unit *unit = sd->unit;
+	struct sbp2_logical_unit *lu = sdev->hostdata;
 
 	sdev->use_10_for_rw = 1;
 
 	if (sdev->type == TYPE_ROM)
 		sdev->use_10_for_ms = 1;
+
 	if (sdev->type == TYPE_DISK &&
-	    sd->workarounds & SBP2_WORKAROUND_MODE_SENSE_8)
+	    lu->tgt->workarounds & SBP2_WORKAROUND_MODE_SENSE_8)
 		sdev->skip_ms_page_8 = 1;
-	if (sd->workarounds & SBP2_WORKAROUND_FIX_CAPACITY) {
-		fw_notify("setting fix_capacity for %s\n", unit->device.bus_id);
+
+	if (lu->tgt->workarounds & SBP2_WORKAROUND_FIX_CAPACITY)
 		sdev->fix_capacity = 1;
-	}
-	if (sd->workarounds & SBP2_WORKAROUND_128K_MAX_TRANS)
+
+	if (lu->tgt->workarounds & SBP2_WORKAROUND_128K_MAX_TRANS)
 		blk_queue_max_sectors(sdev->request_queue, 128 * 1024 / 512);
+
 	return 0;
 }
 
@@ -1128,13 +1269,11 @@ static int sbp2_scsi_slave_configure(str
  */
 static int sbp2_scsi_abort(struct scsi_cmnd *cmd)
 {
-	struct sbp2_device *sd =
-		(struct sbp2_device *)cmd->device->host->hostdata;
-	struct fw_unit *unit = sd->unit;
+	struct sbp2_logical_unit *lu = cmd->device->hostdata;
 
 	fw_notify("sbp2_scsi_abort\n");
-	sbp2_agent_reset(unit);
-	sbp2_cancel_orbs(unit);
+	sbp2_agent_reset(lu);
+	sbp2_cancel_orbs(lu);
 
 	return SUCCESS;
 }
@@ -1151,37 +1290,18 @@ sbp2_sysfs_ieee1394_id_show(struct devic
 			    char *buf)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
-	struct sbp2_device *sd;
-	struct fw_unit *unit;
+	struct sbp2_logical_unit *lu;
 	struct fw_device *device;
-	u32 directory_id;
-	struct fw_csr_iterator ci;
-	int key, value, lun;
 
 	if (!sdev)
 		return 0;
-	sd = (struct sbp2_device *)sdev->host->hostdata;
-	unit = sd->unit;
-	device = fw_device(unit->device.parent);
-
-	/* implicit directory ID */
-	directory_id = ((unit->directory - device->config_rom) * 4
-			+ CSR_CONFIG_ROM) & 0xffffff;
-
-	/* explicit directory ID, overrides implicit ID if present */
-	fw_csr_iterator_init(&ci, unit->directory);
-	while (fw_csr_iterator_next(&ci, &key, &value))
-		if (key == CSR_DIRECTORY_ID) {
-			directory_id = value;
-			break;
-		}
 
-	/* FIXME: Make this work for multi-lun devices. */
-	lun = 0;
+	lu = sdev->hostdata;
+	device = fw_device(lu->tgt->unit->device.parent);
 
 	return sprintf(buf, "%08x%08x:%06x:%04x\n",
 			device->config_rom[3], device->config_rom[4],
-			directory_id, lun);
+			lu->tgt->directory_id, lu->lun);
 }
 
 static DEVICE_ATTR(ieee1394_id, S_IRUGO, sbp2_sysfs_ieee1394_id_show, NULL);
@@ -1219,12 +1339,17 @@ MODULE_ALIAS("sbp2");
 
 static int __init sbp2_init(void)
 {
+	sbp2_wq = create_singlethread_workqueue(KBUILD_MODNAME);
+	if (!sbp2_wq)
+		return -ENOMEM;
+
 	return driver_register(&sbp2_driver.driver);
 }
 
 static void __exit sbp2_cleanup(void)
 {
 	driver_unregister(&sbp2_driver.driver);
+	destroy_workqueue(sbp2_wq);
 }
 
 module_init(sbp2_init);
diff -puN drivers/firewire/fw-transaction.c~git-ieee1394 drivers/firewire/fw-transaction.c
--- a/drivers/firewire/fw-transaction.c~git-ieee1394
+++ a/drivers/firewire/fw-transaction.c
@@ -410,7 +410,12 @@ EXPORT_SYMBOL(fw_unit_space_region);
  * controller.  When a request is received that falls within the
  * specified address range, the specified callback is invoked.  The
  * parameters passed to the callback give the details of the
- * particular request
+ * particular request.
+ *
+ * Return value:  0 on success, non-zero otherwise.
+ * The start offset of the handler's address region is determined by
+ * fw_core_add_address_handler() and is returned in handler->offset.
+ * The offset is quadlet-aligned.
  */
 int
 fw_core_add_address_handler(struct fw_address_handler *handler,
@@ -422,14 +427,15 @@ fw_core_add_address_handler(struct fw_ad
 
 	spin_lock_irqsave(&address_handler_lock, flags);
 
-	handler->offset = region->start;
+	handler->offset = roundup(region->start, 4);
 	while (handler->offset + handler->length <= region->end) {
 		other =
 		    lookup_overlapping_address_handler(&address_handler_list,
 						       handler->offset,
 						       handler->length);
 		if (other != NULL) {
-			handler->offset += other->length;
+			handler->offset =
+			    roundup(other->offset + other->length, 4);
 		} else {
 			list_add_tail(&handler->link, &address_handler_list);
 			ret = 0;
diff -puN drivers/ieee1394/eth1394.c~git-ieee1394 drivers/ieee1394/eth1394.c
--- a/drivers/ieee1394/eth1394.c~git-ieee1394
+++ a/drivers/ieee1394/eth1394.c
@@ -1148,8 +1148,6 @@ static int ether1394_data_handler(struct
 			pdg->sz++;
 			lh = find_partial_datagram(pdgl, dgl);
 		} else {
-			struct partial_datagram *pd;
-
 			pd = list_entry(lh, struct partial_datagram, list);
 
 			if (fragment_overlap(&pd->frag_info, fg_off, fg_len)) {
@@ -1217,23 +1215,19 @@ static int ether1394_data_handler(struct
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
 		dev_kfree_skb_any(skb);
-		goto bad_proto;
-	}
-
-	if (netif_rx(skb) == NET_RX_DROP) {
+	} else if (netif_rx(skb) == NET_RX_DROP) {
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
-		goto bad_proto;
+	} else {
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes += skb->len;
 	}
 
-	/* Statistics */
-	priv->stats.rx_packets++;
-	priv->stats.rx_bytes += skb->len;
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 bad_proto:
 	if (netif_queue_stopped(dev))
 		netif_wake_queue(dev);
-	spin_unlock_irqrestore(&priv->lock, flags);
 
 	dev->last_rx = jiffies;
 
diff -puN drivers/ieee1394/nodemgr.c~git-ieee1394 drivers/ieee1394/nodemgr.c
--- a/drivers/ieee1394/nodemgr.c~git-ieee1394
+++ a/drivers/ieee1394/nodemgr.c
@@ -1712,7 +1712,8 @@ static int nodemgr_host_thread(void *__h
 		 * to make sure things settle down. */
 		g = get_hpsb_generation(host);
 		for (i = 0; i < 4 ; i++) {
-			if (msleep_interruptible(63) || kthread_should_stop())
+			msleep_interruptible(63);
+			if (kthread_should_stop())
 				goto exit;
 
 			/* Now get the generation in which the node ID's we collect
diff -puN drivers/ieee1394/pcilynx.c~git-ieee1394 drivers/ieee1394/pcilynx.c
--- a/drivers/ieee1394/pcilynx.c~git-ieee1394
+++ a/drivers/ieee1394/pcilynx.c
@@ -765,7 +765,6 @@ static int lynx_devctl(struct hpsb_host 
                 } else {
                         struct ti_pcl pcl;
                         u32 ack;
-                        struct hpsb_packet *packet;
 
                         PRINT(KERN_INFO, lynx->id, "cancelling async packet, that was already in PCL");
 
@@ -1470,8 +1469,6 @@ static int __devinit add_card(struct pci
                         if (i2c_transfer(i2c_ad, msg, 2) < 0) {
                                 PRINT(KERN_ERR, lynx->id, "unable to read bus info block from i2c");
                         } else {
-                                int i;
-
                                 PRINT(KERN_INFO, lynx->id, "got bus info block from serial eeprom");
 				/* FIXME: probably we shoud rewrite the max_rec, max_ROM(1394a),
 				 * generation(1394a) and link_spd(1394a) field and recalculate
diff -puN drivers/ieee1394/sbp2.c~git-ieee1394 drivers/ieee1394/sbp2.c
--- a/drivers/ieee1394/sbp2.c~git-ieee1394
+++ a/drivers/ieee1394/sbp2.c
@@ -242,6 +242,8 @@ static int sbp2_max_speed_and_size(struc
 
 static const u8 sbp2_speedto_max_payload[] = { 0x7, 0x8, 0x9, 0xA, 0xB, 0xC };
 
+static DEFINE_RWLOCK(sbp2_hi_logical_units_lock);
+
 static struct hpsb_highlevel sbp2_highlevel = {
 	.name		= SBP2_DEVICE_NAME,
 	.host_reset	= sbp2_host_reset,
@@ -732,6 +734,7 @@ static struct sbp2_lu *sbp2_alloc_device
 	struct sbp2_fwhost_info *hi;
 	struct Scsi_Host *shost = NULL;
 	struct sbp2_lu *lu = NULL;
+	unsigned long flags;
 
 	lu = kzalloc(sizeof(*lu), GFP_KERNEL);
 	if (!lu) {
@@ -784,7 +787,9 @@ static struct sbp2_lu *sbp2_alloc_device
 
 	lu->hi = hi;
 
+	write_lock_irqsave(&sbp2_hi_logical_units_lock, flags);
 	list_add_tail(&lu->lu_list, &hi->logical_units);
+	write_unlock_irqrestore(&sbp2_hi_logical_units_lock, flags);
 
 	/* Register the status FIFO address range. We could use the same FIFO
 	 * for targets at different nodes. However we need different FIFOs per
@@ -828,16 +833,20 @@ static void sbp2_host_reset(struct hpsb_
 {
 	struct sbp2_fwhost_info *hi;
 	struct sbp2_lu *lu;
+	unsigned long flags;
 
 	hi = hpsb_get_hostinfo(&sbp2_highlevel, host);
 	if (!hi)
 		return;
+
+	read_lock_irqsave(&sbp2_hi_logical_units_lock, flags);
 	list_for_each_entry(lu, &hi->logical_units, lu_list)
 		if (likely(atomic_read(&lu->state) !=
 			   SBP2LU_STATE_IN_SHUTDOWN)) {
 			atomic_set(&lu->state, SBP2LU_STATE_IN_RESET);
 			scsi_block_requests(lu->shost);
 		}
+	read_unlock_irqrestore(&sbp2_hi_logical_units_lock, flags);
 }
 
 static int sbp2_start_device(struct sbp2_lu *lu)
@@ -919,6 +928,7 @@ alloc_fail:
 static void sbp2_remove_device(struct sbp2_lu *lu)
 {
 	struct sbp2_fwhost_info *hi;
+	unsigned long flags;
 
 	if (!lu)
 		return;
@@ -933,7 +943,9 @@ static void sbp2_remove_device(struct sb
 	flush_scheduled_work();
 	sbp2util_remove_command_orb_pool(lu, hi->host);
 
+	write_lock_irqsave(&sbp2_hi_logical_units_lock, flags);
 	list_del(&lu->lu_list);
+	write_unlock_irqrestore(&sbp2_hi_logical_units_lock, flags);
 
 	if (lu->login_response)
 		dma_free_coherent(hi->host->device.parent,
@@ -1707,6 +1719,7 @@ static int sbp2_handle_status_write(stru
 	}
 
 	/* Find the unit which wrote the status. */
+	read_lock_irqsave(&sbp2_hi_logical_units_lock, flags);
 	list_for_each_entry(lu_tmp, &hi->logical_units, lu_list) {
 		if (lu_tmp->ne->nodeid == nodeid &&
 		    lu_tmp->status_fifo_addr == addr) {
@@ -1714,6 +1727,8 @@ static int sbp2_handle_status_write(stru
 			break;
 		}
 	}
+	read_unlock_irqrestore(&sbp2_hi_logical_units_lock, flags);
+
 	if (unlikely(!lu)) {
 		SBP2_ERR("lu is NULL - device is gone?");
 		return RCODE_ADDRESS_ERROR;
_
