From 805fa07d7f45a5634d311d0b3d8c0c071c8cfbf2 Mon Sep 17 00:00:00 2001
From: Michael Prokop <mika@grml.org>
Date: Sat, 8 Mar 2008 15:27:58 +0000
Subject: [PATCH 2/4] Apply 4000_ipw2200-1.1.4-inject.patch


Signed-off-by: Michael Prokop <mika@grml.org>

diff --git a/drivers/net/wireless/ipw2200.c b/drivers/net/wireless/ipw2200.c
index a56d9fc..4b43fc8 100644
--- a/drivers/net/wireless/ipw2200.c
+++ b/drivers/net/wireless/ipw2200.c
@@ -1906,6 +1906,66 @@ static ssize_t show_channels(struct device *d,
 
 static DEVICE_ATTR(channels, S_IRUSR, show_channels, NULL);
 
+static int ipw_tx_skb(struct ipw_priv *priv, struct ieee80211_txb *txb, int pri);
+
+/* SYSFS INJECT */
+static ssize_t store_inject(struct device *d,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+	struct device_attribute *attr,
+#endif
+	const char *buf, size_t count) 
+{
+	struct ipw_priv *priv = (struct ipw_priv *)d->driver_data;
+	struct ieee80211_device *ieee = priv->ieee;
+	struct ieee80211_txb * txb;
+	struct sk_buff *skb_frag;
+	unsigned char * newbuf;
+	unsigned long flags;
+
+	// should test (ieee->is_queue_full) 
+	
+	// Fw only accepts data, so avoid accidental fw errors.
+	if ( (buf[0]&0x0c) != '\x08') {
+		//printk("ipw2200: inject: discarding non-data frame (type=%02X)\n",(int)(unsigned char)buf[0]);
+		return count;
+	}
+
+	if (count>1500) {
+		count=1500;
+		printk("ipw2200: inject: cutting down frame to 1500 bytes\n");
+	}
+	
+	spin_lock_irqsave(&priv->lock, flags);
+
+	// Create a txb with one skb
+	txb = kmalloc(sizeof(struct ieee80211_txb) + sizeof(u8 *), GFP_ATOMIC);
+	if (!txb)
+		goto nosepuede;
+	txb->nr_frags=1;
+	txb->frag_size = ieee->tx_headroom;
+	txb->fragments[0]=__dev_alloc_skb(count + ieee->tx_headroom, GFP_ATOMIC);
+	if (!txb->fragments[0]) {
+		kfree(txb);
+		goto nosepuede;
+	}
+	skb_reserve(txb->fragments[0], ieee->tx_headroom);
+	txb->encrypted=0;
+	txb->payload_size=count;
+	skb_frag = txb->fragments[0];
+	newbuf=skb_put(skb_frag, count);
+
+	// copy data into txb->skb and send it
+	memcpy(newbuf, buf, count);
+	
+	ipw_tx_skb(priv, txb, 0);
+
+nosepuede:
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return count;
+}
+
+static DEVICE_ATTR(inject, S_IWUSR, NULL, store_inject);
+
 static void notify_wx_assoc_event(struct ipw_priv *priv)
 {
 	union iwreq_data wrqu;
@@ -11497,6 +11557,7 @@ static struct attribute *ipw_sysfs_entries[] = {
 #ifdef CONFIG_IPW2200_PROMISCUOUS
 	&dev_attr_rtap_iface.attr,
 	&dev_attr_rtap_filter.attr,
+	&dev_attr_inject.attr,
 #endif
 	NULL
 };
-- 
1.5.4.3

