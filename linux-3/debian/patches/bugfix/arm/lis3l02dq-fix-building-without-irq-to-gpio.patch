From 65cb587d7058441c8c910e8766ee86538c7274d8 Mon Sep 17 00:00:00 2001
From: Arnd Bergmann <arnd@arndb.de>
Date: Fri, 28 Sep 2012 22:36:00 +0100
Subject: [PATCH] staging/iio/lis3l02dq: fix building without irq_to_gpio

The driver has not been building for some time after the
irq_to_gpio function has been removed from the kernel.

The only board in the upstream kernel that provides
this device is the "Stargate 2", which is also maintained
by Jonathan Cameron. Rather than working around the problem
by adding new platform data for this driver, this patch
uses the of_gpio framework to get to the gpio number.

However, the stargate2 code does not (yet) use DT based
probing, so it is still broken, but at least building
allyesconfig works again.

Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Cc: Lars-Peter Clausen <lars@metafoo.de>
Cc: Jonathan Cameron <jic23@kernel.org>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Jonathan Cameron <jic23@kernel.org>
---
 drivers/staging/iio/accel/lis3l02dq.h      |    1 +
 drivers/staging/iio/accel/lis3l02dq_core.c |   10 ++++++----
 drivers/staging/iio/accel/lis3l02dq_ring.c |    2 +-
 3 files changed, 8 insertions(+), 5 deletions(-)

Index: experimental/drivers/staging/iio/accel/lis3l02dq.h
===================================================================
--- experimental.orig/drivers/staging/iio/accel/lis3l02dq.h	2012-12-03 20:39:49.000000000 +0100
+++ experimental/drivers/staging/iio/accel/lis3l02dq.h	2012-12-05 11:32:50.159603549 +0100
@@ -158,6 +158,7 @@ struct lis3l02dq_state {
 	struct spi_device		*us;
 	struct iio_trigger		*trig;
 	struct mutex			buf_lock;
+	int				gpio;
 	bool				trigger_on;
 
 	u8	tx[LIS3L02DQ_MAX_RX] ____cacheline_aligned;
Index: experimental/drivers/staging/iio/accel/lis3l02dq_core.c
===================================================================
--- experimental.orig/drivers/staging/iio/accel/lis3l02dq_core.c	2012-12-03 20:39:49.000000000 +0100
+++ experimental/drivers/staging/iio/accel/lis3l02dq_core.c	2012-12-05 11:32:50.159603549 +0100
@@ -15,6 +15,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/mutex.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
@@ -690,6 +691,7 @@ static int __devinit lis3l02dq_probe(str
 	spi_set_drvdata(spi, indio_dev);
 
 	st->us = spi;
+	st->gpio = of_get_gpio(spi->dev.of_node, 0);
 	mutex_init(&st->buf_lock);
 	indio_dev->name = spi->dev.driver->name;
 	indio_dev->dev.parent = &spi->dev;
@@ -711,7 +713,7 @@ static int __devinit lis3l02dq_probe(str
 		goto error_unreg_buffer_funcs;
 	}
 
-	if (spi->irq && gpio_is_valid(irq_to_gpio(spi->irq)) > 0) {
+	if (spi->irq) {
 		ret = request_threaded_irq(st->us->irq,
 					   &lis3l02dq_th,
 					   &lis3l02dq_event_handler,
@@ -738,10 +740,10 @@ static int __devinit lis3l02dq_probe(str
 	return 0;
 
 error_remove_trigger:
-	if (spi->irq && gpio_is_valid(irq_to_gpio(spi->irq)))
+	if (spi->irq)
 		lis3l02dq_remove_trigger(indio_dev);
 error_free_interrupt:
-	if (spi->irq && gpio_is_valid(irq_to_gpio(spi->irq)) > 0)
+	if (spi->irq)
 		free_irq(st->us->irq, indio_dev);
 error_uninitialize_buffer:
 	iio_buffer_unregister(indio_dev);
@@ -796,7 +798,7 @@ static int lis3l02dq_remove(struct spi_d
 	if (ret)
 		goto err_ret;
 
-	if (spi->irq && gpio_is_valid(irq_to_gpio(spi->irq)) > 0)
+	if (spi->irq)
 		free_irq(st->us->irq, indio_dev);
 
 	lis3l02dq_remove_trigger(indio_dev);
Index: experimental/drivers/staging/iio/accel/lis3l02dq_ring.c
===================================================================
--- experimental.orig/drivers/staging/iio/accel/lis3l02dq_ring.c	2012-12-03 20:39:49.000000000 +0100
+++ experimental/drivers/staging/iio/accel/lis3l02dq_ring.c	2012-12-05 11:32:50.183603549 +0100
@@ -264,7 +264,7 @@ static int lis3l02dq_trig_try_reen(struc
 	/* If gpio still high (or high again) */
 	/* In theory possible we will need to do this several times */
 	for (i = 0; i < 5; i++)
-		if (gpio_get_value(irq_to_gpio(st->us->irq)))
+		if (gpio_get_value(st->gpio))
 			lis3l02dq_read_all(indio_dev, NULL);
 		else
 			break;
